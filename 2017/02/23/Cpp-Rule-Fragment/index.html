<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    <title>Cpp Rule Fragment | atlantic8</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="变量和基本类型初始化列表初始化C++11中，一下初始化方法都是成立的1234int x = 0;int x = &amp;#123;0&amp;#125;;int x&amp;#123;0&amp;#125;;int x(0); 使用花括号初始化变量在C++11中得到全面应用，但是用于内置类型的变量时，使用花括号初始化形式有个重要的特点： 使用列表初始化且初始化存在丢失信息的风险，编译器将报错 比如 123double db =">
<meta name="keywords" content="Cpp">
<meta property="og:type" content="article">
<meta property="og:title" content="Cpp Rule Fragment">
<meta property="og:url" content="atlantic8.github.io/2017/02/23/Cpp-Rule-Fragment/index.html">
<meta property="og:site_name" content="atlantic8">
<meta property="og:description" content="变量和基本类型初始化列表初始化C++11中，一下初始化方法都是成立的1234int x = 0;int x = &amp;#123;0&amp;#125;;int x&amp;#123;0&amp;#125;;int x(0); 使用花括号初始化变量在C++11中得到全面应用，但是用于内置类型的变量时，使用花括号初始化形式有个重要的特点： 使用列表初始化且初始化存在丢失信息的风险，编译器将报错 比如 123double db =">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-12-16T14:08:06.201Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Cpp Rule Fragment">
<meta name="twitter:description" content="变量和基本类型初始化列表初始化C++11中，一下初始化方法都是成立的1234int x = 0;int x = &amp;#123;0&amp;#125;;int x&amp;#123;0&amp;#125;;int x(0); 使用花括号初始化变量在C++11中得到全面应用，但是用于内置类型的变量时，使用花括号初始化形式有个重要的特点： 使用列表初始化且初始化存在丢失信息的风险，编译器将报错 比如 123double db =">
    

    

    
        <link rel="icon" href="/css/images/logo.png">
    

    <link rel="stylesheet" href="/libs/font-awesome5/css/fontawesome.min.css">
    <link rel="stylesheet" href="/libs/font-awesome5/css/fa-brands.min.css">
    <link rel="stylesheet" href="/libs/font-awesome5/css/fa-solid.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?ff86ad40748d96af89d192e9b0a3ae62";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    


</head>
</html>
<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">atlantic8</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories/OJ">OJ</a>
                
                    <a class="main-nav-link" href="/categories/Algorithm">Algorithm</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/f35.png" />
                            <i class="fas fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fas fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories/OJ">OJ</a></td>
                
                    <td><a class="main-nav-link" href="/categories/Algorithm">Algorithm</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/f35.png" />
            <h2 id="name">Atlantic8</h2>
            <h3 id="title">algorithm engineer</h3>
            <span id="location"><i class="fas fa-map-marker-alt" style="padding-right: 5px"></i>Beijing, China</span>
            <a id="follow" target="_blank" href="https://github.com/Atlantic8">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                118
                <span>文章</span>
            </div>
            <div class="article-info-block">
                44
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/Atlantic8" target="_blank" title="github" class=tooltip>
                            
                                <i class="fab fa-github"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://www.linkedin.com/in/wenqiang-cao-704236b8/" target="_blank" title="linkedin" class=tooltip>
                            
                                <i class="fab fa-linkedin"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="mailto:atlantic8@outlook.com" target="_blank" title="envelope" class=tooltip>
                            
                                <i class="fas fa-envelope"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="http://weibo.com/2614093607" target="_blank" title="weibo" class=tooltip>
                            
                                <i class="fab fa-weibo"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="facebook" class=tooltip>
                            
                                <i class="fab fa-facebook"></i>
                            
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-Cpp-Rule-Fragment" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            Cpp Rule Fragment
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/02/23/Cpp-Rule-Fragment/">
            <time datetime="2017-02-23T00:50:23.000Z" itemprop="datePublished">2017-02-23</time>
        </a>
    </div>


                        
                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Cpp/">Cpp</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h4 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><h6 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h6><p>C++11中，一下初始化方法都是成立的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>使用花括号初始化变量在C++11中得到全面应用，但是用于内置类型的变量时，使用花括号初始化形式有个重要的特点：</p>
<pre><code>使用列表初始化且初始化存在丢失信息的风险，编译器将报错
</code></pre><p>比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> db = <span class="number">3.141592653</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;db&#125;;              <span class="comment">// 错误，转换存在丢失信息的风险</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y</span><span class="params">(db)</span></span>;              <span class="comment">// 正确，转换执行，丢失部分信息</span></span><br></pre></td></tr></table></figure>
<h6 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h6><p>如果内置类型的变量未被显示初始化，它的值由定义的位置决定。<strong>定义与任何函数体之外的变量初始化为0，定义于函数体内部的内置类型将不会被初始化</strong>。</p>
<h5 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h5><ul>
<li>声明使得名字为程序所知，定义负责创建与名字关联的实体</li>
<li>只声明一个变量而非定义它，使用<code>extern</code>关键字，不要显示初始化</li>
<li>任何包含了显示初始化的声明即成了定义</li>
<li>变量只能定义一次，但是可以声明多次</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="keyword">int</span> i;     <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">int</span> j;            <span class="comment">// 声明且定义</span></span><br><span class="line">extern <span class="keyword">int</span> k = <span class="number">2</span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<h5 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h5><h6 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h6><ul>
<li>引用必须被初始化，因为引用是要和初始值绑定到一起的</li>
<li>引用不能被重新绑定到另一个对象</li>
<li>引用不能被绑定到字面值、表达式计算结果</li>
<li>引用类型要与绑定对象类型严格匹配，只在极少数情况下有例外</li>
<li>因为引用不是对象，所以不能创建引用的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>, &amp;y = x, z=<span class="number">20</span>;</span><br><span class="line">&amp;y = z;         <span class="comment">// 错误，不能重新绑定</span></span><br><span class="line">y = z;          <span class="comment">// 正确，相当于赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;i = <span class="number">10</span>;   <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">double</span> j = <span class="number">2.55</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;k = j;    <span class="comment">// 错误，类型不匹配</span></span><br></pre></td></tr></table></figure>
<h6 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h6><ul>
<li>指针是一个对象，可以有指针的指针，且无需定义时赋初值</li>
<li>指针类型要与其指向对象类型严格匹配，只在极少数情况下有例外</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成空指针的方法</span></span><br><span class="line"><span class="keyword">int</span> *p1 = nullptr;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3 = NULL;</span><br></pre></td></tr></table></figure>
<p>void*指针</p>
<ul>
<li>可以存放任意对象的地址</li>
<li>不能直接操作void*指针指向的对象，因为不知道其类型</li>
</ul>
<h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><ul>
<li>const对象必须初始化，一旦创建，不能修改</li>
<li>利用一个对象去初始化另一个对象，无论他们是不是const都无关紧要，因为拷贝不会改变什么</li>
<li>默认情况下，const变量尽在文件内有效</li>
<li>多个文件共享的方法：声明、定义都添加extern关键字</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file 1，定义、初始化</span></span><br><span class="line">extern <span class="keyword">const</span> <span class="keyword">int</span> x = getSize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// file 2，再次声明一下，与file 1中的是同一个</span></span><br><span class="line">extern <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure>
<h6 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h6><ul>
<li>不能通过引用改变常量的值</li>
<li>初始化常量引用时允许用任意表达式作为初始值，只要表达式结果能转换成引用类型即可</li>
<li><strong>允许为一个常量引用绑定非常量对象、字面值，甚至表达式</strong>，非常量不行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i; <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>; <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span>; <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1*<span class="number">2</span>;     <span class="comment">// 错误，r4是非常量引用</span></span><br></pre></td></tr></table></figure>
<h6 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h6><p><strong>指向常量的指针</strong></p>
<ul>
<li><strong>允许指向常量的指针指向非常量对象</strong></li>
<li>常量对象的地址只能存在指向常量的指针里</li>
</ul>
<p><strong>常量指针</strong></p>
<ul>
<li>常量指针是常量，必须初始化，且一旦初始化就不能改变，但其指向的对象可以被改变</li>
</ul>
<p><strong>顶层const</strong><br>顶层const表示指针本身是个常量，顶层const表示指针指向一个常量<br>左为底，右为顶即可分辨<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k=<span class="number">0</span>; <span class="comment">// 这个也是顶层const</span></span><br></pre></td></tr></table></figure></p>
<h6 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h6><ul>
<li>常量表达式的值不会改变，且在编译时期就能得到结果</li>
<li>C++11中将变量声明为constexpr类型，由编译器验证变量的值是否为常量表达式</li>
<li><strong>声明为constexpr的变量一定是常量，且必须用常量表达式初始化</strong></li>
<li>一个constexpr指针的初始值必须是nullprt或者0，或是存储与某个固定地址（比如全局变量，局部变量不行）中的对象</li>
<li>constexpr声明的指针，仅对指针有约束，不能约束指向的对象，顶层const</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="keyword">int</span> * p = nullptr; <span class="comment">// p是指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<h5 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h5><h6 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h6><p><strong>typedef</strong>和<strong>别名声明</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">double</span> wage, *p; <span class="comment">// wage是double同义词，p相当于double*</span></span><br><span class="line"></span><br><span class="line">using vi = vector;</span><br></pre></td></tr></table></figure></p>
<h6 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h6><ul>
<li>auto定义的变量必须有初始值</li>
<li>auto可以一次声明多个变量，但是这些变量的初始基本数据类型必须一样</li>
<li>auto推断的类型与原始类型可能会不太一样，比如<strong>auto会忽略掉顶层const</strong></li>
<li>引用类型也可以是auto，原来初始化规则适用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">auto a = i;       <span class="comment">// a是一个整数，顶层const被忽略</span></span><br><span class="line"><span class="keyword">const</span> auto b = i; <span class="comment">// b是一个const int</span></span><br><span class="line"></span><br><span class="line">auto &amp;c = i;</span><br><span class="line">auto &amp;d = <span class="number">42</span>; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> auto &amp;e = <span class="number">42</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h6 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h6><ul>
<li>decltype的作用是<strong>选择并返回操作数的严格基本类型</strong></li>
<li>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括const和引用）</li>
<li>如果表达式内容是解引用，decltype得到引用类型</li>
<li>如果<strong>变量名加上了一层或多层括号，就会被当成表达式，会得到引用类型</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>, &amp;cj=ci;</span><br><span class="line">decltype(ci) x=<span class="number">0</span>;  <span class="comment">// x为const int</span></span><br><span class="line">decltype(cj) y=x;  <span class="comment">// y为const int&amp;，y绑定到x</span></span><br><span class="line">decltype(cj) z;    <span class="comment">// 错误，z是引用，必须初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>, *p=&amp;i;</span><br><span class="line">decltype(*p) c;    <span class="comment">// 错误，c是int&amp;，必须初始化</span></span><br><span class="line"></span><br><span class="line">decltype(i) m;     <span class="comment">// 正确，一个未初始化的int</span></span><br><span class="line">decltype((i)) n;   <span class="comment">// 错误，int&amp; 必须初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串，向量，数组"><a href="#字符串，向量，数组" class="headerlink" title="字符串，向量，数组"></a>字符串，向量，数组</h4><p>数组不允许直接拷贝、赋值</p>
<h5 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h5><p>字符数组可以使用字符串字面值进行初始化，但字符串结尾处还有一个空字符<code>&#39;\0&#39;</code>，这个空字符也会被拷贝到数组中去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'c'</span>,<span class="string">'+'</span>, <span class="string">'+'</span>&#125;;         <span class="comment">// 长度为3</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">'c'</span>,<span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;  <span class="comment">// 长度为4</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"c++"</span>;              <span class="comment">// 长度为4</span></span><br><span class="line"><span class="keyword">char</span> a4[<span class="number">3</span>] = <span class="string">"c++"</span>;            <span class="comment">// 错误，数组空间不足</span></span><br></pre></td></tr></table></figure>
<h5 id="负载数组声明"><a href="#负载数组声明" class="headerlink" title="负载数组声明"></a>负载数组声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr[<span class="number">10</span>];           <span class="comment">// 含义10个整型指针的数组 </span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]=<span class="comment">/*...*/</span>  <span class="comment">// 不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>];     <span class="comment">// 指向一个10个整型元素数组的指针</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>]     <span class="comment">// 引用一个10个整型元素数组的指针</span></span><br></pre></td></tr></table></figure>
<h5 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h5><h6 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h6><p><strong><code>static_cast</code>可以完成任何具有明确定义的类型转换(支持强制转换)，只要不包含底层const</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> slope = static_cast&lt;<span class="keyword">double</span>&gt;(j) / i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p = &amp;d;</span><br><span class="line"><span class="keyword">double</span> *dp = static_cast&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure></p>
<h6 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h6><p><strong><code>const_cast</code>只能改变运算对象的底层const</strong>，通常用于有函数重载的上下文中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p = const_cast&lt;<span class="keyword">char</span>*&gt;(pc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp;</span><br><span class="line"><span class="keyword">char</span> *q = static_cast&lt;<span class="keyword">char</span>*&gt;(cp);  <span class="comment">// 错误，static_cast不能转换掉const性质</span></span><br><span class="line">static_cast&lt;string&gt;(cp);           <span class="comment">// 正确，字符串字面值转换成string属性</span></span><br><span class="line"><span class="keyword">const</span>&lt;string&gt;(cp);                 <span class="comment">// 错误，const_cast只改变常量属性</span></span><br></pre></td></tr></table></figure></p>
<h6 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h6><p><strong><code>reinterpret_cast</code>通常为运算对象的位模式提供较低层次上的重新解释</strong>，容易引发错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *cp = reinterpret_cast&lt;<span class="keyword">char</span>*&gt;(ip); <span class="comment">// 虽然转换，但pc所指对象依旧是int型</span></span><br></pre></td></tr></table></figure></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><ul>
<li><strong>用实参初始化形参时会忽略掉顶层const，也就是说给形参传递常量对象或者非常量对象都可以</strong></li>
<li>由于顶层const被忽略，只有形参顶层const差异的函数会被当成同一个函数</li>
<li><strong>可以使用一个非常量初始化一个底层const对象，但是反过来不行</strong></li>
<li><strong>普通引用必须用同类型的对象初始化</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;...&#125;        <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;...&#125;  <span class="comment">// 错误，重复定义func</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span>&#123;i=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line">string::size_type ctr = <span class="number">0</span>;</span><br><span class="line">reset(&amp;i);           <span class="comment">// 调用形参类型是int*的reset函数</span></span><br><span class="line">reset(i);            <span class="comment">// 调用形参类型是int&amp;的reset函数</span></span><br><span class="line">reset(&amp;ci);          <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br><span class="line">reset(ci);           <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br><span class="line">reset(<span class="number">42</span>);           <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br><span class="line">reset(ctr);          <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br></pre></td></tr></table></figure>
<h5 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h5><ul>
<li>一般函数的返回值均为右值，但也有返回左值的函数</li>
<li>由函数的返回值类型决定，具体来说，<strong>调用一个返回引用的函数得到左值，其他类型为右值</strong></li>
<li><strong>左值可以被赋值，右值不行</strong></li>
<li>如果返回值类型是常量引用，那么就不能赋值了（常量不能修改啊）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;get_val(string &amp;s, string::size_type ix) &#123; <span class="comment">//返回的是引用</span></span><br><span class="line">    <span class="keyword">return</span> s[ix];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line">get_val(s,<span class="number">3</span>) = <span class="string">'A'</span>;       <span class="comment">// 可以对左值进行赋值</span></span><br></pre></td></tr></table></figure>
<h5 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h5><p>普通的数组指针声明如下</p>
<pre><code>type (*name)[dimension]
</code></pre><p>返回数组指针的函数形式如下</p>
<pre><code>type ( *function(parameter_list) ) [dimension]
</code></pre><h6 id="类型别名-1"><a href="#类型别名-1" class="headerlink" title="类型别名"></a>类型别名</h6><p>也可以考虑使用类型别名</p>
<pre><code>typedef int arrT[10];
using arrT = int[10];
arrt* func(int i);
</code></pre><h6 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h6><ul>
<li>任何函数都可以使用尾置返回类型</li>
<li>这种返回方法对复杂的返回类型比较有效</li>
<li>尾置返回类型跟在形参列表后面，以<code>-&gt;</code>开头，在原本返回类型出现的地方加上<code>auto</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span> [10]</span>;</span><br></pre></td></tr></table></figure>
<h6 id="使用decltype"><a href="#使用decltype" class="headerlink" title="使用decltype"></a>使用decltype</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// decltype(odd) 返回的是数组，需要在加一个*变成指针</span></span><br><span class="line">decltype(odd) * func(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="comment">// ...........</span></span><br><span class="line">2<span class="keyword">return</span> &amp;odd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><ul>
<li>重载函数的名字肯定一样，需要形参类型或者数量上有差异</li>
<li>仅仅返回值不一样不是重载函数，而是重定义</li>
<li><strong>仅有顶层const的差异不构成重载，底层const可以</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;      <span class="comment">// 顶层const，重复定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *i)</span></span>;     <span class="comment">// 底层const，重载函数，指针换引用也一样</span></span><br></pre></td></tr></table></figure>
<h6 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h6><ul>
<li><strong>如果在内层作用域中声明名字，它将隐藏外层作用域中所有同名的实体</strong></li>
<li>声明在内部作用域的名字可能会是外部作用域中同名的所有重载函数失效（不声明名字就没事）</li>
<li>不同的作用域中无法承载函数名</li>
</ul>
<h5 id="默认语言用途"><a href="#默认语言用途" class="headerlink" title="默认语言用途"></a>默认语言用途</h5><h6 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h6><ul>
<li>默认实参填补函数调用缺少的尾部实参，所以默认形参都在尾部</li>
<li>尾部参数没省略时，中间参数不能省略</li>
<li>给定作用域中，一个形参只能被赋予一次默认实参</li>
<li><strong>局部变量不能成为默认实参</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span>=<span class="string">' '</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span>=<span class="string">'*'</span>)</span></span>;  <span class="comment">// 错误，重复声明</span></span><br></pre></td></tr></table></figure>
<h6 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h6><ul>
<li>优先选择精确匹配、最匹配，所谓最匹配要看实参与形参的接近程度</li>
<li>有且只有一个函数满足以下条件，则匹配成功<ul>
<li>该函数每个函数的匹配都不劣与其他函数需要的匹配</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配</li>
</ul>
</li>
<li>上面两步检查后没有函数脱颖而出，那么判定为二义性，报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>,<span class="number">2.5</span>);</span><br></pre></td></tr></table></figure>
<p>上面的例子中，对于第一个实参，<code>f(int,int)</code>好；对于第二个实参，<code>f(double,double)</code>好。最终判断此调用具有二义性，拒绝请求。</p>
<p>实参到形参的类型转换分为几个等级，如下</p>
<ol>
<li>精确匹配<ul>
<li>实参、形参类型相同</li>
<li>实参从数组或函数类型转化成对应的指针</li>
<li>向实参添加顶层const、从实参中删除顶层const</li>
</ul>
</li>
<li>通过const转换实现的匹配（比如创建指向非常量的常量指针、引用）</li>
<li>通过类型提升实现的匹配（short+int=int整型提升）</li>
<li>通过算术类型转换（int转double，所有算术类型转换级别一样）或指针实现的匹配</li>
<li>通过类类型转换实现的匹配</li>
</ol>
<h5 id="inline和constexpr"><a href="#inline和constexpr" class="headerlink" title="inline和constexpr"></a>inline和constexpr</h5><ul>
<li>inline函数编译时，一般适用于代码量很少的函数</li>
<li>const是指用于常量表达式的函数，返回类型及所有形参都必须是字面值类型，并且要求有且只有一个return语句</li>
<li>inline函数和constexpr函数可以多次定义，且通常定义在头文件内</li>
</ul>
<h5 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h5><h6 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h6><p>assert的用法是<code>assert(expr);</code>，如果表达式expr的值为true，assert什么也不做；否则，assert输出信息并终止程序执行。</p>
<h6 id="NDEBUG"><a href="#NDEBUG" class="headerlink" title="NDEBUG"></a>NDEBUG</h6><p>如果定义了NDEBUG，那么调试模式就关闭了，assert就不能起作用了。此外，NDEBUG也有助于开发者编写自己的调试代码。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define NDEBUG  // 表示关闭了调试模式</span><br><span class="line"></span><br><span class="line"># ifndef NDEBUG  // 没有关闭调试模式</span><br><span class="line"><span class="comment">// 。。。。</span></span><br><span class="line"># endif</span><br></pre></td></tr></table></figure></p>
<h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><ul>
<li>函数指针也是指针，可以赋值为nullptr、0等</li>
<li>指向不同函数类型的函数指针不存在类型转换</li>
<li><strong>定义重载函数指针时，指针类型必须与重载函数中的某一个精确匹配</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 定义函数指针</span></span><br><span class="line">bool (*pf)(<span class="keyword">int</span>) = func;     <span class="comment">// 定义指向函数func的函数指针</span></span><br><span class="line">bool (*pf)(<span class="keyword">int</span>) = &amp;func   <span class="comment">// 与上面等价</span></span><br><span class="line"><span class="comment">// 使用函数指针</span></span><br><span class="line">pf(<span class="number">1</span>);</span><br><span class="line">(*pf)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><strong>C++中，形参和返回值都不能是函数，但可以是函数指针</strong>，使用类型别名、decltype等可以使得函数指针的声明变得简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价的两种定义方式，funcp可以使用在函数实参、返回值</span></span><br><span class="line"><span class="function">typedef <span class="title">bool</span> <span class="params">(*funcp)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">typedef <span class="title">decltype</span><span class="params">(func)</span> *funcp</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用using、尾置返回类型</span></span><br><span class="line">using pf = bool(*) (<span class="keyword">int</span>);  <span class="comment">// pf是函数指针</span></span><br><span class="line"><span class="function">pf <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">using f  = bool (<span class="keyword">int</span>);     <span class="comment">// f类型是函数</span></span><br><span class="line">f *f1(<span class="keyword">int</span>);                    <span class="comment">// 显示指定返回类型是指向函数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function">auto <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> -&gt; <span class="title">bool</span><span class="params">(*)</span> <span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 尾置返回类型指定返回类型</span></span><br><span class="line">decltype(func) *f1(<span class="keyword">int</span>);        <span class="comment">// 知道返回的函数是哪一个更方便</span></span><br></pre></td></tr></table></figure></p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h5><h6 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h6><ul>
<li>const成员函数不能改变调用它的对象的内容</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">const_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回this对象的函数</span></span><br><span class="line"><span class="comment">// 返回值是引用</span></span><br><span class="line">New_Class&amp; New_Class::hello () &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">2attribute += <span class="number">1</span>;</span><br><span class="line">2<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">New_Class nc;</span><br><span class="line">nc.hello();  <span class="comment">// nc的attribute属性已经改变了</span></span><br></pre></td></tr></table></figure>
<h6 id="类相关的非成员函数"><a href="#类相关的非成员函数" class="headerlink" title="类相关的非成员函数"></a>类相关的非成员函数</h6><ul>
<li>这里的相关非成员函数包括但不限于<code>read</code>、<code>print</code>等</li>
<li>如果非成员函数是类接口的组成部分，这些函数的声明应当与类在同一个头文件内</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IO类型不能拷贝，所以只能以引用的形式加入形参</span></span><br><span class="line"><span class="comment">// 最后需要返回IO类型的引用</span></span><br><span class="line"><span class="comment">// ostream、print也类似，定义输出函数应该尽量减少对格式的控制</span></span><br><span class="line">istream &amp;read(istream &amp;is, New_Class &amp;item) &#123;</span><br><span class="line">    is &gt;&gt; item.a1 &gt;&gt; item.a2 &gt;&gt; item.a3;</span><br><span class="line">2<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">istream &amp;is;</span><br><span class="line">read(is, *<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><ul>
<li><strong>构造函数不能为const</strong></li>
<li><strong>const对象和引用都应该在初始值列表中初始化</strong></li>
<li>初始化列表：成员初始化的顺序与类定义中的顺序一致</li>
<li>构造const对象时，知道构造函数完成其初始化过程，对象才能取得其“常量”属性</li>
<li>默认构造函数的规则如下：<ul>
<li>如果有别的构造函数，编译器不会生成默认构造函数</li>
<li><strong>如果存在类内初始值，用它来初始化成员</strong></li>
<li>否则，默认初始化（string为””，int块外为0，块内未定义）</li>
</ul>
</li>
<li>C++11中，如果需要默认行为可以在参数列表之后写上 <code>=default</code>要求编译器生成默认构造函数</li>
<li><strong>当某个数据成员被构造函数初始值列表忽略时，它将以合成默认构造函数相同的方式隐式初始化</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有其他构造函数的情况下，还想要默认构造函数可以这样</span></span><br><span class="line">New_Class() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过默认参数也等与实现了默认构造函数</span></span><br><span class="line">New_Class(string s = <span class="string">" "</span>):name(s)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>委托构造函数</strong>就是利用其他构造函数执行自己的初始化过程，其在参数列表初始化位置调用其他构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New_Class() : New_Class(<span class="string">"zhangsan"</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="隐式类类型转换"><a href="#隐式类类型转换" class="headerlink" title="隐式类类型转换"></a>隐式类类型转换</h6><ul>
<li>通过一个实参调用的构造函数定义一条<strong>从构造函数参数类型向类类型隐式转换</strong>的规则</li>
<li>只允许一步类类型转换，隐式转换可能会出错</li>
<li>抑制隐式转换的方法是在构造函数前加上关键字<code>explicit</code></li>
<li>使用<code>static_cast</code>这样的显式转换也能达到转换的效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string lisi = <span class="string">"lisi"</span>;</span><br><span class="line"><span class="function">New_Class <span class="title">zhangsan</span><span class="params">(<span class="string">"zhangsan"</span>)</span></span>;</span><br><span class="line"><span class="comment">// playWith函数的参数类型是New_Class</span></span><br><span class="line">zhangsan.playWith(lisi);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h5><ul>
<li>class和struct定义类时的唯一区别就是默认访问权限</li>
<li>struct默认为public，而class默认为private</li>
</ul>
<h6 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h6><ul>
<li>类中使用<code>friend</code>关键字可以使其他类或者函数成为它的友元</li>
<li>成为友元的类、函数可以访问当前类的非公有成员</li>
<li>友元不是类的成员，不受其所在区域访问控制级别的约束</li>
<li>类内友元函数的声明并非普通意义上的声明，所以在其他地方还得声明一次，即便定义在类内部也还要在外面声明</li>
<li>友元函数也可以定义在类内部，隐式inline</li>
<li><strong>友元关系不存在传递性</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class2</span> </span>&#123;</span><br><span class="line">friend <span class="class"><span class="keyword">class</span> <span class="title">Class1</span></span>;</span><br><span class="line">friend istream &amp; read(istream &amp;is, Class2 &amp; c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h6><ul>
<li>定义在类内部的成员函数自动是<code>inline</code>类型的</li>
<li><strong><code>mutable</code>成员用于不会是const，即使在const成员函数内他也是可以被改变的</strong></li>
<li>返回<code>*this</code>的函数返回的是左值引用（返回类型是引用），返回的是对象本身而不是副本</li>
</ul>
<h6 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h6><ul>
<li>所有成员都是public</li>
<li>没有定义任何构造函数</li>
<li><strong>没有类内初始值</strong></li>
<li>没有基类、没有虚函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct data &#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">2<span class="keyword">char</span> c;</span><br><span class="line">2string s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h5><ul>
<li>静态成员于类本身直接相关</li>
<li>静态成员函数不包含this指针、也不能显式、隐式地使用this指针（<strong>不能操作非静态成员</strong>）</li>
<li><strong>静态成员函数不能声明成const</strong></li>
<li>在类的外部定义静态成员时，不能重复static关键字</li>
<li>静态成员变量应该在类的外部定义</li>
<li>静态数据成员可以是不完全类型（类在声明之后、定义之前称为不完全类型）</li>
<li>静态成员可以是默认实参，非静态的不可以</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> A a;  <span class="comment">// 正确，静态成员可以使不完全类型</span></span><br><span class="line">2A b;           <span class="comment">// 错误，数据成员必须是完全类型，不过可以定义指针、引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IO库与容器库"><a href="#IO库与容器库" class="headerlink" title="IO库与容器库"></a>IO库与容器库</h4><h5 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h5><p><code>sstream</code>包含三个支持string读写的类型，分别是<code>istringstream</code>、<code>ostringstream</code>和<code>stringstream</code>。<br>sstream的使用可以如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sstream strm;</span><br><span class="line"><span class="function">sstream <span class="title">strm</span><span class="params">(s)</span></span>; <span class="comment">// strm是sstream的对象，保存string s的拷贝</span></span><br><span class="line"></span><br><span class="line">strm.str()           <span class="comment">// 返回strm所保存的string的拷贝</span></span><br><span class="line">strm.str(s)         <span class="comment">// copy string s to strm, return void</span></span><br></pre></td></tr></table></figure></p>
<p><code>istringstream</code>、<code>ostringstream</code>的用法也很简单，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">line</span><span class="params">(<span class="string">"suck my balls"</span>)</span>, word</span>;</span><br><span class="line"><span class="function">istringstream <span class="title">is</span><span class="params">(line)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (is &gt;&gt; word)</span><br><span class="line">    cout &lt;&lt; word &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>向<code>ostringstream</code>对象写入string其实就是将string添加字符。</p>
<h6 id="array"><a href="#array" class="headerlink" title="array"></a>array</h6><ul>
<li>array容器的大小是一定的，其大小也是类型的一部分</li>
<li>array容器与普通数组不同的是，array支持拷贝与赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>&gt; arr;  <span class="comment">// 错误，缺少大小</span></span><br><span class="line">array&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; arr1 <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; arr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; arr1 = arr;  <span class="comment">//正确，类型一定要一致</span></span><br></pre></td></tr></table></figure>
<h6 id="顺序容器的操作"><a href="#顺序容器的操作" class="headerlink" title="顺序容器的操作"></a>顺序容器的操作</h6><pre><code>seq.assign(b,e); // 将seq中的元素替换成迭代器b、e所表示范围中的元素
seq.assign(il);   // 将seq中的元素替换成初始化列表il中的元素，比如il={1,2,3,4}，为值列表
seq.assign(n,t); // 将seq中的元素替换成n个元素t

c.insert(p, t); // 在迭代器p之前添加元素t，返回添加元素的迭代器
c.insert(p, n, t); // 在迭代器p之前添加n个元素t，返回第一个添加的元素的迭代器
c.insert(p, b, e); // 在迭代器p之前添加迭代器b、e之间的元素
c.insert(p, il);
</code></pre><p><strong>向一个vector、string、deque插入元素会使所有的指向容器的迭代器、引用和指针失效</strong></p>
<ul>
<li><code>emplace_front, emplace_back, emplace</code>分别对应<code>push_front, push_back, insert</code></li>
<li>这些函数可以构造元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">2<span class="keyword">int</span> age;</span><br><span class="line">2person(string nm, <span class="keyword">int</span> ag);</span><br><span class="line">&#125;</span><br><span class="line">c.emplace_front(<span class="string">"zhangsan"</span>, <span class="number">10</span>); <span class="comment">// 插入10岁的zhangsan的元素</span></span><br><span class="line">c.push_front(<span class="string">"zhangsan"</span>, <span class="number">10</span>); <span class="comment">// 错误，没有接受三个参数的push_front版本</span></span><br><span class="line">c.push_front(person(<span class="string">"zhangsan"</span>,<span class="number">10</span>)); <span class="comment">// 正确，先构造对象</span></span><br></pre></td></tr></table></figure>
<p>顺序容器还支持关系运算符，从头向尾比较，比较直观。</p>
<h6 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h6><pre><code>c1.swap(c2);
swap(c1, c2);
</code></pre><ul>
<li>swap交换元素很快，因为元素本身没有交换，swap只是交换了两个容器的内部数据结构</li>
<li>array是个例外，swap真正交换元素，所以交换所需时间与元素数目成正比</li>
</ul>
<h6 id="改变容器大小、容量"><a href="#改变容器大小、容量" class="headerlink" title="改变容器大小、容量"></a>改变容器大小、容量</h6><p><strong>改变size</strong>：size是容器当前大小，采用多退少补的方法</p>
<ul>
<li>函数resize可以改变改变容器大小<code>resize(n)</code>，也可以将新添加的元素设置为t <code>resize(n,t)</code></li>
<li>array不支持</li>
</ul>
<p><strong>改变capacity</strong>：capacity是容器的最大容量</p>
<ul>
<li><code>capacity()</code>获取容量</li>
<li><code>reserve(n)</code>分布至少能容纳n个元素的内存空间</li>
<li><code>shrink_to_fit()</code>将<code>capacity</code>减少为<code>size</code>大小</li>
</ul>
<h6 id="string的搜索操作"><a href="#string的搜索操作" class="headerlink" title="string的搜索操作"></a>string的搜索操作</h6><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find(args)</td>
<td>s中args第一次出现的位置</td>
</tr>
<tr>
<td>s.rfind(args)</td>
<td>s中args最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_of(args)</td>
<td>s中查找args中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td>s.find_last_of(args)</td>
<td>s中查找args中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_not_of(args)</td>
<td>s中查找第一个不在args中的字符</td>
</tr>
<tr>
<td>s.find_last_not_of(args)</td>
<td>s中查找最后一个不在args中的字符</td>
</tr>
</tbody>
</table>
</div>
<p>其中<code>args</code>的形式为包括（pos默认为0）</p>
<pre><code>c, pos ：    pos为开始查找的位置，c是一个字符
s2, pos：    s2是字符串
cp, pos：    cp是指向c风格的字符串的指针（以&#39;\0&#39;结尾）
cp, pos, n： n表示只看前n个字符
</code></pre><p>搜索失败则返回一个名为<code>string::npos</code>的static成员，其值初始化为-1.</p>
<h6 id="string数制转换"><a href="#string数制转换" class="headerlink" title="string数制转换"></a>string数制转换</h6><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_string(val)</td>
<td>任何算术类型向string转换</td>
</tr>
<tr>
<td>stoi(s, p, b)</td>
<td>string转int，s是字符串</td>
</tr>
<tr>
<td>stol(s, p, b)</td>
<td>string转long，b是转换基数（默认为10，十进制）</td>
</tr>
<tr>
<td>stoul(s, p, b)</td>
<td>string转unsigned long，p是起始位置</td>
</tr>
<tr>
<td>stoll(s, p, b)</td>
<td>string转long long</td>
</tr>
<tr>
<td>stoull(s, p, b)</td>
<td>string转unsigned long long</td>
</tr>
<tr>
<td>stof(s, p)</td>
<td>string转float，p是起始位置</td>
</tr>
<tr>
<td>stod(s, p)</td>
<td>string转double</td>
</tr>
<tr>
<td>stold(s, p)</td>
<td>string转long double</td>
</tr>
</tbody>
</table>
</div>
<h5 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h5><p><strong>适配器是一种机制，能使某种事物的行为看起来像另外一种事物</strong><br>标准库中有三个顺序容器适配器，<code>stack、queue、priority_queue</code></p>
<h4 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h4><ul>
<li>泛型算法定义在头文件<code>numeric</code>中</li>
</ul>
<h5 id="几个基本的泛型算法"><a href="#几个基本的泛型算法" class="headerlink" title="几个基本的泛型算法"></a>几个基本的泛型算法</h5><ul>
<li><code>find(iter1, iter2, val);</code> // 元素查找，iter1、iter2迭代器至少查找的范围，val是查找的元素。查找失败返回iter2，否则返回对应的迭代器</li>
<li><code>accumulate(iter1, iter2, sum);</code>  // 元素累加，执行+运算，sum是和的初值，返回最终的和</li>
<li><code>equal(iter1, iter2, another_iter);</code>  //  比较两个序列元素是否完全一致，一致返回true。another_iter表示第二个序列的起始迭代器</li>
<li><code>fill(iter1, iter2, val);</code>  // 将迭代器范围中的每个值置为val</li>
<li><code>fill_n(iter, n, val);</code>  // 将从iter起的n个元素置为val（必须保证有n个元素）</li>
<li><code>copy(iter1, iter2, another_iter);</code>  // 将iter1-iter2范围内的元素拷贝到以another_iter起始的位置上，要求another_iter对应的容器大小不能比iter1对应的容器小，返回another_iter的位置迭代器位置</li>
<li><code>replace(iter1, iter2, val, new_val);</code>  // 迭代器范围内，将所有的val换成 new_val</li>
<li><code>replace_copy(iter1, iter2, new_iter, val, new_val);</code>  // 保持iter1对应的容器不变，将替换后的结果写入new_iter对应的容器中</li>
<li><code>unique(iter1, iter2);</code>  // 去重，返回指向不重复区域之后一个位置的迭代器</li>
</ul>
<h5 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h5><h6 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h6><pre><code>[捕获列表] (参数列表) -&gt; 返回类型 {函数体};
</code></pre><ul>
<li>lambda可以理解成未命名的inline函数</li>
<li>捕获列表：表达式所在函数的局部变量列表，局部变量间以<code>,</code>分隔，通常为空。<code>&amp;</code>引用捕获，<code>=</code></li>
<li>参数列表、返回类型、函数体和普通函数一个意思</li>
<li><strong>参数列表和返回类型可以忽略，但捕获列表和函数体必须存在</strong></li>
<li>lambda表达式的返回值是一个可调用对象，不接收参数，直接带括号调用。可调用对象包括函数、函数指针、lambda表达式等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto f = []&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125; <span class="comment">// f是可调用对象</span></span><br><span class="line">cout &lt;&lt; f() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h6 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h6><ul>
<li>头文件为<code>functional</code></li>
<li>接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表</li>
<li>可以看成一个通用的函数适配器</li>
<li><p>bind在绑定过程中都是采用参数拷贝的方式，所以对于需要引用的类型，可以使用<code>ref</code>、<code>cref</code>函数表示引用（常量c）</p>
<p>  <code>auto newCallable = bind(callable, arg_list);</code></p>
</li>
</ul>
<p><code>arg_list</code>中可能包含<code>_n</code>这样的名字（n是整数），这些是占位符，表示newCallable的参数。<code>_n</code>表示第n个参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f是有5个参数的可调用对象</span></span><br><span class="line">auto g = bind(f, a, b, _2, c, _1);</span><br><span class="line"><span class="comment">// 传递给g的参数会被分别绑定到_1、_2位置上</span></span><br><span class="line"><span class="comment">// g(X, Y) 等价于 f(a, b, Y, c, X)</span></span><br><span class="line"></span><br><span class="line">ostream &amp;print(ostream &amp;os, string &amp;s, <span class="keyword">char</span> c) &#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; s &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line">for_each(words.begin(), words.end(), bind(print, os, _1, <span class="string">' '</span>));  <span class="comment">// 错误，os不能拷贝</span></span><br><span class="line">for_each(words.begin(), words.end(), bind(print, ref(os), _1, <span class="string">' '</span>));  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p>
<h5 id="特殊迭代器"><a href="#特殊迭代器" class="headerlink" title="特殊迭代器"></a>特殊迭代器</h5><h6 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h6><p>包括<code>back_inserter, front_inserter, inserter</code>三种，分别创建使用<code>push_back, push_front, insert</code>的迭代器。<br>使用 <code>inserter(c, iter)</code>时，插入元素位置在iter位置之前，并且插入前后，iter指向的元素不变；但是<code>front_inserter(c)</code>就一直在容器头部插入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; lst2, lst3;</span><br><span class="line"><span class="comment">// 插入后lst2为 4 3 2 1</span></span><br><span class="line">copy(lst.begin(), lst.end(), front_inserter(lst2));</span><br><span class="line"><span class="comment">// 插入后lst3为 1 2 3 4</span></span><br><span class="line">copy(lst.begin(), lst.end(), inserter(lst3, lst3.begin()));</span><br></pre></td></tr></table></figure></p>
<h6 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h6><ul>
<li>使用流迭代器，必须指定读写对象的类型</li>
<li>istream_iterator迭代器要读取的内容必须定义了<code>&gt;&gt;</code>运算符，ostream_iterator迭代器要读取的内容必须定义了<code>&lt;&lt;</code>运算符</li>
<li>默认初始化istream_iterator迭代器，创建一个当作尾后值使用的迭代器</li>
<li>流迭代器不支持递减<code>--</code>操作</li>
<li>istream_iterator迭代器支持<code>++, *, -&gt;, ==,  !=</code>运算符</li>
<li>ostream_iterator迭代器支持<code>++, =,  *</code>运算符</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;T&gt; <span class="title">in</span><span class="params">(is)</span></span>;  <span class="comment">// 迭代器对象in从输入流is中读取类型为T的值</span></span><br><span class="line">istream_iterator&lt;T&gt; eof;     <span class="comment">// 尾后迭代器</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">vec</span><span class="params">(in, eof)</span></span>;  <span class="comment">// 从迭代器范围构造vector对象</span></span><br><span class="line">accumulate(in, eof, <span class="number">0</span>);   <span class="comment">// 求和</span></span><br><span class="line"></span><br><span class="line"><span class="function">ostream_iterator&lt;T&gt; <span class="title">out</span><span class="params">(os)</span></span>;  <span class="comment">// out将类型为T的输出值写入到输出流os中</span></span><br><span class="line"><span class="function">ostream_iterator&lt;T&gt; <span class="title">out</span><span class="params">(os, d)</span></span>;  <span class="comment">// out将类型为T的输出值写入到输出流os中，每个值后面都额外输出一个d（d是C风格的字符串）</span></span><br><span class="line"><span class="keyword">for</span> (anto e : vec)</span><br><span class="line">    *out++ = e;  <span class="comment">// 直接写out=e;也可以，不过不推荐这么写</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">copy(vec.begin(), vec.end(), out);</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h6 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h6><ul>
<li>在容器中从尾元素向首元素反向移动的迭代器</li>
<li>其递增、递减的操作是反过来的，即<code>++</code>会向前移动，前也是相对移动方向的</li>
<li>除了<code>forward_list</code>外都支持，使用<code>rbegin(),crbegin()</code>等</li>
</ul>
<h6 id="链表类容器的特殊方法"><a href="#链表类容器的特殊方法" class="headerlink" title="链表类容器的特殊方法"></a>链表类容器的特殊方法</h6><p><code>list、forward_list</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>lst.merge(lst2)</td>
<td>将lst2中的元素合并入lst，要求lst、lst2都必须有序</td>
</tr>
<tr>
<td>lst.merge(lst2, comp)</td>
<td>comp为特定的比较函数</td>
</tr>
<tr>
<td>lst.remove(val)</td>
<td>调用erase删除lst内与val相等的元素</td>
</tr>
<tr>
<td>lst.remove(pred)</td>
<td>调用erase删除lst内使得一元谓词pred成立的元素</td>
</tr>
<tr>
<td>lst.reverse()</td>
<td>反转lst中元素的顺序</td>
</tr>
<tr>
<td>lst.sort()</td>
<td>排序，可以使用comp</td>
</tr>
<tr>
<td>lst.unique()</td>
<td>调用erase去重</td>
</tr>
<tr>
<td>lst.unique(pred)</td>
<td>调用erase去重，重复指的是满足二元谓词pred的元素</td>
</tr>
</tbody>
</table>
</div>
<p><strong>谓词是返回可以转换为bool类型值的函数。元对应参数个数</strong></p>
<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4><ul>
<li>关联容器支持高效的关键字查询和访问，可以分为有序集合和无序集合两种</li>
<li>map和set的迭代器都不允许修改关键字<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5>| 有序类型 | 说明 |<br>|————|————|<br>|    map    |     关联数组，保存（key, value）对   |<br>|    set      |       只保存关键字      |<br>|multimap|       关键字可重复出现的map|<br>|multiset|      关键字可重复出现的set    |</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>无序类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unordered_map</td>
<td>用哈希函数组织的map</td>
</tr>
<tr>
<td>unordered_set</td>
<td>用哈希函数组织的set</td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>….</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>….</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    vec.push_back(i);</span><br><span class="line">2vec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(vec.cbegin()</span>, vec.<span class="title">cend</span><span class="params">()</span>)</span>;  <span class="comment">// 10个元素</span></span><br><span class="line"><span class="function">multiset&lt;<span class="keyword">int</span>&gt; <span class="title">imset</span><span class="params">(vec.cbegin()</span>, vec.<span class="title">cend</span><span class="params">()</span>)</span>;  <span class="comment">// 20个元素</span></span><br></pre></td></tr></table></figure>
<h5 id="关键字类型要求"><a href="#关键字类型要求" class="headerlink" title="关键字类型要求"></a>关键字类型要求</h5><ul>
<li>有序元素的关键字类型必须定义元素比较的方法</li>
<li>不支持比较的复杂类型需要自定义比较函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compareClass1是进行Class1对象比较的函数，定义时需要添加比较函数的函数指针</span></span><br><span class="line"><span class="comment">// 直接使用compareClass1也行，因为函数名会转化为函数指针</span></span><br><span class="line"><span class="comment">// 构造函数也使用比较函数的函数指针</span></span><br><span class="line">set&lt;Class1, decltype(compareClass1)*&gt; cls(compareClass1);</span><br></pre></td></tr></table></figure>
<h6 id="关联容器额外的类型别名"><a href="#关联容器额外的类型别名" class="headerlink" title="关联容器额外的类型别名"></a>关联容器额外的类型别名</h6><pre><code>key_type : 容器的关键字类型
value_type : 对于set，与key_type相同；map则是pair&lt;key, value&gt;
mapped_type : 关键字关联的类型
</code></pre><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><pre><code>c.insert(v);
c.emplace(args);
c.insert(iter1, iter2);
c.insert(il);  // 花括号列表，返回void
c.insert(iter, v); // 迭代器指示搜索新元素存储应该存储的位置。返回一个迭代器，指向具有给定关键字的元素
c.emplace(iter, args);
</code></pre><p><strong>对于不包含重复关键字的容器，添加单一元素的inert和emplace返回一个pair，指示插入操作是否成功。pair的首元素（first）是一个迭代器，指向具有指定关键字的元素；second是一个bool值，指示元素成功插入还是已经存在于容器中，成功插入为true，否则为false</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto ret = word_count.insert(&#123;<span class="string">"hello"</span>, <span class="number">1</span>&#125;); 尝试插入</span><br><span class="line"><span class="keyword">if</span> (!ret.second) <span class="comment">// 元素已经存在map中</span></span><br><span class="line">    ++ret.first-&gt;second;  <span class="comment">//  ret.first是指向“hello”关键字的迭代器，迭代器指向的second元素是原本"hello"对应的数目，加一即可</span></span><br></pre></td></tr></table></figure></p>
<h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><pre><code>c.find(k);  // 返回指向第一个key为k的迭代器
c.count(k);  // 返回关键字k的个数
c.lower_bound(k); // 返回一个迭代器，指向第一个关键字不小于k的元素
c.upper_bound(k);  // 返回一个迭代器，指向第一个关键字大于k的元素
c.equal_range(k);   //  返回一个迭代器pair，表示关键字等于k的元素的范围。如不存在，则pair的两个成员均为c.end()
</code></pre><p><code>lower_bound</code>和<code>upper_bound</code>只适用于有序容器<br>通过下标访问元素返回左值，既可以读，也可以写回</p>
<h5 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h5><ul>
<li>无序容器在存储上组织为一组桶，每个桶保存0个或多个元素</li>
<li><p>无序容器的性能依赖于哈希函数的质量和桶的大小</p>
<p>  c.bucket_count();  // 正在使用的桶数目<br>  c.max_bucket_count();  // 容器能容纳的最多的桶的数量<br>  c.bucket_size(n);  // 第n个桶中有多少个元素<br>  c.bucket(k);  //  关键字为k的元素在哪个桶中</p>
<p>  local_iterator       // 访问桶中元素的迭代器<br>  const_local_iterator   //  const版本<br>  c.begin(n), c.end(n)   //  桶n元素的首、尾迭代器<br>  c.cbegin(n), c.cend(n)</p>
<p>  c.load_factor();   //  每个桶的平均元素数量，float类型<br>  c.max_load_factor();  // 最大平均桶元素数量，每个桶的平均元素数量大于这个值就需要添加新的桶<br>  c.rehash(n);    //  重组存储，使得bucket_count &gt;= n且bucket_count&gt;size/max_load_factor<br>  c.reserve(n);   //  重组存储，使得c可以保存n个元素且不必rehash</p>
</li>
</ul>
<h6 id="无序容器对关键字的要求"><a href="#无序容器对关键字的要求" class="headerlink" title="无序容器对关键字的要求"></a>无序容器对关键字的要求</h6><ul>
<li>无序容器使用<code>==</code>运算符比较元素</li>
<li>使用<code>hash&lt;key_type&gt;</code>类型的对象生成每个元素的哈希值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_t <span class="title">hasher</span><span class="params">(<span class="keyword">const</span> Class1 &amp; cls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;string&gt;()(cls.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bool <span class="title">eqop</span><span class="params">(<span class="keyword">const</span> Class1 &amp; cls1, <span class="keyword">const</span> Class1 &amp; cls2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cls1.name == cls2.name;</span><br><span class="line">&#125;</span><br><span class="line">using clsset = unordered_set&lt;Class1, hasher, eqop&gt;;</span><br><span class="line"><span class="comment">// 42是桶大小</span></span><br><span class="line"><span class="function">clsset <span class="title">s</span><span class="params">(<span class="number">42</span>, hasher, eqop)</span></span>;</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/02/23/Cpp-Rule-Fragment/" data-id="cjzqae5xi003zq4ph1qz9ozd8" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2017/02/26/Bayesian-Classifier/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    Bayesian Classifier
                
            </div>
        </a>
    
    
        <a href="/2017/02/21/H-Index/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">H-Index</div>
        </a>
    
</nav>


    
</article>


    
    

</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/12/16/Hough-Transform/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2018/12/16/Hough-Transform/" class="title">Hough Transform</a></p>
                            <p class="item-date"><time datetime="2018-12-16T13:32:21.000Z" itemprop="datePublished">2018-12-16</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/12/16/GRU-and-LSTM/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2018/12/16/GRU-and-LSTM/" class="title">GRU and LSTM</a></p>
                            <p class="item-date"><time datetime="2018-12-16T13:27:29.000Z" itemprop="datePublished">2018-12-16</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2018/12/16/how-does-shazam-work/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2018/12/16/how-does-shazam-work/" class="title">how does shazam work</a></p>
                            <p class="item-date"><time datetime="2018-12-16T13:06:11.000Z" itemprop="datePublished">2018-12-16</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/08/27/Conditional-Random-Field/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2017/08/27/Conditional-Random-Field/" class="title">Conditional Random Field</a></p>
                            <p class="item-date"><time datetime="2017-08-27T06:19:20.000Z" itemprop="datePublished">2017-08-27</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2017/08/27/Maximum-Entropy-Model/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2017/08/27/Maximum-Entropy-Model/" class="title">Maximum Entropy Model</a></p>
                            <p class="item-date"><time datetime="2017-08-27T04:11:22.000Z" itemprop="datePublished">2017-08-27</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">40</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OJ/">OJ</a><span class="category-list-count">53</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Other/">Other</a><span class="category-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">35</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">8</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Backtracking/" style="font-size: 11.25px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 11.25px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 17.5px;">Binary Tree</a> <a href="/tags/Cpp/" style="font-size: 16.25px;">Cpp</a> <a href="/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/tags/DP/" style="font-size: 17.5px;">DP</a> <a href="/tags/Deep-Learning/" style="font-size: 10px;">Deep Learning</a> <a href="/tags/Divide-Conquer/" style="font-size: 10px;">Divide & Conquer</a> <a href="/tags/Game-Theory/" style="font-size: 10px;">Game Theory</a> <a href="/tags/Geometry/" style="font-size: 10px;">Geometry</a> <a href="/tags/Greedy/" style="font-size: 13.75px;">Greedy</a> <a href="/tags/IPython/" style="font-size: 10px;">IPython</a> <a href="/tags/Java/" style="font-size: 13.75px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 20px;">LeetCode</a> <a href="/tags/MIR/" style="font-size: 10px;">MIR</a> <a href="/tags/Machine-Learning/" style="font-size: 10px;">Machine Learning</a> <a href="/tags/Math/" style="font-size: 12.5px;">Math</a> <a href="/tags/Matlab/" style="font-size: 10px;">Matlab</a> <a href="/tags/NLP/" style="font-size: 12.5px;">NLP</a> <a href="/tags/POJ/" style="font-size: 11.25px;">POJ</a> <a href="/tags/Permutation/" style="font-size: 10px;">Permutation</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/Sliding-window/" style="font-size: 15px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.25px;">Sort</a> <a href="/tags/State-Machine/" style="font-size: 10px;">State Machine</a> <a href="/tags/String/" style="font-size: 15px;">String</a> <a href="/tags/Tree/" style="font-size: 10px;">Tree</a> <a href="/tags/bit/" style="font-size: 10px;">bit</a> <a href="/tags/deep-learning/" style="font-size: 10px;">deep learning</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/machine-learning/" style="font-size: 18.75px;">machine learning</a> <a href="/tags/music-information-retrieval/" style="font-size: 10px;">music information retrieval</a> <a href="/tags/numpy/" style="font-size: 11.25px;">numpy</a> <a href="/tags/other/" style="font-size: 10px;">other</a> <a href="/tags/pandas/" style="font-size: 11.25px;">pandas</a> <a href="/tags/prime/" style="font-size: 10px;">prime</a> <a href="/tags/python/" style="font-size: 17.5px;">python</a> <a href="/tags/random-algorithm/" style="font-size: 12.5px;">random algorithm</a> <a href="/tags/recommender-system/" style="font-size: 10px;">recommender system</a> <a href="/tags/time-series-data/" style="font-size: 10px;">time_series_data</a> <a href="/tags/visualization/" style="font-size: 10px;">visualization</a> <a href="/tags/数据分析/" style="font-size: 10px;">数据分析</a> <a href="/tags/文件/" style="font-size: 10px;">文件</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="https://xueshu.glgoo.org/">Google Scholar Mirror</a>
                    </li>
                
                    <li>
                        <a href="https://www.kaggle.com/">Kaggle</a>
                    </li>
                
                    <li>
                        <a href="http://mlr.cs.umass.edu/ml/datasets.html">UCI dataset</a>
                    </li>
                
                    <li>
                        <a href="https://leetcode.com/problemset/algorithms/">LeetCode</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fas fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2019 Atlantic8<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        </div>
    </div>
</footer>
        


    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>