<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    <title>曹文强</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="A note is preferable to the best memory">
<meta property="og:type" content="website">
<meta property="og:title" content="曹文强">
<meta property="og:url" content="atlantic8.github.io/page/5/index.html">
<meta property="og:site_name" content="曹文强">
<meta property="og:description" content="A note is preferable to the best memory">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="曹文强">
<meta name="twitter:description" content="A note is preferable to the best memory">
    

    

    
        <link rel="icon" href="/css/images/logo.png">
    

    <link rel="stylesheet" href="/libs/font-awesome5/css/fontawesome.min.css">
    <link rel="stylesheet" href="/libs/font-awesome5/css/fa-brands.min.css">
    <link rel="stylesheet" href="/libs/font-awesome5/css/fa-solid.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?ff86ad40748d96af89d192e9b0a3ae62";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    


</head>
</html>
<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">曹文强</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories/OJ">OJ</a>
                
                    <a class="main-nav-link" href="/categories/Algorithm">Algorithm</a>
                
                    <a class="main-nav-link" href="/categories/Math">Math</a>
                
                    <a class="main-nav-link" href="/categories/Dev">Dev</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/me.png" />
                            <i class="fas fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fas fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories/OJ">OJ</a></td>
                
                    <td><a class="main-nav-link" href="/categories/Algorithm">Algorithm</a></td>
                
                    <td><a class="main-nav-link" href="/categories/Math">Math</a></td>
                
                    <td><a class="main-nav-link" href="/categories/Dev">Dev</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/me.png" />
            <h2 id="name">曹文强</h2>
            <h3 id="title">算法工程师</h3>
            <span id="location"><i class="fas fa-map-marker-alt" style="padding-right: 5px"></i>北京, 中国</span>
            <a id="follow" target="_blank" href="https://github.com/Atlantic8">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                135
                <span>文章</span>
            </div>
            <div class="article-info-block">
                48
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/Atlantic8" target="_blank" title="github" class=tooltip>
                            
                                <i class="fab fa-github"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://www.linkedin.com/in/wenqiang-cao-704236b8/" target="_blank" title="linkedin" class=tooltip>
                            
                                <i class="fab fa-linkedin"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="mailto:atlantic8@outlook.com" target="_blank" title="envelope" class=tooltip>
                            
                                <i class="fas fa-envelope"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="http://weibo.com/2614093607" target="_blank" title="weibo" class=tooltip>
                            
                                <i class="fab fa-weibo"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="facebook" class=tooltip>
                            
                                <i class="fab fa-facebook"></i>
                            
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-Cpp-Rule-Fragment2" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/06/Cpp-Rule-Fragment2/">Cpp Rule Fragment2</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/06/Cpp-Rule-Fragment2/">
            <time datetime="2017-03-06T07:28:49.000Z" itemprop="datePublished">2017-03-06</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Dev/">Dev</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Cpp/">Cpp</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="左右的概念"><a href="#左右的概念" class="headerlink" title="左右的概念"></a>左右的概念</h5><h6 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h6><p>C++中左值与右值这两概念是从 c 中传承而来的，在 c 中，<strong>左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)</strong></p>
<p><strong>在 C语言中，通常来说有名字的变量就是左值</strong>(如 a, b)，<strong>而由运算操作(加减乘除，函数调用返回值等)所产生的中间结果(没有名字)就是右值</strong>，如 3 + 4， a + b 等。</p>
<p>在 C++ 中，每一个表达式都会产生一个左值，或者右值，相应的，该表达式也就被称作“左值表达式”， “右值表达式”。对于内置的基本数据类型来说，左值右值的概念和 c 没有太多不同，不同的地方在于自定义的类型，具体如下：</p>
<ul>
<li>对于内置的类型，右值是不可被修改的(non-modifiable)，也不可被 const, volatile 所修饰（volatile关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中，保证每次取的值都是内存中值）</li>
<li>对于自定义的类型(user-defined types)，右值却允许通过它的成员函数进行修改<br>2<h6 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h6></li>
<li>左值引用，<code>Type &amp; 左值引用名 = 左值表达式;</code></li>
<li>声明时必须初始化，初始化之后无法在改变；对别名的一切操作都等价于对原来变量的操作。</li>
<li>右值不能赋值给左值引用，加上const限定符即可</li>
<li>c++中临时变量默认const属性，所以只能传给const引用(延长生命周期)</li>
</ul>
<hr>
<ul>
<li>右值引用，<code>Type &amp;&amp; 右值引用名 = 右值表达式;</code></li>
<li>可以直接把左值或者右值转换成右值引用，但转换后原对象就不能使用了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; a1 = val+<span class="number">1</span>;  <span class="comment">// 错误，此时val+1（中间结果用const型的临时变量保存）等价于右值，右值不能赋值给左值引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a2 = val+<span class="number">1</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a3 = <span class="number">10</span>;  <span class="comment">//  正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a4 = std::move(val+<span class="number">1</span>); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h4 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h4><ul>
<li>智能指针负责自动释放所指向的对象，定义在<code>memory</code>头文件中</li>
<li>智能指针也是模板，创建智能指针时需要提供类型信息</li>
<li>智能指针的使用与普通指针类似</li>
<li>包括shared_ptr（允许多个指针指向同一个对象）、unique_ptr（独占所指向的对象）、weak_ptr（指向shared_ptr所指向的对象）</li>
</ul>
<p>注意事项</p>
<ul>
<li>不用相同的内置指针初始化多个智能指针</li>
<li>不delete get函数返回的值</li>
<li>不用get返回值初始化/reset另一个智能指针</li>
<li>如果智能指针管理的资源不是new分配的资源，需要传给他一个删除器</li>
</ul>
<h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; sp; <span class="comment">// 空指针</span></span><br><span class="line"><span class="keyword">if</span> (p)   <span class="comment">//  如果p指向一个对象则为true</span></span><br><span class="line">*p</span><br><span class="line">p-&gt;mem</span><br><span class="line">p.get()   <span class="comment">// 返回p中保存的指针</span></span><br><span class="line">swap(p, q)  <span class="comment">// 交换p和q中的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>不要将get函数得到的内置指针用于初始化其他智能指针</strong>，可能会导致两个智能指针指向同一个对象，且他们的计数器都为1<br>以上操作也适用于unique_ptr，下面的操作则是shared_ptr独占：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make_shared&lt;T&gt; (args)  <span class="comment">// 返回一个shared_ptr, 指向类型T的动态内存对象，使用args初始化</span></span><br><span class="line">shared_ptr&lt;T&gt;p(q)   <span class="comment">// p是q的拷贝；q中的计数器加一，要求q中的指针必须能转化位T*</span></span><br><span class="line">p = q    <span class="comment">// p,q都是shared_ptr，保存的指针必须能相互转换。p的引用计数器递减，q的递增。若p的引用计数器变为0，则将其管理的资源释放</span></span><br><span class="line">p.unique()   <span class="comment">//  若p.use_count()为1，返回true；否则返回false</span></span><br><span class="line">p.use_count  <span class="comment">// 返回与p共享对象的智能指针个数；一般用于调试</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto p1 = <span class="keyword">new</span> auto(obj); <span class="comment">// p指向一个与obj类类型相同的对象，该对象用obj初始化</span></span><br><span class="line"></span><br><span class="line">auto p2 = <span class="keyword">new</span> auto&#123;a,b,c&#125;; <span class="comment">// 错误，括号中只能有单个初始化器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存耗尽时new操作会抛出bad_alloc异常，下面的方法可以避免抛出异常</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> (notthrow) <span class="keyword">int</span>;   <span class="comment">// 内存耗尽时返回空指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li>delete空指针没有问题</li>
<li>delete之后应该重置指针</li>
</ul>
<h6 id="shared-ptr和new"><a href="#shared-ptr和new" class="headerlink" title="shared_ptr和new"></a>shared_ptr和new</h6><ul>
<li>可以使用new返回的指针初始化智能指针</li>
<li><strong>接受指针参数的智能指针构造函数为explicit</strong>（不准指针隐式转换），必须使用直接初始化形式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(new <span class="keyword">int</span>(<span class="number">42</span>)</span>)</span>;</span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>); <span class="comment">// 错误，可以使用reset</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(u)</span></span>;  <span class="comment">// p从unique_ptr接管对象所有权，将u置空</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(q, d)</span>  <span class="comment">// p接管内置指针q所指向的对象，q必须能转换为T*，p使用可调用对象d代替delete</span></span></span><br><span class="line"><span class="function">p.<span class="title">reset</span><span class="params">()</span>   <span class="comment">// 若p是唯一指向其对象的shared_ptr，reset释放该对象</span></span></span><br><span class="line"><span class="function">p.<span class="title">reset</span><span class="params">(q)</span>  <span class="comment">// 若传递了参数内置指针q，令p指向q，否则将p置空</span></span></span><br><span class="line"><span class="function">p.<span class="title">reset</span><span class="params">(q, d)</span></span>;  <span class="comment">// 有d则使用可调用对象代替delete</span></span><br></pre></td></tr></table></figure>
<h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h5><ul>
<li>一个对象只能有一个unique_ptr，不支持拷贝（除非是返回即将要销毁或局部对象的拷贝）、赋值</li>
<li>必须采用直接初始化形式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;T, D&gt; u <span class="comment">// D为可调用对象，用来释放内存</span></span><br><span class="line"><span class="function">unique_ptr&lt;T, D&gt; <span class="title">u</span><span class="params">(d)</span>   <span class="comment">// 用d代替D</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">u </span>= nullptr  <span class="comment">// 释放u指向的对象，将u置空</span></span><br><span class="line">u.release()  <span class="comment">// u交出控制权，返回内置指针，将u置空</span></span><br><span class="line"></span><br><span class="line">u.reset()     <span class="comment">// 释放u指向的对象</span></span><br><span class="line">u.reset(q)   <span class="comment">// 提供内置指针q，则令u指向这个对象；否则将u置空</span></span><br><span class="line">u.reset(nullptr)</span><br></pre></td></tr></table></figure>
<h6 id="unique-ptr和动态数组"><a href="#unique-ptr和动态数组" class="headerlink" title="unique_ptr和动态数组"></a>unique_ptr和动态数组</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;T[]&gt; u;  <span class="comment">// u指向一个动态分配的数组</span></span><br><span class="line">unique_ptr&lt;T[]&gt; u(p);  <span class="comment">// u指向内置指针p指向的动态动态分配的数组，p类型必须能转换为T*</span></span><br><span class="line">u[i];   <span class="comment">// 访问数组</span></span><br></pre></td></tr></table></figure>
<p>shared_ptr没有提供管理动态数组的功能，需要使用需要自己定义删除器。</p>
<h5 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h5><ul>
<li>不能控制对象生存周期，指向由shared_ptr管理的对象，切不改变shared_ptr引用计数</li>
<li>需要用shared_ptr初始化</li>
<li>指向对象可能被释放掉，所以不能直接访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">weak_ptr&lt;T&gt; <span class="title">w</span><span class="params">(sp)</span></span>;  <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">w = p; <span class="comment">// p可以是weak_ptr或shared_ptr，赋值后两者共享对象</span></span><br><span class="line">w.reset()  <span class="comment">// w置空</span></span><br><span class="line">w.use_count()  <span class="comment">// 与w共享对象的shared_ptr的数量</span></span><br><span class="line">w.expired()     <span class="comment">// w.use_count() == 0返回true</span></span><br><span class="line">w.lock()   <span class="comment">// w.expired() 为true返回一个空shared_ptr，否则返回一个与w共享对象的shared_ptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line"><span class="keyword">if</span> (shared_ptr&lt;<span class="keyword">int</span>&gt; np = w.lock()) &#123;  <span class="comment">// np不为空成立</span></span><br><span class="line">    <span class="comment">// 使用np访问对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h5><ul>
<li>定义在memory头文件中，是一个模板</li>
<li>allocator分配的内存都是未构造的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;T&gt; a;</span><br><span class="line">a.allocate(n);  <span class="comment">// 分配一段原始的、未构造的内存，保存n个类型为T的对象</span></span><br><span class="line">a.deallocate(p, n);  <span class="comment">// 释放从T*类型的指针p开始的内存，这块内存保存了n个T类型对象；p必须是由allocate函数返回的指针，n必须是p创建时要求的大小。调用之前，必须对这n个T对象调用destory</span></span><br><span class="line"></span><br><span class="line">a.construct(p, args); <span class="comment">// p必须是类型为T*的指针，指向一块原始内存，args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</span></span><br><span class="line">a.destory(p)  <span class="comment">// 对p指向的对象指向析构函数</span></span><br></pre></td></tr></table></figure>
<h6 id="构造、填充未初始化内存的算法"><a href="#构造、填充未初始化内存的算法" class="headerlink" title="构造、填充未初始化内存的算法"></a>构造、填充未初始化内存的算法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uninitialized_copy(b, e, b2);  <span class="comment">// 拷贝迭代器b、e指定范围元素到b2指定的未构造的原始内存中，b2指向的内存必须足够大</span></span><br><span class="line">uninitialized_copy_n(b, n, b2); <span class="comment">// 从b开始，n个元素</span></span><br><span class="line"></span><br><span class="line">uninitialized_fill(b, e, t);  <span class="comment">// 拷贝值均为t</span></span><br><span class="line">uninitialized_fill_n(b, n, t);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这几个算法都返回下一个未初始化的内存位置</span></span><br></pre></td></tr></table></figure>
<h4 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h4><h5 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h5><h6 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h6><ul>
<li>成员类型决定拷贝方式，内置类型直接拷贝，类类型需要拷贝构造函数来拷贝</li>
<li>不应该是explicit的</li>
<li>参数是自身类类型的引用</li>
<li>编译器会为我们定义一个（如果我们没有定义）</li>
</ul>
<p><strong>拷贝初始化发生的时间不仅在用=定义变量时，也会发生在</strong>：</p>
<ol>
<li>将对象作为实参传递给非引用类型的形参</li>
<li>从返回非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ol>
<h6 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h6><ul>
<li>编译器会为我们定义一个（如果我们没有定义）</li>
</ul>
<h6 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h6><ul>
<li>编译器会为我们定义一个（如果我们没有定义）</li>
<li>一般为空，成员是在析构函数体之后隐含的析构阶段被销毁的</li>
<li>某些类中，析构函数也被用来阻止该类型的对象被销毁</li>
<li>需要析构函数的类也需要拷贝、赋值操作</li>
</ul>
<h6 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用<code>=default</code></h6><ul>
<li>将拷贝控制成员定义为<code>=default</code>可以显式地要求编译器生成合成的版本</li>
<li>类内使用`=default’修饰的成员将隐式地声明为内联的</li>
<li>如果不希望内联，则只对类外的定义使用<code>=default</code>。</li>
</ul>
<h6 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h6><ul>
<li>在函数第一次声明后面写上<code>=delete</code>表示<strong>删除的函数</strong>，不希望定义这些成员</li>
<li>拷贝构造函数、拷贝赋值运算符定义为删除的函数可以阻止拷贝</li>
<li>析构函数不能是删除的成员，因为存在对象无法销毁的问题</li>
<li>但如果你真的这么干了：如果一个类有数据成员不能默认构造、拷贝、复制、销毁，则对应的成员函数将被定义为删除的</li>
</ul>
<h5 id="动态内存管理类"><a href="#动态内存管理类" class="headerlink" title="动态内存管理类"></a>动态内存管理类</h5><ul>
<li>在运行时分配可变大小内存的空间</li>
<li>以vector为例，添加元素的成员函数检查是否有更多空间，没有则申请新的空间，<strong>将已有元素移到新空间</strong>，释放旧空间，添加新元素</li>
</ul>
<h5 id="移动构造函数和std-move"><a href="#移动构造函数和std-move" class="headerlink" title="移动构造函数和std::move"></a>移动构造函数和std::move</h5><ul>
<li>移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象</li>
<li>调用标准库函数move（utility头文件）表示希望使用移动构造函数</li>
</ul>
<h6 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h6><ul>
<li><strong>右值引用是指必须绑定到右值的引用</strong>，通过<code>&amp;&amp;</code>获得</li>
<li>右值引用只能绑定到将要销毁的对象，因此可以将一个将要销毁的资源移动到另一个对象中</li>
<li>左值引用不能绑定到要求转换的表达式、字面常量、返回右值的表达式（变量是左值）</li>
<li>右值引用有相反的要求；一般右值生命周期短（字面常量、临时对象等）</li>
<li>通过move函数显式地将左值转换为对应的右值引用类型，使用move不用using声明，直接用<code>std::move</code></li>
<li>右值引用做形参时不能为const，因为需要窃取他的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;r1 = <span class="number">42</span>; <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2 = r1;  <span class="comment">// wrong, 变量表达式r1是左值</span></span><br><span class="line"><span class="comment">// 调用move后，意味着除了对r1赋值、销毁外，将不再使用它</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r3 = std::move(r1); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h5 id="移动构造函数、移动赋值运算符"><a href="#移动构造函数、移动赋值运算符" class="headerlink" title="移动构造函数、移动赋值运算符"></a>移动构造函数、移动赋值运算符</h5><ul>
<li>移动构造函数的<strong>第一个参数是该类型的一个右值引用</strong></li>
<li>必须确保移动后，源对象处于销毁无害的状态，也就是说<strong>源对象必须不再指向被移动的资源</strong>（指针置为nullptr，因为源对象可以被销毁，如果它的指针还指向被移动的资源，执行析构函数时就会将被移动的资源释放）</li>
<li>移动操作<strong>通常</strong>不抛出异常。编写不抛出异常的移动操作，应该使用<code>noexcept</code>通知标准库，免去其为了处理可能存在的异常做的额外工作（可能出现异常的还是不要写比较好）</li>
<li><code>noexcept</code>出现在参数列表之后；如果是构造函数，其在初始化列表的<code>:</code>之前</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A::A(A &amp;&amp;a) noexcept : x(a.x), y(x.y) &#123;</span><br><span class="line">    a.x = a.y = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A &amp;A::operator=(A &amp;&amp; a) noexcept &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 自赋值</span></span><br><span class="line">    free();   <span class="comment">// 释放现在对象的资源</span></span><br><span class="line">    x = a.x;</span><br><span class="line">    y = a.y;</span><br><span class="line">    a.x = a.y = nullptr;  <span class="comment">// 重置源对象的指针</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员；也可以移动有对应移动操作的类成员</strong></li>
<li>移到构造函数永远不会隐式地定义为删除的函数（delete）</li>
<li>如果显式要求编译器生成<code>=default</code>的移动操作，但编译器不能移动所有成员，则编译器将移动操作定义为删除的</li>
<li>类本身的析构函数为删除的、不可访问的，则其移动构造函数为删除的</li>
<li>如果类成员是const的或者是引用，则类的移动赋值运算符定义为删除的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct X &#123;</span><br><span class="line">    <span class="keyword">int</span> i;               <span class="comment">// 内置成员可以移动</span></span><br><span class="line">    std::string s;   <span class="comment">//  string有自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line">struct Y &#123;</span><br><span class="line">    X mem;     <span class="comment">// X有合成移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x1, x = std::move(x1);   <span class="comment">// 合成移动构造函数</span></span><br><span class="line">Y y1, y = std::move(y1);   <span class="comment">// 使用合成移动构造函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>既有拷贝构造函数也有移动构造函数时，遵循<strong>移动右值，拷贝左值</strong>的方法</li>
<li>没有移动构造函数时，右值也被拷贝</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A  a1, a2;</span><br><span class="line">a1 = a2;  <span class="comment">// a2是左值，使用拷贝</span></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">(istream&amp; is)</span></span>;  <span class="comment">// 函数getA返回一个右值</span></span><br><span class="line">a2 = getA();      <span class="comment">// 返回右值，使用移动赋值</span></span><br></pre></td></tr></table></figure>
<h6 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h6><ul>
<li>一般的迭代器解引用操作返回一个指向元素的左值，<strong>移动迭代器的解引用操作生成一个右值引用</strong></li>
<li>调用<code>make_move_iterator</code>将一个普通迭代器转化为一个移动迭代器，原迭代器的所有操作在移动迭代器中都正常工作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto first = alloc.allocate(new_capacity);</span><br><span class="line"><span class="comment">// 使用移动构造函数来构造每个元素</span></span><br><span class="line">auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);</span><br></pre></td></tr></table></figure>
<h6 id="右值、左值引用成员函数、重载和引用函数"><a href="#右值、左值引用成员函数、重载和引用函数" class="headerlink" title="右值、左值引用成员函数、重载和引用函数"></a>右值、左值引用成员函数、重载和引用函数</h6><ul>
<li>类成员函数的参数列表后可以放置<code>&amp;</code>或<code>&amp;&amp;</code>，称为引用限定符</li>
<li>引用限定符指出<code>this</code>可以指向一个左值或右值</li>
<li>引用限定符只能用在非static成员函数中（类似const限定符），且必须在声明、定义中都出现</li>
<li><strong>引用限定符就是限制调用成员函数的对象有引用限定</strong></li>
<li><code>&amp;</code>限定的函数，只能将这个函数用于左值；<code>&amp;&amp;</code>则只能用于右值</li>
<li>同时有const限定符的函数，引用限定符应该在const限定符之后<code>const &amp;</code></li>
<li>引用限定符可以区分重载版本（const也可以），表示其对象是右值还是左值</li>
<li>定义两个及以上具有相同名字和参数列表的函数，就必须对所有函数加上引用限定符，或者所有都不加。（有的加，有的不加不行）</li>
</ul>
<p><strong>右值执行排序，可以直接进行，因为右值没有其他用户，可以改变；但是，对const右值、左值进行排序时，不能改变对象，所以先拷贝再排序。</strong></p>
<h4 id="重载运算与类型转换"><a href="#重载运算与类型转换" class="headerlink" title="重载运算与类型转换"></a>重载运算与类型转换</h4><ul>
<li>运算符作用域内置类型的运算对象时，运算符的含义无法改变（不能重载）</li>
<li>只能重载已有的运算符</li>
<li>不能被重载的运算符包括<code>::        .*        .        ?:</code></li>
<li>下标运算符<code>[]</code>返回的是元素的引用</li>
</ul>
<h5 id="输入输出运算符"><a href="#输入输出运算符" class="headerlink" title="输入输出运算符"></a>输入输出运算符</h5><ul>
<li>输入、输出运算符必须是非成员函数</li>
<li>一般地，重载输出运算符<code>&lt;&lt;</code>函数的第一个参数是一个非常量<code>ostream</code>对象引用（非常量是因为向流写入内容会改变其状态，引用是因为ostream不能拷贝），第二个参数一般是要打印对象的常量引用；函数返回ostream的形参</li>
<li>重载输入运算符函数的第二个参数<strong>非常量对象的引用</strong>，返回istream的形参</li>
<li>重载输入运算符要处理可能失败的情况，输出则不需要</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; operator&gt;&gt;(istream&amp; is, A&amp; a) &#123;</span><br><span class="line">    <span class="comment">// .... 包括处理失败情况</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h5><ul>
<li>区分前置、后置的办法是：<strong>后置版本有一个不被使用的int类型形参</strong></li>
<li>后置版本需要先记录对象的状态，操作完成后返回之前记录的状态</li>
<li><strong>后置运算符返回对象的原值</strong>，不是引用</li>
<li>显式调用后置运算符需要多加一个参数: <code>a.operator++(0);</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&amp; operator++();    <span class="comment">// 前置</span></span><br><span class="line">A operator++(<span class="keyword">int</span>);  <span class="comment">// 后置，有形参，返回原值</span></span><br><span class="line"></span><br><span class="line">A A::operator++() &#123;</span><br><span class="line">    A ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回之前的记录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h5><ul>
<li>包括解引用<code>*</code>和箭头运算符<code>-&gt;</code>两种</li>
<li><code>-&gt;</code>必须是类成员，解引用通常是类成员</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string&amp; operator*() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// 检查curr是否在有效范围内，如果是，返回curr所知元素的引用</span></span><br><span class="line">    auto p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">    <span class="keyword">return</span> (*p)[curr];          <span class="comment">// *p是对象所指的vector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string * operator-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 将工作委托给解引用运算符</span></span><br><span class="line">    <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;operator*();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h5><ul>
<li>重载函数调用运算符就可以向调用函数一样使用类对象</li>
<li>由于可以像使用函数对象那样使用，重载调用运算符可以替代lambda表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">absInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;   <span class="comment">// 注意参数放在后面的括号里</span></span><br><span class="line">        <span class="keyword">return</span> val&lt;<span class="number">0</span>? -val:val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">absInt ai;</span><br><span class="line">ai(-<span class="number">10</span>);  <span class="comment">// 返回10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stable_sort(words.begin(), words.end(), [](<span class="keyword">const</span> string&amp; s1, <span class="keyword">const</span> string&amp; s2)&#123;<span class="keyword">return</span> s1.size &lt; s2.size()&#125;;);</span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">short_string</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string&amp; s1, <span class="keyword">const</span> string&amp; s2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.size &lt; s2.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// short_string()构造一个对象，由于重载了调用运算符，就可以看作"可调用对象"使用</span></span><br><span class="line">stable_sort(words.begin(), words.end(), short_string());</span><br></pre></td></tr></table></figure>
<h6 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h6><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符（所以其对象也可以被“调用”）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>算术</th>
<th>关系</th>
<th>逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td>plus<t></t></td>
<td>equal_to<t></t></td>
<td>logical_and<t></t></td>
</tr>
<tr>
<td>minus<t></t></td>
<td>not_equal_to<t></t></td>
<td>logical_or<t></t></td>
</tr>
<tr>
<td>multiplies<t></t></td>
<td>greater<t></t></td>
<td>logical_not<t></t></td>
</tr>
<tr>
<td>divides<t></t></td>
<td>greater_equal<t></t></td>
<td></td>
</tr>
<tr>
<td>modules<t></t></td>
<td>less<t></t></td>
<td></td>
</tr>
<tr>
<td>megate<t></t></td>
<td>less_equal<t></t></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="keyword">int</span>&gt; intadd;</span><br><span class="line">intadd(<span class="number">10</span>, <span class="number">15</span>);  <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; intnegate;</span><br><span class="line">intnegate(<span class="number">10</span>);  <span class="comment">// -10</span></span><br><span class="line">intnegate(intadd(<span class="number">10</span>,<span class="number">15</span>));  <span class="comment">// -25</span></span><br><span class="line"></span><br><span class="line">sort(vec.begin(), vec.end(), greater&lt;string&gt;());</span><br><span class="line"><span class="comment">// 如果vector里面是string*也照样可以</span></span><br><span class="line">sort(vec.begin(), vec.end(), greater&lt;string*&gt;());</span><br></pre></td></tr></table></figure>
<h6 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h6><p>C++中的可调用对象包括：<strong>函数、函数指针、lambda表达式、bind创建的对象、重载了调用运算符的类</strong></p>
<ul>
<li>function类型定义在<code>functional</code>头文件中，是一个模板</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function&lt;T&gt; f;  <span class="comment">// f是用来存储可调用对象的空的function，T限定函数类型（T就是`返回值 (各个参数)`）</span></span><br><span class="line"><span class="function">function&lt;T&gt; <span class="title">f</span><span class="params">(nullptr)</span></span>;  <span class="comment">//  显式构造一个空的function</span></span><br><span class="line"><span class="function">function&lt;T&gt; <span class="title">f</span><span class="params">(obj)</span></span>;  <span class="comment">// f中存储可调用对象obj的副本</span></span><br><span class="line">f                               <span class="comment">// f中有可调用对象为真，否则为假</span></span><br><span class="line">f(args);                    <span class="comment">// 调用f中的对象，args是参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义为function&lt;T&gt;的成员类型</span></span><br><span class="line">result_type       <span class="comment">// 可调用对象的返回类型</span></span><br><span class="line">argument_type <span class="comment">// T一个实参时，实参的类型</span></span><br><span class="line">first_argument_type, second_argument_type</span><br></pre></td></tr></table></figure>
<p>使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;    <span class="comment">// 函数指针</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = divide(); <span class="comment">// 重载了调用运算符的类的对象</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;<span class="keyword">return</span> i+j;&#125;;  <span class="comment">// lambda表达式</span></span><br><span class="line"></span><br><span class="line">f1(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">f2(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">f3(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h5><ul>
<li>可以通过定义类类型转换运算符达到类类型转换的效果</li>
<li>转换构造函数和类型转换运算符共同定义了类类型转换</li>
</ul>
<h6 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h6><ul>
<li><strong>类型转换运算符是类成员函数</strong></li>
<li>可以面向除了<code>void*</code>之外的任意类型进行定义，只要该类型能作为函数的返回类型（数组、函数类型就不行）</li>
<li>一般形式<code>operator type() const</code></li>
<li>类型转换运算符是<strong>隐式执行</strong>的，没有形参，不能传递实参，不能指定返回类型</li>
<li>可能产生意外结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smallInt</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    smallInt(<span class="keyword">int</span> i=<span class="number">0</span>) : val(i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;<span class="number">255</span>) <span class="keyword">throw</span> std::out_of_range(<span class="string">"Invalid value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">operator <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> operator <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// wrong，不能有返回类型</span></span><br><span class="line">    <span class="function">operator <span class="title">int</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// wrong，不能有形式参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::size_t val;</span><br><span class="line">&#125;</span><br><span class="line">smallInt si;</span><br><span class="line">si = <span class="number">4</span>;  <span class="comment">// 先将4隐式转换为smallInt，再调用赋值运算符</span></span><br><span class="line">si+<span class="number">3</span>;    <span class="comment">// 先将si隐式转换为int，再执行整数加法</span></span><br><span class="line"></span><br><span class="line">smallInt s = <span class="number">3.14</span>;  <span class="comment">// 内置类型转换double-&gt;int，再调用smallInt(int)构造</span></span><br><span class="line">s+<span class="number">3.14</span>                <span class="comment">// smallInt先转成int，内置类型再将int转换成double</span></span><br></pre></td></tr></table></figure>
<p>由于隐式转换可能会带来意想不到的结果，所以有时候需要使用<strong>显式的类型转换运算符</strong>。定义显式类型转换运算符只需要加上<code>explicit</code>即可，但转换时就行必须使用显式的强制转换方式。<br><strong>有一个例外：当表达式被用作条件判断（<code>if, while, do, for, &amp;&amp;, ||, !, ?:</code>），编译器会将显式的类型转换自动用于它，也就是会隐式执行</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">explicit operator <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;  <span class="comment">// 改变的类型转换运算符</span></span><br><span class="line"></span><br><span class="line">smallInt si = <span class="number">3</span>; <span class="comment">// ok</span></span><br><span class="line">si+<span class="number">3</span>                 <span class="comment">// wrong，此处需要隐式转换，但转换函数是显式的</span></span><br><span class="line">static_cast&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>  <span class="comment">// 显示请求转换</span></span><br></pre></td></tr></table></figure></p>
<p>IO类型可以向void*转换，C++11下支持将IO类型向bool显式类型转换，IO类型向bool的转换一般定义成显式（explicit），因为通常用在条件判断部分，所以也可以隐式执行。</p>
<h6 id="二义性问题"><a href="#二义性问题" class="headerlink" title="二义性问题"></a>二义性问题</h6><p>二义性类型转换的途径</p>
<ul>
<li>两个类提供了相同的类型转换（分别通过构造函数和类型转换运算符）</li>
<li>定义了多个转换规则，这些转换<strong>涉及的类型本身可以通过其他类型转换联系在一起</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A(<span class="keyword">int</span> = <span class="number">0</span>); <span class="comment">// 最好不要创建两个转换源都是算术类型的类型转换</span></span><br><span class="line">    A(<span class="keyword">double</span>);</span><br><span class="line">    <span class="function">operator <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// 最好不要创建两个转换对象都是算术类型的类型转换</span></span><br><span class="line">    <span class="function">operator <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// other member</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">f2(a);  <span class="comment">// 二义性错误，两个类型转换函数都可以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>;  <span class="comment">// 二义性，编译器无法区分long转int和double的好坏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">42</span>;</span><br><span class="line"><span class="function">A <span class="title">a3</span><span class="params">(s)</span></span>;  <span class="comment">//ok, 使用A::A(int)</span></span><br></pre></td></tr></table></figure>
<p>但是short转int确实比short转double好</p>
<p><strong>重载函数于转换构造函数</strong></p>
<ul>
<li>如果两个或多个类型的转换都提供了同一种可行的匹配，则这些类型转换一样好</li>
<li><strong>即使其中一个能精确匹配，另一个需要额外的标准类型转换，编译器也会将其表示为二义性错误</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct C &#123;</span><br><span class="line">    C(<span class="keyword">int</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">struct D &#123;</span><br><span class="line">    D(ing);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> D&amp;)</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//二义性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------分割线----------------------------------</span></span><br><span class="line"></span><br><span class="line">struct E &#123;</span><br><span class="line">    E(<span class="keyword">double</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> E&amp;)</span></span>;</span><br><span class="line">f(<span class="number">10</span>);  <span class="comment">// 依旧二义性错误，即使其中一个能精确匹配，另一个需要额外的标准类型转换，编译器也会将其表示为二义性错误</span></span><br></pre></td></tr></table></figure>
<p>函数匹配与重载运算符</p>
<ul>
<li>表达式中运算符的候选函数集包括成员函数和非成员函数</li>
<li><strong>如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">friend A operator+(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> A&amp; b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">    <span class="function">operator <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    size_t val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A a1, a2;</span><br><span class="line">A a3 = s1 + s2;  <span class="comment">// 使用重载的operator+</span></span><br><span class="line"><span class="keyword">int</span> i = s3 + <span class="number">1</span>;    <span class="comment">//  二义性错误</span></span><br></pre></td></tr></table></figure>
<h4 id="面向对象程序设计-OOP"><a href="#面向对象程序设计-OOP" class="headerlink" title="面向对象程序设计 OOP"></a>面向对象程序设计 OOP</h4><ul>
<li>OOP的核心思想是<strong>数据抽象、继承和动态绑定</strong></li>
</ul>
<h5 id="基类与派生类（父类与子类）"><a href="#基类与派生类（父类与子类）" class="headerlink" title="基类与派生类（父类与子类）"></a>基类与派生类（父类与子类）</h5><ul>
<li>子类经常覆盖父类中的虚函数，如果不覆盖，子类将直接继承父类的版本</li>
<li>能把子类对象当成父类对象来用，也能把父类的指针或引用绑定到子类对象的父类部分上</li>
<li>子类构造函数先初始化父类部分，然后按照声明顺序依次初始化子类成员</li>
<li><strong>派生类可以访问基类的公有和受保护成员</strong></li>
</ul>
<hr>
<ul>
<li>基类中的静态成员在整个继承体系中都只存在该成员的唯一定义，如果是private的，派生类就不能访问</li>
<li><strong>声明派生类时不能加上派生列表</strong></li>
<li>派生类一定要有定义，类不能派生自己</li>
<li>使用final关键字可以禁止类被继承</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span> </span>&#123;&#125;;</span><br><span class="line">class A final : public father &#123;&#125;;  // ok, 但A不能被继承</span><br><span class="line">class B : public A&#123;&#125;;  // 错误，A是final的</span><br></pre></td></tr></table></figure>
<ul>
<li>派生类向基类的自动类型转换只对指针、引用类型有效</li>
<li>用派生类对象为基类对象初始化或者赋值时，其派生类独有的部分会被忽略</li>
</ul>
<h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><ul>
<li>运行时动态绑定</li>
<li>所有虚函数都必须有定义</li>
<li>派生类中的虚函数可以不加<code>virtual</code>关键字，因为一旦某个函数被声明为虚函数，他在所有派生类中都是虚函数</li>
<li>覆盖基类虚函数的派生类函数必须在形参上与派生类完全一致</li>
<li><code>override</code>关键字用来说明派生类中的虚函数</li>
<li><code>final</code>关键字阻止函数派生类覆盖此函数</li>
<li>如果虚函数使用默认实参，实参由本次调用的静态类型决定（使用基类的指针就用基类的虚函数默认实参），所以最好定义派生类、基类虚函数的默认实参一致</li>
<li>回避虚函数机制，可使用作用域运算符机制</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function">virtual <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">class B : A &#123;</span><br><span class="line"><span class="function">virtual <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">final</span></span>;  <span class="comment">// 不允许后续的其他类覆盖f1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A * a = <span class="keyword">new</span> B();</span><br><span class="line">a-&gt;f1();  <span class="comment">// 调用B类中的虚函数f1</span></span><br><span class="line">a-&gt;A::f1();  <span class="comment">// 无论a类型是什么，都是用A中的虚函数f1</span></span><br></pre></td></tr></table></figure>
<h5 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h5><ul>
<li>抽象基类负责定义接口，不能直接创建其对象</li>
</ul>
<h6 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h6><ul>
<li>在函数声明加上<code>=0</code>就可以将函数声明为纯虚函数</li>
<li>纯虚函数无需定义，非要定义的话必须在类的外部</li>
</ul>
<h5 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h5><h6 id="受保护的成员-protected"><a href="#受保护的成员-protected" class="headerlink" title="受保护的成员 protected"></a>受保护的成员 protected</h6><ul>
<li>类的用户不能访问受保护的成员，私有的更不行</li>
<li>派生类的成员、友元可访问继承来的protected、public成员，private不行</li>
<li><strong>派生类的成员、友元只能通过派生类对象访问基类的受保护成员。派生类无法访问基类对象中的受保护成员</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class base &#123;</span><br><span class="line">protected:</span><br><span class="line">    int mem;</span><br><span class="line">&#125;;</span><br><span class="line">class sneak : base &#123;</span><br><span class="line">    friend void get(sneak&amp;);  // 可以通过自身对象访问基类的受保护部分</span><br><span class="line">    friend void get(base&amp;);   // 不能访问基类对象中的受保护成员</span><br><span class="line">    int j; // private</span><br><span class="line">&#125;;</span><br><span class="line">void get(sneaky&amp; s)&#123;s.j = s.mem = 0;&#125;</span><br><span class="line">void get(base &amp;b) &#123;b.mem = 0;&#125;  // 错误，不能访问</span><br></pre></td></tr></table></figure>
<ul>
<li>派生类对其继承而来的成员的访问权限收到两个因素影响：<ul>
<li>基类中该成员的访问说明符</li>
<li>派生类的派生列表中的访问说明符</li>
</ul>
</li>
<li><strong>派生访问说明符对于派生类的成员及其友元能否访问直接基类的成员没什么影响</strong>，<strong>其对基类成员的访问权限只与基类中的访问说明符有关</strong></li>
<li><strong>派生访问说明符的目的是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限</strong><ul>
<li>如果继承是公有的，成员遵循原有的访问说明符</li>
<li>如果继承是私有的，则所有对象都是私有的</li>
<li>如果继承是protected的，原本public的称为protected的</li>
</ul>
</li>
</ul>
<hr>
<p><strong>派生类向基类转换的可访问性</strong>（假定D继承自B）</p>
<ul>
<li>只有继承方式是public，用户代码才能使用派生类向基类的转换</li>
<li>无论以什么方式继承，D的成员和友元都能使用派生类向基类的转换</li>
<li>如果D以public或protected方式继承B，则D的派生类的成员和友元可以使用D向B的转换</li>
<li>要改变个别成员的可访问性，可使用<code>using</code>关键字</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mem, n;</span><br><span class="line">&#125;;</span><br><span class="line">class derived : private base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    using base::mem;</span><br><span class="line">protect:</span><br><span class="line">    using base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>友元与继承</p>
<ul>
<li>友元关系不能继承</li>
</ul>
<h5 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h5><ul>
<li>先名字查找再类型检查（p-&gt;mem(), obj.mem()）<ol>
<li>确定p的静态类型，因为调用的是成员，该类型必然是类类型</li>
<li>在p的静态类型对应的类中查找mem，找不到则直接基类中查找直到继承链最顶端。还是找不到就报错</li>
<li>一旦找到mem，就进行常规的类型检查以确认本次调用是否合法</li>
<li>如果调用合法，则编译器将根据调用的是否是虚函数产生不同的代码</li>
</ol>
</li>
<li>内层作用域的函数不会重载声明在外层作用域的函数</li>
<li>名字查找过程中，<strong>派生类会隐藏基类的同名成员（即使形参列表不一样）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">class derived : private base&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// 隐藏了基类的f()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">base b; derived d;</span><br><span class="line">d.f(<span class="number">10</span>);  <span class="comment">// ok</span></span><br><span class="line">d.f();      <span class="comment">// wrong，参数列表为空的f函数被隐藏了</span></span><br></pre></td></tr></table></figure>
<h5 id="拷贝函数与拷贝控制"><a href="#拷贝函数与拷贝控制" class="headerlink" title="拷贝函数与拷贝控制"></a>拷贝函数与拷贝控制</h5><h6 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h6><ul>
<li>派生类会继承基类析构函数的虚属性</li>
<li>基类虚析构函数能保证delete基类指针时使用正确的析构函数版本</li>
<li>定义了虚析构函数的类，编译器就不会为其合成移动操作</li>
</ul>
<h6 id="派生类中删除的拷贝控制与基类的关系"><a href="#派生类中删除的拷贝控制与基类的关系" class="headerlink" title="派生类中删除的拷贝控制与基类的关系"></a>派生类中删除的拷贝控制与基类的关系</h6><ul>
<li>基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或不可访问的，则派生类中对应的成员将是删除的</li>
<li>基类中的析构函数是不可访问或删除的，那么派生类中的合成的默认和拷贝构造函数都是删除的</li>
<li>基类中对应操作是删除的，派生类中的也会是删除的（比如说移动构造函数）</li>
</ul>
<h6 id="移动操作与继承"><a href="#移动操作与继承" class="headerlink" title="移动操作与继承"></a>移动操作与继承</h6><ul>
<li>带有虚析构函数的类，编译器不会为其合成移动操作，所以其子类也没有</li>
<li>确实需要移动操作时，可以显式地定义（可以使用合成版本）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() = <span class="keyword">default</span>;   <span class="comment">// 默认构造</span></span><br><span class="line">    A(<span class="keyword">const</span> A&amp;) = <span class="keyword">default</span>;   <span class="comment">// 拷贝构造</span></span><br><span class="line">    A(A&amp;&amp;) = <span class="keyword">default</span>;        <span class="comment">// 移动构造</span></span><br><span class="line">    A&amp; operator=(<span class="keyword">const</span> A&amp;) = <span class="keyword">default</span>;   <span class="comment">// 拷贝赋值</span></span><br><span class="line">    A&amp; operator=(A&amp;&amp;) = <span class="keyword">default</span>;        <span class="comment">// 移动赋值</span></span><br><span class="line">    virtual ~A();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="派生类的拷贝控制"><a href="#派生类的拷贝控制" class="headerlink" title="派生类的拷贝控制"></a>派生类的拷贝控制</h6><ul>
<li>派生类在拷贝、移动的同时要拷贝、移动基类部分(显式地)</li>
<li>派生类赋值运算符的处理方法也类似</li>
<li>派生类的析构函数只负责销毁派生类自己分配的资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> </span>&#123;&#125;;</span><br><span class="line">class D : private base&#123;</span><br><span class="line">    D(<span class="keyword">const</span> D&amp; d) : base(d), <span class="comment">/*D的成员初始值*/</span> &#123;...&#125; <span class="comment">// d作为参数将被绑定到类型为base&amp;的实参上</span></span><br><span class="line">    D(D&amp;&amp; d) : base(std::move(d)), <span class="comment">/*D的成员初始值*/</span> &#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">D&amp; D::operator= (<span class="keyword">const</span> D&amp; d) &#123;</span><br><span class="line">    base::operator=(d);  <span class="comment">// 为基类部分赋值</span></span><br><span class="line">    <span class="comment">// 酌情处理自赋值、释放已有资源</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="在构造函数和虚构函数中调用虚函数"><a href="#在构造函数和虚构函数中调用虚函数" class="headerlink" title="在构造函数和虚构函数中调用虚函数"></a>在构造函数和虚构函数中调用虚函数</h6><ul>
<li><strong>如果构造函数或析构函数调用了某个虚函数，则程序会执行与调用构造函数或析构函数所属类型相对应的虚函数版本</strong></li>
<li>这个例子：创建派生类对象时，先调用基类的构造函数，此时对象的派生类部分是未被初始化的，调用派生类的虚函数存在风险，所以应该调用基类的虚函数。</li>
</ul>
<h6 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h6><ul>
<li>一个类可以继承其直接基类的构造函数</li>
<li>类不能继承默认、移动、拷贝构造函数</li>
<li>继承方式是使用<code>using base::base;</code>就可以继承base的构造函数，对于基类的构造函数，编译器将会为派生类与之对应的派生类版本<code>derived(params) : base(args) {}</code></li>
<li>构造函数的using声明不会改变该构造函数的访问级别（私有还是私有，公有还是共有）</li>
<li>当基类构造函数有默认实参，派生类将获得多个构造函数，每个构造函数省略掉一个含有默认实参的形参</li>
<li>派生类不继承某些构造函数的原因可能是：<ul>
<li>派生类自己定义了有相同参数列表的构造函数</li>
<li>默认、移动、拷贝构造函数按照正常规则被合成</li>
</ul>
</li>
</ul>
<h6 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h6><ul>
<li>不能把具有继承关系的对象放在一个容器中</li>
<li>在容器中放置（智能）指针而非对象</li>
<li>派生类的（智能）指针可以隐式转换为基类的（智能）指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;shared_ptr&lt;quote&gt;&gt; basket;</span><br><span class="line">basket.push_back(make_shared&lt;quote&gt;(<span class="string">"00001"</span>, <span class="number">50</span>));</span><br><span class="line">basket.push_back(make_shared&lt;derived_quote&gt;(<span class="string">"972719"</span>, <span class="number">35</span>, <span class="number">21</span>, <span class="number">7</span>));</span><br></pre></td></tr></table></figure>
<h5 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h5><h6 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h6><ul>
<li>每个基类包含一个可选的访问说明符</li>
<li>关键字<code>class</code>的默认访问说明符是<code>private</code>，<code>struct</code>的默认访问说明符是<code>public</code></li>
<li>派生类的对象包含每个基类的子对象，派生类的构造函数初始值只能初始化它的直接基类</li>
<li><strong>基类的构造顺序与派生列表中的基类出现的顺序一致</strong></li>
<li>多重构造在析构时，顺序与构造时相反，派生类的析构函数只负责销毁自己的部分</li>
<li>派生列表中，同一个基类只能出现一次</li>
</ul>
<p><strong>多重继承构造函数的继承</strong></p>
<ul>
<li>C++11中允许派生类从他的基类中继承构造函数</li>
<li>如果继承的多个构造函数相同（形参列表完全相同），程序产生错误</li>
<li>如果不想上述错误出现，这个类必须为该构造函数定义它自己的版本</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct base1 &#123;</span><br><span class="line">    base1() = <span class="keyword">default</span>;</span><br><span class="line">    base1(<span class="keyword">const</span> string&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">struct base2 &#123;</span><br><span class="line">base2() = <span class="keyword">default</span>;</span><br><span class="line">base2(<span class="keyword">const</span> string&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// D1尝试继承两个基类中的参数为 const string&amp; 的构造函数</span></span><br><span class="line">struct D1 : <span class="keyword">public</span> base1, <span class="keyword">public</span> base2 &#123;</span><br><span class="line">    using base1::base1;  <span class="comment">// 继承base1</span></span><br><span class="line">    using base2::base2;  <span class="comment">// 继承base2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct D2 : <span class="keyword">public</span> base1, <span class="keyword">public</span> base2 &#123;</span><br><span class="line">    using base1::base1;  <span class="comment">// 继承base1</span></span><br><span class="line">    using base2::base2;  <span class="comment">// 继承base2</span></span><br><span class="line">    <span class="comment">// 定义自己的 参数为 const string&amp; 的构造函数</span></span><br><span class="line">    D2(<span class="keyword">const</span> string&amp; s) : base1(s), base2(s);</span><br><span class="line">    D2() = <span class="keyword">default</span>;  <span class="comment">// 一旦D2定义了自己的构造函数，就必须出现这个</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h6><ul>
<li>可以使某个可访问的基类的指针、引用直接指向一个派生类的对象</li>
<li>编译器认为基类们向派生类的转换不分优劣，因此可能会产生二义性错误</li>
</ul>
<h6 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h6><ul>
<li>派生类可能通过直接基类间接继承自同一个间接基类，所以派生类对象会包含两份间接基类的对象</li>
<li>虚继承可以解决上述问题，<strong>其目的是令某个类作出声明，承诺愿意共享它的基类</strong></li>
<li>共享的基类称为虚基类</li>
<li><strong>含有虚基类的对象构造顺序：虚基类总是先于非虚基类构造</strong></li>
<li>先虚：虚子对象按照他们在派生列表中出现的顺序从左向右出现，然后才是非虚对象从左向右</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base是D1、D2的虚基类</span></span><br><span class="line">class D1 : public virtual base &#123;&#125;;</span><br><span class="line">class D2 : virtual public base &#123;&#125;;</span><br></pre></td></tr></table></figure>
<pre><code>class Character {};
class BookCharacter : public Character{};
class ZooAnimal {};
class Bear : public ZooAnimal{};
class ToyAnimal{};
class TeddyBear : public BookCharacter, public Bear, public virtual ToyAnimal{};
// 构造TeddyBear时，构造顺序如下：
ZooAnimal();
ToyAnimal();
Character();
BookCharacter();
Bear();
TeddyBear();
</code></pre><h4 id="标准库特殊设施"><a href="#标准库特殊设施" class="headerlink" title="标准库特殊设施"></a>标准库特殊设施</h4><h5 id="bitset类"><a href="#bitset类" class="headerlink" title="bitset类"></a>bitset类</h5><p><code>#include &lt;bitset&gt;</code></p>
<h6 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h6><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bitset&lt;n&gt; b</code></td>
<td><code>b有n位，每一位均是0。此构造函数为constexpr</code></td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(u)</code></td>
<td><code>b是unsigned long long值u的低n位的拷贝，如果u没有n位，则补0。此构造函数为constexpr</code></td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(s, pos, m, zero, one)</code></td>
<td><code>explicit型。从string s的pos（默认为0）位置开始的m（默认为string::npos）个字符，s中只能包含zero（默认&#39;0&#39;）和one（默认&#39;1&#39;）</code></td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(cp, pos, m, zero, one)</code></td>
<td><code>explicit型。从字符数组cp的pos（默认为0）位置开始的m（默认为string::npos）个字符，cp中只能包含zero（默认&#39;0&#39;）和one（默认&#39;1&#39;）</code></td>
</tr>
</tbody>
</table>
</div>
<h6 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h6><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>b.any()</code></td>
<td><code>b中是否有为1的二进制位</code></td>
<td><code>b.all()</code></td>
<td><code>是否所有的位置都为1</code></td>
</tr>
<tr>
<td><code>b.none()</code></td>
<td><code>b中是否所有的位置都为0</code></td>
<td><code>b.count()</code></td>
<td><code>b中1的个数</code></td>
</tr>
<tr>
<td><code>b.size()</code></td>
<td><code>b中位数总和，constexpr型</code></td>
<td><code>b.test(pos)</code></td>
<td><code>pos位位1：true，否则false</code></td>
</tr>
<tr>
<td><code>b.set(pos, v)</code></td>
<td><code>将pos位置为v(默认true是1)，不带参数pos则设置所有位</code></td>
<td><code>b.reset(pos)</code></td>
<td><code>将pos复位，没有pos则全部复位</code></td>
</tr>
<tr>
<td><code>b.flip(pos)</code></td>
<td><code>反转pos位或者全部反转</code></td>
<td><code>b[pos]</code></td>
<td><code>访问pos位置，如果b是const的，返回true/false布尔值</code></td>
</tr>
<tr>
<td><code>b.to_ulong()</code></td>
<td><code>返回b对应的unsigned long值，放不下则抛出异常</code></td>
<td><code>b.to_ullong()</code></td>
<td><code>返回b对应的unsigned long long值，放不下则抛出异常</code></td>
</tr>
<tr>
<td><code>b.to_string(zero, one)</code></td>
<td><code>将b转换成&#39;0&#39;,&#39;1&#39;组成的string类型</code></td>
<td><code>os&lt;&lt;b</code></td>
<td><code>打印b中的01流</code></td>
</tr>
<tr>
<td><code>is&gt;&gt;b</code></td>
<td><code>从is读入字符存入b，当下一个字符不是&#39;0&#39;,&#39;1&#39;或是已经到达b.size()时停止</code></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h5 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h5><p><code>#include &lt;random.h&gt;</code></p>
<h6 id="随机数引擎类和随机数分布"><a href="#随机数引擎类和随机数分布" class="headerlink" title="随机数引擎类和随机数分布"></a>随机数引擎类和随机数分布</h6><p>随机数引擎是函数对象类，定义了调用运算符，该运算符不接收参数并返回一个随机unsigned整数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;</span><br><span class="line">e();</span><br></pre></td></tr></table></figure></p>
<p>随机数引擎操作如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Engine e</code></td>
<td><code>默认构造函数，使用默认种子</code></td>
</tr>
<tr>
<td><code>Engine e(s)</code></td>
<td><code>使用整型值s作为种子</code></td>
</tr>
<tr>
<td><code>e.seed(s)</code></td>
<td><code>使用种子s重置e的状态</code></td>
</tr>
<tr>
<td><code>e.min()</code></td>
<td><code>此引擎可生成的最小值</code></td>
</tr>
<tr>
<td><code>e.max()</code></td>
<td><code>最大值</code></td>
</tr>
<tr>
<td><code>Engine::result_type</code></td>
<td><code>此引擎生成的unsigned整型类型</code></td>
</tr>
<tr>
<td><code>e.discard(u)</code></td>
<td><code>将引擎推进u步，u的类型位uul</code></td>
</tr>
</tbody>
</table>
</div>
<p>为了得到一个指定范围内的数，使用一个分布类型的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0-9之间的均匀分布</span></span><br><span class="line"><span class="comment">// u是一个调用运算符，接受一个随机数引擎作为参数</span></span><br><span class="line"><span class="function">unifrom_int_distribution&lt;unsigned&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">default_random_engine e;</span><br><span class="line">cout &lt;&lt; u(e) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<h6 id="其他随机数分布"><a href="#其他随机数分布" class="headerlink" title="其他随机数分布"></a>其他随机数分布</h6><ul>
<li>使用<code>uniform_real_distribution&lt;double&gt;</code>类型的对象生成随机浮点数，用法类似上面</li>
<li><code>uniform_real_distribution&lt;&gt;</code>默认为<code>double</code>类型</li>
<li>高斯分布：<code>normal_distribution&lt;&gt; n(u, sigma);</code> // 均值为<code>u</code>，标准差为<code>sigma</code></li>
<li><code>lround(a)</code>函数对<code>a</code>进行四舍五入转化为整数，来自头文件<code>cmath</code></li>
<li><code>bernoulli_distribution b(p)</code>一次成功概率为<code>p</code>。它不是模板类（没有<code>&lt;&gt;</code>）</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/06/Cpp-Rule-Fragment2/" data-id="ckychngpe00217gphi06imz11" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-BM" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/04/BM/">BM</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/04/BM/">
            <time datetime="2017-03-04T12:33:18.000Z" itemprop="datePublished">2017-03-04</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/String/">String</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="BM介绍"><a href="#BM介绍" class="headerlink" title="BM介绍"></a>BM介绍</h6><p>KMP算法是一种利用模式串前缀移动的字符串匹配算法，时间复杂度为<code>O(n)</code>。<br>BM算法是一种使用了两个跳转表的字符串匹配算法，单模式匹配有更加出色的表现。</p>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fdb3b45fkbj216t0d8753" alt=""></p>
<p>上图表述了BM算法的大致过程，模式串是<code>AT-THAT</code>，于KMP不同，BM算法<strong>对每一次匹配尝试从后向前匹配的方法</strong>。</p>
<ol>
<li><p>第一次匹配从第7位开始。第7为不能匹配，移动模式串，注意到目标串第7为为<code>F</code>，<code>F</code>不在模式串中，所以可以直接将模式串的首位移到目标串第8位。</p>
</li>
<li><p>接着从后向前匹配，目标串的14位<code>-</code>与模式串最后一位不匹配，但是<code>-</code>在模式串中，所以将模式串中最靠后的<code>-</code>移到与目标串的14位对齐。</p>
</li>
<li><p>再从后向前匹配，目标串的第18位<code>T</code>与模式串的最后一位匹配，向前看一位，17位<code>L</code>不匹配，且<code>L</code>不在模式串中，所以把模式串第一位移到目标串第18位。</p>
</li>
<li><p>接着从后向前匹配，第23、24位匹配，22位不匹配，由于模式串的前两位等于后两位，所以将模式串移动使其前两位到后两位的位置上。</p>
</li>
</ol>
<h6 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h6><p>假设目标串T长度为n，模式串P长度为m</p>
<p>坏字符规则分为两种情况：</p>
<ul>
<li>坏字符没出现在模式串中，这时可以把模式串首移动到坏字符的下一个字符</li>
<li>坏字符出现在模式串中，这时可以<strong>把模式串第一个出现的坏字符和母串的坏字符对齐</strong>（当然，这样可能造成模式串倒退移动）</li>
</ul>
<p>使用一个数组<code>bad</code>，<code>bad[&#39;k&#39;]</code>表示坏字符在模式串中最左侧的字符<code>&#39;k&#39;</code>距离模式串末尾的长度，如果字符’k’不在模式串中，<code>bad[&#39;k&#39;]=m</code>。那么遇到坏字符时模式串可以移动的距离为：<code>bad[T[i]]-(m-1-i)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m为模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_bad</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* P, <span class="keyword">int</span> m, <span class="keyword">int</span>* bad)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++)</span><br><span class="line">         bad[i] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        bad[P[i]] = m-i-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h6><p>发现某个字符不匹配的同时，已有部分字符匹配成功。假设模式串P已经匹配成功的部分为Q</p>
<ul>
<li>模式串中有子串匹配上好后缀，此时移动模式串，让该子串和好后缀对齐即可，如果超过一个子串匹配上好后缀，则选择最靠左边的子串对齐</li>
<li>模式串中没有子串匹配上好后缀，此时需要寻找模式串的一个最长前缀，并让该前缀等于好后缀的后缀，寻找到该前缀后，让该前缀和好后缀对齐即可</li>
<li>模式串中没有子串匹配上后后缀，并且在模式串中找不到最长前缀，让该前缀等于好后缀的后缀。此时，直接移动模式到好后缀的下一个字符</li>
</ul>
<p>为了实现好后缀规则，需要定义一个数组<code>suffix[]</code>，其中<code>suffix[i] = s</code> 表示以<code>i</code>为右边界，与模式串后缀匹配的最大长度为<code>s</code>，即<code>P[i-s:s]==P[m-s:m]</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffixes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *P, <span class="keyword">int</span> m, <span class="keyword">int</span> *suff)</span> </span>&#123;</span><br><span class="line">    suff[m-<span class="number">1</span>]=m;</span><br><span class="line">        <span class="keyword">for</span> (i=m-<span class="number">2</span>；i&gt;=<span class="number">0</span>；--i)&#123;</span><br><span class="line">            q=i;</span><br><span class="line">            <span class="keyword">while</span>(q&gt;=<span class="number">0</span>&amp;&amp;P[q]==P[m-<span class="number">1</span>-i+q])</span><br><span class="line">                --q;</span><br><span class="line">            suff[i]=i-q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义<code>good[]</code>数组表示遇到好后缀时，模式串应该移动的距离。其中<code>i</code>表示好后缀前面一个字符的位置（也就是坏字符的位置）.对应上面三种情况，<code>good</code>数组构建方法如下：<br><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fdb6nka0aqj20y013zgq7" alt=""></p>
<p>上面的三种情况，移动的距离是逐渐增大的，在满足不止一种情况时，应该移动最小的距离。所以分三部分考虑，</p>
<ul>
<li>对第三种情况，移动距离就是P的长度</li>
<li>对第二种情况，我们要找前缀，所以如果位置<code>i</code>到第一个是满足条件的话，必然有<code>suff[i]=i+1</code>，满足条件时，坏字符出现在<code>[0,m-1-i)</code>位置上时都可以移动<code>m-1-i</code>位使得模式串前<code>i+1</code>位与后<code>i+1</code>位重叠。对于<code>i</code>，从大到小计算是因为越长的前缀意味着越小的移动步数，我们希望找到小的，更新时判断<code>good[j]==m</code>也是为了不多次更新。</li>
<li>对第一种情况，我们知道当<code>m-1-suff[i]</code>位置为坏字符时，需要移动<code>m-i-1</code>位</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_good</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *P, <span class="keyword">int</span> m, <span class="keyword">int</span> bmGs[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, suff[<span class="number">256</span>];</span><br><span class="line">    suffixes(x, m, suff);</span><br><span class="line">    <span class="comment">// 第三种情况</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        good[i] = m;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第二种情况</span></span><br><span class="line">    <span class="keyword">for</span> (i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (suff[i] == i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; m - <span class="number">1</span> - i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (good[j] == m)</span><br><span class="line">                good[j] = m - <span class="number">1</span> - i;</span><br><span class="line">     <span class="comment">// 第一种情况</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m - <span class="number">2</span>; ++i)</span><br><span class="line">          good[m - <span class="number">1</span> - suff[i]] = m - <span class="number">1</span> - i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后给出BM算法，<strong>对于出现无法匹配的时候，移动步数取好后缀和坏字符两种情况的最大值</strong>。完整代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BM</span><span class="params">(<span class="keyword">char</span> *P, <span class="keyword">int</span> m, <span class="keyword">char</span> *S, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, good[m], bad[<span class="number">256</span>], k=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Preprocessing */</span></span><br><span class="line">    get_bad(P, m, bad);</span><br><span class="line">    get_good(P, m, good);</span><br><span class="line">    i = j = m-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Searching */</span></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n - m) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i!=<span class="number">0</span> &amp;&amp; P[i]==S[j]) &#123;  <span class="comment">// 从后向前匹配、直到找到不匹配或者完全匹配</span></span><br><span class="line">            --i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到一个匹配</span></span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; P[i]==S[j]) &#123;</span><br><span class="line">            m++;</span><br><span class="line">            j += good[<span class="number">0</span>];  <span class="comment">// 找到匹配算是好后缀情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j += good[i]&gt;bad[S[j]] ? good[i] : bad[S[j]];</span><br><span class="line">        &#125;</span><br><span class="line">        i = m-<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/04/BM/" data-id="ckychngme00007gph7fec0hti" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Decision-Tree" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/02/Decision-Tree/">Decision Tree</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/02/Decision-Tree/">
            <time datetime="2017-03-02T01:39:28.000Z" itemprop="datePublished">2017-03-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/machine-learning/">machine learning</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h5><ul>
<li>决策树是一种基本的分类与回归的方法</li>
<li>决策树由节点和有向边组成</li>
<li>节点分为内部节点和叶节点</li>
<li><strong>决策树的学习其实就是特征选择的过程</strong></li>
</ul>
<h5 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h5><p><strong>决策树学习算法包含特征选择、决策树的生成和决策树的剪枝过程</strong></p>
<p>给定数据集$D=\lbrace (x_1,y_1),…,(x_m,y_m) \rbrace$其中$m$为样本容量，$x_i=(x_i^{(1)},…,x_i^{(n)})$，$n$为特征个数；$y_i\in \lbrace 1,2,…,K \rbrace$为类标记。</p>
<h6 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h6><p>统计学中，熵是随机变量不确定性的度量，即混乱程度。假设$X$是一个取有限个值的离散随机变量，其概率分布为$P(X=x_i)=p_i,i=1,..,N$，那么$X$的熵定义为<script type="math/tex">H(X)=-\sum_{i=1}^n p_i log p_i</script>条件熵$H(Y|X)$可以表示为已知随机变量$X$的条件下，随机变量$Y$的不确定性，也可以表示成<script type="math/tex">H(Y|X)=\sum_{i=1}^N p_iH(Y|X=x_i)</script>其中$p_i=P(X=x_i)$。<strong>当熵和条件熵中的概率由数据估计得到时，则分别称之为经验熵和条件经验熵</strong>，如果出现0概率，则令$0log0=0$。</p>
<p><strong>信息增益表示在得知特征$X$的情况下而使得$Y$的不确定性减少的程度</strong>，形式化表述为：特征$A$对训练数据集$D$的信息增益$g(D,A)$，定义为<script type="math/tex">g(D,A)=H(D)-H(D|A)</script>这里的<strong>信息增益等价于训练数据集中类与特征的互信息</strong>。计算信息增益的算法如下：</p>
<hr>
<p>输入：数据集$D$和特征$A$</p>
<hr>
<p>1 计算数据集$D$的经验熵$H(D)=-\sum_{k=1}^K \frac{|C_k|}{|D|}log_2\frac{|C_k|}{|D|}$<br>2 计算特征$A$对数据集$D$的经验条件熵<script type="math/tex">H(D|A)=\sum_{i=1}^N \frac{|D_i|}{|D|}H(D_i)=-\sum_{i=1}^N \frac{|D_i|}{|D|}\sum_{k=1}^K\frac{|D_{ik}|}{|D_i|}log_2\frac{|D_{ik}|}{|D_i|}</script><br>3 计算信息增益$g(D,A)=H(D)-H(D|A)$.</p>
<hr>
<p>输出信息增益</p>
<hr>
<h6 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h6><p><strong>以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的特征的问题</strong>，使用信息增益比可以缓解这个问题。特征$A$对训练数据集$D$的信息增益比定义为其增益信息$g(D,A)$与训练数据集$D$关于特征$A$的值的熵$H_A(D)$之比，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
g_R(D,A)=\frac{g(D,A)}{H_A(D)}
\end{aligned}</script><p>其中，$H_A(D)=-\sum_{i=1}^{A_n}\frac{|D_i|}{|D|}log_2\frac{|D_i|}{|D|}$，$A_n$是特征$A$取值的个数。</p>
<h6 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h6><p>ID3算法采用<strong>自上而下递归式的算法构建决策树，它使用信息增益作为特征选择的标准</strong>。停止条件是节点所有特征的信息增益都很小（阈值$\epsilon$）或没有特征可以选择为止。</p>
<hr>
<p>输入：训练数据集$D$，特征集$A$，阈值$\epsilon$</p>
<hr>
<p>1 若$D$中所有实例属于同一类$C_k$，$T$为单节点树，$C_k$为该节点的类标记，返回$T$<br>2 若$A=\emptyset$则$T$为单节点树，将$D$中实例数最大的类$C_k$作为该节点的类标记，返回$T$<br>3 否则，分别计算$A$中各特征对$D$的信息增益，选择信息增益最大的特征$A_g$<br>4 如果$A_g&lt;\epsilon$，则置T为单节点树，将$D$中实例数最大的类$C_k$作为该节点的类标记，返回$T$<br>5 否则，对$A_g$的每一个可能值$a_i$，根据$A_g=a_i$将$D$分割成若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子节点，由节点及其子节点构成树$T$，返回$T$<br>6 对每个子节点$i$，以$D_i$为训练集，以$A-A_g$为特征集，递归调用以上步骤</p>
<hr>
<p>输出：决策树$T$</p>
<hr>
<h6 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h6><p><strong>C4.5与ID3的差异在于C4.5使用信息增益比进行选择选择</strong></p>
<h6 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h6><p><strong>基尼指数表示不确定程度，基尼指数越大，样本集的不确定程度就越大、纯度越低。</strong></p>
<p>分类问题中，假设有$K$个类，样本点属于第$k$类的概率为$p_k$，则概率分布的基尼指数定义为<script type="math/tex">Gini(p)=1-\sum_{k=1}^K p_k^2</script>对于给定的样本集$D$，其基尼指数为<script type="math/tex">Gini(D)=1-\sum_{k=1}^K\left( \frac{|C_k|}{|D|} \right)^2</script>其中$C_k$表示第$k$类的样本子集。表示集合$D$的不确定性。</p>
<p>假设样本集$D$根据特征$A$的不同取值被分成$A_n$个部分，则定义在特征$A$下集合$D$的基尼指数为</p>
<script type="math/tex; mode=display">
\begin{aligned}
Gini(D,A)=\sum_{i=1}^{A_n} \frac{|D_i|}{|D|}Gini(D_i)
\end{aligned}</script><h6 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h6><p><strong>CART分类树</strong><br>使用基尼指数作为划分属性的标准，每次选择基尼指数最小的属性。</p>
<p><strong>CART回归模型</strong><br>假设已将输入空间划分为$M$个单元$R_1,…,R_M$，并且在每个单元$R_m$上有一个固定的输出值$c_m$，回归树模型可以表示为<script type="math/tex">f(x)=\sum_{m=1}^Mc_mI(x\in R_m)</script>当输入空间划分确定时，可以用平方误差$\sum_{x_i}(y_i-f(x_i))^2$表示训练误差,<strong> $c_m$输出值为对应$R_m$上所有样本输出值的均值</strong>。</p>
<p>使用启发式的方法划分输入空间，遍历输入变量和可能的切分变量找到最优的切分变量$j$和切分点$s$，即找到切分后部分的误差最小：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&R_1(j,s)=\lbrace{x|x^{(j)}\le s\rbrace}  \\
&R_2(j,s)=\lbrace x|x^{(j)}> s \rbrace  \\
&\min_{j,s} \left[ \min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2 + \min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2  \right]
\end{aligned}</script><p>其中$c_1,c_2$是划分后部分中输出值的均值。最小二乘回归树算法描述如下：</p>
<hr>
<p>输入：训练集$D$</p>
<hr>
<ol>
<li>选择最优切分变量$j$与最优切分点$s$，求解$\min_{j,s} \left[ \min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2 + \min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2  \right]$</li>
<li>用选定的对$(j,s)$划分区域并决定相应输出值：$R_1,R_2,c_1,c_2$</li>
<li>继续对两个子区域调用步骤1、2直至满足停止条件</li>
<li>将输入空间划分为$M$个区域$R_1,…,R_M$，生成CART树$f(x)=\sum_{m=1}^Mc_mI(x\in R_m)$</li>
</ol>
<hr>
<p>输出：$f(x)$</p>
<hr>
<h5 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h5><p>以上方法可能会产生过拟合现象，适当剪枝会使得决策树的泛化效果变得更好<br>剪枝分为预剪枝和后剪枝两种，预剪枝指的是在决策树生成的过程中进行剪枝，后剪枝则是在生成决策树之后再进行剪枝。</p>
<h6 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h6><p>大致过程描述：对于一个节点，考虑其剪枝或者不剪枝的情况，看这两种情况下哪种正确率高（一个节点的类别由其包含同类样本数最多的决定），由此决定是否剪枝。</p>
<p><strong>预剪枝基于贪心本质禁止某些节点展开，而这些节点第一次展开效果可能不好，但后续表现可能显著提高，所以会带来欠拟合的风险</strong>。</p>
<h6 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h6><p>大致过程描述：自下而上，叶节点不考虑，考虑其父节点F是否需要剪枝，可以仅仅通过父节点包含的样本，在剪枝和不剪枝的情况下分别计算准确率，然后确定是否需要剪枝。</p>
<p>下面是令一种后剪枝的方法（我不是很了解）：<br>通过<strong>极小化决策树整体的损失函数来实现</strong>。设树的叶节点个数为$|T|$，$t$是树$T$的叶节点，此叶节点上有$N_t$个样本，属于类$C_k$的样本有$N_{tk}$个，$H_t(T)$为叶节点$t$上的经验熵，$\alpha \ge 0$为参数，则决策树学习的损失函数可以定义为</p>
<script type="math/tex; mode=display">
\begin{aligned}
C_{\alpha}(T)=\sum_{t=1}^{|T|} N_tH_t(T)+\alpha |T|=C(T)+\alpha |T|
\end{aligned}</script><p>其中经验熵为$H_t(T)=-\sum_k \frac{N_{tk}}{N_t}log_2  \frac{N_{tk}}{N_t}$。$C(T)$表示模型对训练数据的预测误差，|T|表示模型的复杂度。剪枝算法描述如下：</p>
<hr>
<p>输入：决策树$T$，参数$\alpha$</p>
<hr>
<p>1 计算每个节点的经验熵<br>2 递归地从树的节点向上回溯，如果保留子节点的损失函数更大，剪枝以父节点作为叶子<br>3 返回2直到不能继续为止</p>
<hr>
<p>输出：修建后的决策树$T_{\alpha}$</p>
<hr>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/02/Decision-Tree/" data-id="ckychngpr002h7gphdz1ofel7" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Bayesian-Classifier" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/02/26/Bayesian-Classifier/">Bayesian Classifier</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/02/26/Bayesian-Classifier/">
            <time datetime="2017-02-26T06:49:57.000Z" itemprop="datePublished">2017-02-26</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/machine-learning/">machine learning</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h6><p>输入空间$\mathbb{R}$为$n$维向量的集合，输出空间为类标记集合$\mathcal{Y}=\lbrace c_1,c_2,…,c_K \rbrace$，给定训练数据集<script type="math/tex">T=\lbrace (x_1,y_1),...,(x_N,y_N) \rbrace</script>由联合概率分布$P(X,Y)$独立同分布产生。</p>
<p>朴素贝叶斯分类器旨在<strong>最大化后验概率</strong>，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
c&=\arg\max_{c_k} P(Y=c_k|X=x) \\
 &=\arg\max_{c_k} \frac{P(X=x|Y=c_k)P(Y=c_k)} {\sum_k P(X=x|Y=c_k)P(Y=c_k)}
\end{aligned}</script><p>由于对于每一个不同的类别，上式中的分母都是一样的，所以上面的目标公式可以写成</p>
<script type="math/tex; mode=display">
\begin{aligned}
c=\arg\max_{c_k} P(X=x|Y=c_k)P(Y=c_k)
\end{aligned}</script><p>对于这个优化目标，可做如下统计</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(Y=c_k) &= \frac{ I\lbrace Y=c_k \rbrace }{N}
\end{aligned}</script><p>朴素贝叶斯分类器对条件概率分布进行了<strong>条件独立性</strong>的假设 而$P(X=x|Y=c_k)$可以分解为</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(X=x|Y=c_k)=\prod_j^n P(X^{(j)}=x^{(j)}|Y=c_k)
\end{aligned}</script><p>所以上式可以分开考虑，即在满足$Y=c_k$的集合中分别考虑，$P(X^{(1)}=x^{(1)}|Y=c_k)$就等于$Y=c_k$的集合中第一个属性为$x^{(1)}$样本所占的比例，所以上式可以写成</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(X=x|Y=c_k)=\prod_j^n \frac {I\lbrace X^{(j)}=x^{(j)}|Y=c_k \rbrace} {I\lbrace Y=c_k \rbrace}
\end{aligned}</script><p>所以，经过统计，就可以使用后验概率最大准则进行分类。</p>
<p>当然，也可以使用极大似然估计对单个属性和属性进行建模，用$D_c$表示数据集中第$c$类样本的集合，参数$\theta_c$表示对第$c$类样本的建模，所以有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathcal{l} &= log \prod_{x\in D_c}P(x|\theta_c) \\
 &= \sum_{x\in D_c} logP(x|\theta_c)
\end{aligned}</script><p>对$P(x|\theta_c)$进行适当建模，比如$P(x|\theta_c) \sim \mathcal{N}(\mu_c, \sigma^2_c)$，然后用经典的极大似然估计进行估值即可。</p>
<h6 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h6><p>对于朴素贝叶斯分类器，做如下统计计算时</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(X=x|Y=c_k)=\prod_j^n \frac {I\lbrace X^{(j)}=x^{(j)}|Y=c_k \rbrace} {I\lbrace Y=c_k \rbrace}
\end{aligned}</script><p>分子、分母可能为0，所以这里使用<strong>拉普拉斯平滑</strong>，所以统计方法如下</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(Y=c_k) &= \frac{ I\lbrace Y=c_k \rbrace+\lambda }{N+\lambda K} \\
P(X=x|Y=c_k)&=\prod_j^n \frac {I\lbrace X^{(j)}=x^{(j)}|Y=c_k \rbrace+\lambda} {I\lbrace Y=c_k \rbrace+\lambda K_j}
\end{aligned}</script><p>其中，$K$是分类类别总数，而$K_j$表示第$j$个属性的可能取值数，$\lambda$是平滑参数，为1时则为Laplace平滑。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/02/26/Bayesian-Classifier/" data-id="ckychngn000067gpho86v9ko2" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Cpp-Rule-Fragment" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/02/23/Cpp-Rule-Fragment/">Cpp Rule Fragment</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/02/23/Cpp-Rule-Fragment/">
            <time datetime="2017-02-23T00:50:23.000Z" itemprop="datePublished">2017-02-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Dev/">Dev</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Cpp/">Cpp</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h4 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><h6 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h6><p>C++11中，一下初始化方法都是成立的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>使用花括号初始化变量在C++11中得到全面应用，但是用于内置类型的变量时，使用花括号初始化形式有个重要的特点：</p>
<pre><code>使用列表初始化且初始化存在丢失信息的风险，编译器将报错
</code></pre><p>比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> db = <span class="number">3.141592653</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;db&#125;;              <span class="comment">// 错误，转换存在丢失信息的风险</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y</span><span class="params">(db)</span></span>;              <span class="comment">// 正确，转换执行，丢失部分信息</span></span><br></pre></td></tr></table></figure>
<h6 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h6><p>如果内置类型的变量未被显示初始化，它的值由定义的位置决定。<strong>定义与任何函数体之外的变量初始化为0，定义于函数体内部的内置类型将不会被初始化</strong>。</p>
<h5 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h5><ul>
<li>声明使得名字为程序所知，定义负责创建与名字关联的实体</li>
<li>只声明一个变量而非定义它，使用<code>extern</code>关键字，不要显示初始化</li>
<li>任何包含了显示初始化的声明即成了定义</li>
<li>变量只能定义一次，但是可以声明多次</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="keyword">int</span> i;     <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">int</span> j;            <span class="comment">// 声明且定义</span></span><br><span class="line">extern <span class="keyword">int</span> k = <span class="number">2</span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<h5 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h5><h6 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h6><ul>
<li>引用必须被初始化，因为引用是要和初始值绑定到一起的</li>
<li>引用不能被重新绑定到另一个对象</li>
<li>引用不能被绑定到字面值、表达式计算结果</li>
<li>引用类型要与绑定对象类型严格匹配，只在极少数情况下有例外</li>
<li>因为引用不是对象，所以不能创建引用的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>, &amp;y = x, z=<span class="number">20</span>;</span><br><span class="line">&amp;y = z;         <span class="comment">// 错误，不能重新绑定</span></span><br><span class="line">y = z;          <span class="comment">// 正确，相当于赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;i = <span class="number">10</span>;   <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">double</span> j = <span class="number">2.55</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;k = j;    <span class="comment">// 错误，类型不匹配</span></span><br></pre></td></tr></table></figure>
<h6 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h6><ul>
<li>指针是一个对象，可以有指针的指针，且无需定义时赋初值</li>
<li>指针类型要与其指向对象类型严格匹配，只在极少数情况下有例外</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成空指针的方法</span></span><br><span class="line"><span class="keyword">int</span> *p1 = nullptr;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3 = NULL;</span><br></pre></td></tr></table></figure>
<p>void*指针</p>
<ul>
<li>可以存放任意对象的地址</li>
<li>不能直接操作void*指针指向的对象，因为不知道其类型</li>
</ul>
<h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><ul>
<li>const对象必须初始化，一旦创建，不能修改</li>
<li>利用一个对象去初始化另一个对象，无论他们是不是const都无关紧要，因为拷贝不会改变什么</li>
<li>默认情况下，const变量尽在文件内有效</li>
<li>多个文件共享的方法：声明、定义都添加extern关键字</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file 1，定义、初始化</span></span><br><span class="line">extern <span class="keyword">const</span> <span class="keyword">int</span> x = getSize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// file 2，再次声明一下，与file 1中的是同一个</span></span><br><span class="line">extern <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure>
<h6 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h6><ul>
<li>不能通过引用改变常量的值</li>
<li>初始化常量引用时允许用任意表达式作为初始值，只要表达式结果能转换成引用类型即可</li>
<li><strong>允许为一个常量引用绑定非常量对象、字面值，甚至表达式</strong>，非常量不行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i; <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>; <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span>; <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1*<span class="number">2</span>;     <span class="comment">// 错误，r4是非常量引用</span></span><br></pre></td></tr></table></figure>
<h6 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h6><p><strong>指向常量的指针</strong></p>
<ul>
<li><strong>允许指向常量的指针指向非常量对象</strong></li>
<li>常量对象的地址只能存在指向常量的指针里</li>
</ul>
<p><strong>常量指针</strong></p>
<ul>
<li>常量指针是常量，必须初始化，且一旦初始化就不能改变，但其指向的对象可以被改变</li>
</ul>
<p><strong>顶层const</strong><br>顶层const表示指针本身是个常量，顶层const表示指针指向一个常量<br>左为底，右为顶即可分辨<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k=<span class="number">0</span>; <span class="comment">// 这个也是顶层const</span></span><br></pre></td></tr></table></figure></p>
<h6 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h6><ul>
<li>常量表达式的值不会改变，且在编译时期就能得到结果</li>
<li>C++11中将变量声明为constexpr类型，由编译器验证变量的值是否为常量表达式</li>
<li><strong>声明为constexpr的变量一定是常量，且必须用常量表达式初始化</strong></li>
<li>一个constexpr指针的初始值必须是nullprt或者0，或是存储与某个固定地址（比如全局变量，局部变量不行）中的对象</li>
<li>constexpr声明的指针，仅对指针有约束，不能约束指向的对象，顶层const</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="keyword">int</span> * p = nullptr; <span class="comment">// p是指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<h5 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h5><h6 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h6><p><strong>typedef</strong>和<strong>别名声明</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">double</span> wage, *p; <span class="comment">// wage是double同义词，p相当于double*</span></span><br><span class="line"></span><br><span class="line">using vi = vector;</span><br></pre></td></tr></table></figure></p>
<h6 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h6><ul>
<li>auto定义的变量必须有初始值</li>
<li>auto可以一次声明多个变量，但是这些变量的初始基本数据类型必须一样</li>
<li>auto推断的类型与原始类型可能会不太一样，比如<strong>auto会忽略掉顶层const</strong></li>
<li>引用类型也可以是auto，原来初始化规则适用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">auto a = i;       <span class="comment">// a是一个整数，顶层const被忽略</span></span><br><span class="line"><span class="keyword">const</span> auto b = i; <span class="comment">// b是一个const int</span></span><br><span class="line"></span><br><span class="line">auto &amp;c = i;</span><br><span class="line">auto &amp;d = <span class="number">42</span>; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> auto &amp;e = <span class="number">42</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h6 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h6><ul>
<li>decltype的作用是<strong>选择并返回操作数的严格基本类型</strong></li>
<li>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括const和引用）</li>
<li>如果表达式内容是解引用，decltype得到引用类型</li>
<li>如果<strong>变量名加上了一层或多层括号，就会被当成表达式，会得到引用类型</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>, &amp;cj=ci;</span><br><span class="line">decltype(ci) x=<span class="number">0</span>;  <span class="comment">// x为const int</span></span><br><span class="line">decltype(cj) y=x;  <span class="comment">// y为const int&amp;，y绑定到x</span></span><br><span class="line">decltype(cj) z;    <span class="comment">// 错误，z是引用，必须初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>, *p=&amp;i;</span><br><span class="line">decltype(*p) c;    <span class="comment">// 错误，c是int&amp;，必须初始化</span></span><br><span class="line"></span><br><span class="line">decltype(i) m;     <span class="comment">// 正确，一个未初始化的int</span></span><br><span class="line">decltype((i)) n;   <span class="comment">// 错误，int&amp; 必须初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串，向量，数组"><a href="#字符串，向量，数组" class="headerlink" title="字符串，向量，数组"></a>字符串，向量，数组</h4><p>数组不允许直接拷贝、赋值</p>
<h5 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h5><p>字符数组可以使用字符串字面值进行初始化，但字符串结尾处还有一个空字符<code>&#39;\0&#39;</code>，这个空字符也会被拷贝到数组中去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'c'</span>,<span class="string">'+'</span>, <span class="string">'+'</span>&#125;;         <span class="comment">// 长度为3</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">'c'</span>,<span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;  <span class="comment">// 长度为4</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"c++"</span>;              <span class="comment">// 长度为4</span></span><br><span class="line"><span class="keyword">char</span> a4[<span class="number">3</span>] = <span class="string">"c++"</span>;            <span class="comment">// 错误，数组空间不足</span></span><br></pre></td></tr></table></figure>
<h5 id="负载数组声明"><a href="#负载数组声明" class="headerlink" title="负载数组声明"></a>负载数组声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr[<span class="number">10</span>];           <span class="comment">// 含义10个整型指针的数组 </span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]=<span class="comment">/*...*/</span>  <span class="comment">// 不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>];     <span class="comment">// 指向一个10个整型元素数组的指针</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>]     <span class="comment">// 引用一个10个整型元素数组的指针</span></span><br></pre></td></tr></table></figure>
<h5 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h5><h6 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h6><p><strong><code>static_cast</code>可以完成任何具有明确定义的类型转换(支持强制转换)，只要不包含底层const</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> slope = static_cast&lt;<span class="keyword">double</span>&gt;(j) / i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p = &amp;d;</span><br><span class="line"><span class="keyword">double</span> *dp = static_cast&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure></p>
<h6 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h6><p><strong><code>const_cast</code>只能改变运算对象的底层const</strong>，通常用于有函数重载的上下文中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p = const_cast&lt;<span class="keyword">char</span>*&gt;(pc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp;</span><br><span class="line"><span class="keyword">char</span> *q = static_cast&lt;<span class="keyword">char</span>*&gt;(cp);  <span class="comment">// 错误，static_cast不能转换掉const性质</span></span><br><span class="line">static_cast&lt;string&gt;(cp);           <span class="comment">// 正确，字符串字面值转换成string属性</span></span><br><span class="line"><span class="keyword">const</span>&lt;string&gt;(cp);                 <span class="comment">// 错误，const_cast只改变常量属性</span></span><br></pre></td></tr></table></figure></p>
<h6 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h6><p><strong><code>reinterpret_cast</code>通常为运算对象的位模式提供较低层次上的重新解释</strong>，容易引发错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *cp = reinterpret_cast&lt;<span class="keyword">char</span>*&gt;(ip); <span class="comment">// 虽然转换，但pc所指对象依旧是int型</span></span><br></pre></td></tr></table></figure></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><ul>
<li><strong>用实参初始化形参时会忽略掉顶层const，也就是说给形参传递常量对象或者非常量对象都可以</strong></li>
<li>由于顶层const被忽略，只有形参顶层const差异的函数会被当成同一个函数</li>
<li><strong>可以使用一个非常量初始化一个底层const对象，但是反过来不行</strong></li>
<li><strong>普通引用必须用同类型的对象初始化</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;...&#125;        <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;...&#125;  <span class="comment">// 错误，重复定义func</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span>&#123;i=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line">string::size_type ctr = <span class="number">0</span>;</span><br><span class="line">reset(&amp;i);           <span class="comment">// 调用形参类型是int*的reset函数</span></span><br><span class="line">reset(i);            <span class="comment">// 调用形参类型是int&amp;的reset函数</span></span><br><span class="line">reset(&amp;ci);          <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br><span class="line">reset(ci);           <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br><span class="line">reset(<span class="number">42</span>);           <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br><span class="line">reset(ctr);          <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br></pre></td></tr></table></figure>
<h5 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h5><ul>
<li>一般函数的返回值均为右值，但也有返回左值的函数</li>
<li>由函数的返回值类型决定，具体来说，<strong>调用一个返回引用的函数得到左值，其他类型为右值</strong></li>
<li><strong>左值可以被赋值，右值不行</strong></li>
<li>如果返回值类型是常量引用，那么就不能赋值了（常量不能修改啊）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;get_val(string &amp;s, string::size_type ix) &#123; <span class="comment">//返回的是引用</span></span><br><span class="line">    <span class="keyword">return</span> s[ix];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line">get_val(s,<span class="number">3</span>) = <span class="string">'A'</span>;       <span class="comment">// 可以对左值进行赋值</span></span><br></pre></td></tr></table></figure>
<h5 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h5><p>普通的数组指针声明如下</p>
<pre><code>type (*name)[dimension]
</code></pre><p>返回数组指针的函数形式如下</p>
<pre><code>type ( *function(parameter_list) ) [dimension]
</code></pre><h6 id="类型别名-1"><a href="#类型别名-1" class="headerlink" title="类型别名"></a>类型别名</h6><p>也可以考虑使用类型别名</p>
<pre><code>typedef int arrT[10];
using arrT = int[10];
arrt* func(int i);
</code></pre><h6 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h6><ul>
<li>任何函数都可以使用尾置返回类型</li>
<li>这种返回方法对复杂的返回类型比较有效</li>
<li>尾置返回类型跟在形参列表后面，以<code>-&gt;</code>开头，在原本返回类型出现的地方加上<code>auto</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span> [10]</span>;</span><br></pre></td></tr></table></figure>
<h6 id="使用decltype"><a href="#使用decltype" class="headerlink" title="使用decltype"></a>使用decltype</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// decltype(odd) 返回的是数组，需要在加一个*变成指针</span></span><br><span class="line">decltype(odd) * func(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="comment">// ...........</span></span><br><span class="line">    <span class="keyword">return</span> &amp;odd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><ul>
<li>重载函数的名字肯定一样，需要形参类型或者数量上有差异</li>
<li>仅仅返回值不一样不是重载函数，而是重定义</li>
<li><strong>仅有顶层const的差异不构成重载，底层const可以</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;      <span class="comment">// 顶层const，重复定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *i)</span></span>;     <span class="comment">// 底层const，重载函数，指针换引用也一样</span></span><br></pre></td></tr></table></figure>
<h6 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h6><ul>
<li><strong>如果在内层作用域中声明名字，它将隐藏外层作用域中所有同名的实体</strong></li>
<li>声明在内部作用域的名字可能会是外部作用域中同名的所有重载函数失效（不声明名字就没事）</li>
<li>不同的作用域中无法承载函数名</li>
</ul>
<h5 id="默认语言用途"><a href="#默认语言用途" class="headerlink" title="默认语言用途"></a>默认语言用途</h5><h6 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h6><ul>
<li>默认实参填补函数调用缺少的尾部实参，所以默认形参都在尾部</li>
<li>尾部参数没省略时，中间参数不能省略</li>
<li>给定作用域中，一个形参只能被赋予一次默认实参</li>
<li><strong>局部变量不能成为默认实参</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span>=<span class="string">' '</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span>=<span class="string">'*'</span>)</span></span>;  <span class="comment">// 错误，重复声明</span></span><br></pre></td></tr></table></figure>
<h6 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h6><ul>
<li>优先选择精确匹配、最匹配，所谓最匹配要看实参与形参的接近程度</li>
<li>有且只有一个函数满足以下条件，则匹配成功<ul>
<li>该函数每个函数的匹配都不劣与其他函数需要的匹配</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配</li>
</ul>
</li>
<li>上面两步检查后没有函数脱颖而出，那么判定为二义性，报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>,<span class="number">2.5</span>);</span><br></pre></td></tr></table></figure>
<p>上面的例子中，对于第一个实参，<code>f(int,int)</code>好；对于第二个实参，<code>f(double,double)</code>好。最终判断此调用具有二义性，拒绝请求。</p>
<p>实参到形参的类型转换分为几个等级，如下</p>
<ol>
<li>精确匹配<ul>
<li>实参、形参类型相同</li>
<li>实参从数组或函数类型转化成对应的指针</li>
<li>向实参添加顶层const、从实参中删除顶层const</li>
</ul>
</li>
<li>通过const转换实现的匹配（比如创建指向非常量的常量指针、引用）</li>
<li>通过类型提升实现的匹配（short+int=int整型提升）</li>
<li>通过算术类型转换（int转double，所有算术类型转换级别一样）或指针实现的匹配</li>
<li>通过类类型转换实现的匹配</li>
</ol>
<h5 id="inline和constexpr"><a href="#inline和constexpr" class="headerlink" title="inline和constexpr"></a>inline和constexpr</h5><ul>
<li>inline函数编译时，一般适用于代码量很少的函数</li>
<li>const是指用于常量表达式的函数，返回类型及所有形参都必须是字面值类型，并且要求有且只有一个return语句</li>
<li>inline函数和constexpr函数可以多次定义，且通常定义在头文件内</li>
</ul>
<h5 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h5><h6 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h6><p>assert的用法是<code>assert(expr);</code>，如果表达式expr的值为true，assert什么也不做；否则，assert输出信息并终止程序执行。</p>
<h6 id="NDEBUG"><a href="#NDEBUG" class="headerlink" title="NDEBUG"></a>NDEBUG</h6><p>如果定义了NDEBUG，那么调试模式就关闭了，assert就不能起作用了。此外，NDEBUG也有助于开发者编写自己的调试代码。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define NDEBUG  // 表示关闭了调试模式</span><br><span class="line"></span><br><span class="line"># ifndef NDEBUG  // 没有关闭调试模式</span><br><span class="line"><span class="comment">// 。。。。</span></span><br><span class="line"># endif</span><br></pre></td></tr></table></figure></p>
<h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><ul>
<li>函数指针也是指针，可以赋值为nullptr、0等</li>
<li>指向不同函数类型的函数指针不存在类型转换</li>
<li><strong>定义重载函数指针时，指针类型必须与重载函数中的某一个精确匹配</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 定义函数指针</span></span><br><span class="line">bool (*pf)(<span class="keyword">int</span>) = func;     <span class="comment">// 定义指向函数func的函数指针</span></span><br><span class="line">bool (*pf)(<span class="keyword">int</span>) = &amp;func   <span class="comment">// 与上面等价</span></span><br><span class="line"><span class="comment">// 使用函数指针</span></span><br><span class="line">pf(<span class="number">1</span>);</span><br><span class="line">(*pf)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><strong>C++中，形参和返回值都不能是函数，但可以是函数指针</strong>，使用类型别名、decltype等可以使得函数指针的声明变得简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价的两种定义方式，funcp可以使用在函数实参、返回值</span></span><br><span class="line"><span class="function">typedef <span class="title">bool</span> <span class="params">(*funcp)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">typedef <span class="title">decltype</span><span class="params">(func)</span> *funcp</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用using、尾置返回类型</span></span><br><span class="line">using pf = bool(*) (<span class="keyword">int</span>);  <span class="comment">// pf是函数指针</span></span><br><span class="line"><span class="function">pf <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">using f  = bool (<span class="keyword">int</span>);     <span class="comment">// f类型是函数</span></span><br><span class="line">f *f1(<span class="keyword">int</span>);                    <span class="comment">// 显示指定返回类型是指向函数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function">auto <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> -&gt; <span class="title">bool</span><span class="params">(*)</span> <span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 尾置返回类型指定返回类型</span></span><br><span class="line">decltype(func) *f1(<span class="keyword">int</span>);        <span class="comment">// 知道返回的函数是哪一个更方便</span></span><br></pre></td></tr></table></figure></p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h5><h6 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h6><ul>
<li>const成员函数不能改变调用它的对象的内容</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">const_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回this对象的函数</span></span><br><span class="line"><span class="comment">// 返回值是引用</span></span><br><span class="line">New_Class&amp; New_Class::hello () &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    attribute += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">New_Class nc;</span><br><span class="line">nc.hello();  <span class="comment">// nc的attribute属性已经改变了</span></span><br></pre></td></tr></table></figure>
<h6 id="类相关的非成员函数"><a href="#类相关的非成员函数" class="headerlink" title="类相关的非成员函数"></a>类相关的非成员函数</h6><ul>
<li>这里的相关非成员函数包括但不限于<code>read</code>、<code>print</code>等</li>
<li>如果非成员函数是类接口的组成部分，这些函数的声明应当与类在同一个头文件内</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IO类型不能拷贝，所以只能以引用的形式加入形参</span></span><br><span class="line"><span class="comment">// 最后需要返回IO类型的引用</span></span><br><span class="line"><span class="comment">// ostream、print也类似，定义输出函数应该尽量减少对格式的控制</span></span><br><span class="line">istream &amp;read(istream &amp;is, New_Class &amp;item) &#123;</span><br><span class="line">    is &gt;&gt; item.a1 &gt;&gt; item.a2 &gt;&gt; item.a3;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">istream &amp;is;</span><br><span class="line">read(is, *<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><ul>
<li><strong>构造函数不能为const</strong></li>
<li><strong>const对象和引用都应该在初始值列表中初始化</strong></li>
<li>初始化列表：成员初始化的顺序与类定义中的顺序一致</li>
<li>构造const对象时，知道构造函数完成其初始化过程，对象才能取得其“常量”属性</li>
<li>默认构造函数的规则如下：<ul>
<li>如果有别的构造函数，编译器不会生成默认构造函数</li>
<li><strong>如果存在类内初始值，用它来初始化成员</strong></li>
<li>否则，默认初始化（string为””，int块外为0，块内未定义）</li>
</ul>
</li>
<li>C++11中，如果需要默认行为可以在参数列表之后写上 <code>=default</code>要求编译器生成默认构造函数</li>
<li><strong>当某个数据成员被构造函数初始值列表忽略时，它将以合成默认构造函数相同的方式隐式初始化</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有其他构造函数的情况下，还想要默认构造函数可以这样</span></span><br><span class="line">New_Class() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过默认参数也等与实现了默认构造函数</span></span><br><span class="line">New_Class(string s = <span class="string">" "</span>):name(s)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>委托构造函数</strong>就是利用其他构造函数执行自己的初始化过程，其在参数列表初始化位置调用其他构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New_Class() : New_Class(<span class="string">"zhangsan"</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="隐式类类型转换"><a href="#隐式类类型转换" class="headerlink" title="隐式类类型转换"></a>隐式类类型转换</h6><ul>
<li>通过一个实参调用的构造函数定义一条<strong>从构造函数参数类型向类类型隐式转换</strong>的规则</li>
<li>只允许一步类类型转换，隐式转换可能会出错</li>
<li>抑制隐式转换的方法是在构造函数前加上关键字<code>explicit</code></li>
<li>使用<code>static_cast</code>这样的显式转换也能达到转换的效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string lisi = <span class="string">"lisi"</span>;</span><br><span class="line"><span class="function">New_Class <span class="title">zhangsan</span><span class="params">(<span class="string">"zhangsan"</span>)</span></span>;</span><br><span class="line"><span class="comment">// playWith函数的参数类型是New_Class</span></span><br><span class="line">zhangsan.playWith(lisi);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h5><ul>
<li>class和struct定义类时的唯一区别就是默认访问权限</li>
<li>struct默认为public，而class默认为private</li>
</ul>
<h6 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h6><ul>
<li>类中使用<code>friend</code>关键字可以使其他类或者函数成为它的友元</li>
<li>成为友元的类、函数可以访问当前类的非公有成员</li>
<li>友元不是类的成员，不受其所在区域访问控制级别的约束</li>
<li>类内友元函数的声明并非普通意义上的声明，所以在其他地方还得声明一次，即便定义在类内部也还要在外面声明</li>
<li>友元函数也可以定义在类内部，隐式inline</li>
<li><strong>友元关系不存在传递性</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class2</span> </span>&#123;</span><br><span class="line">friend <span class="class"><span class="keyword">class</span> <span class="title">Class1</span></span>;</span><br><span class="line">friend istream &amp; read(istream &amp;is, Class2 &amp; c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h6><ul>
<li>定义在类内部的成员函数自动是<code>inline</code>类型的</li>
<li><strong><code>mutable</code>成员用于不会是const，即使在const成员函数内他也是可以被改变的</strong></li>
<li>返回<code>*this</code>的函数返回的是左值引用（返回类型是引用），返回的是对象本身而不是副本</li>
</ul>
<h6 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h6><ul>
<li>所有成员都是public</li>
<li>没有定义任何构造函数</li>
<li><strong>没有类内初始值</strong></li>
<li>没有基类、没有虚函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct data &#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    string s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h5><ul>
<li>静态成员于类本身直接相关</li>
<li>静态成员函数不包含this指针、也不能显式、隐式地使用this指针（<strong>不能操作非静态成员</strong>）</li>
<li><strong>静态成员函数不能声明成const</strong></li>
<li>在类的外部定义静态成员时，不能重复static关键字</li>
<li>静态成员变量应该在类的外部定义</li>
<li>静态数据成员可以是不完全类型（类在声明之后、定义之前称为不完全类型）</li>
<li>静态成员可以是默认实参，非静态的不可以</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> A a;  <span class="comment">// 正确，静态成员可以使不完全类型</span></span><br><span class="line">    A b;           <span class="comment">// 错误，数据成员必须是完全类型，不过可以定义指针、引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IO库与容器库"><a href="#IO库与容器库" class="headerlink" title="IO库与容器库"></a>IO库与容器库</h4><h5 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h5><p><code>sstream</code>包含三个支持string读写的类型，分别是<code>istringstream</code>、<code>ostringstream</code>和<code>stringstream</code>。<br>sstream的使用可以如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sstream strm;</span><br><span class="line"><span class="function">sstream <span class="title">strm</span><span class="params">(s)</span></span>; <span class="comment">// strm是sstream的对象，保存string s的拷贝</span></span><br><span class="line"></span><br><span class="line">strm.str()           <span class="comment">// 返回strm所保存的string的拷贝</span></span><br><span class="line">strm.str(s)         <span class="comment">// copy string s to strm, return void</span></span><br></pre></td></tr></table></figure></p>
<p><code>istringstream</code>、<code>ostringstream</code>的用法也很简单，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">line</span><span class="params">(<span class="string">"suck my balls"</span>)</span>, word</span>;</span><br><span class="line"><span class="function">istringstream <span class="title">is</span><span class="params">(line)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (is &gt;&gt; word)</span><br><span class="line">    cout &lt;&lt; word &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>向<code>ostringstream</code>对象写入string其实就是将string添加字符。</p>
<h6 id="array"><a href="#array" class="headerlink" title="array"></a>array</h6><ul>
<li>array容器的大小是一定的，其大小也是类型的一部分</li>
<li>array容器与普通数组不同的是，array支持拷贝与赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>&gt; arr;  <span class="comment">// 错误，缺少大小</span></span><br><span class="line">array&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; arr1 <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; arr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; arr1 = arr;  <span class="comment">//正确，类型一定要一致</span></span><br></pre></td></tr></table></figure>
<h6 id="顺序容器的操作"><a href="#顺序容器的操作" class="headerlink" title="顺序容器的操作"></a>顺序容器的操作</h6><pre><code>seq.assign(b,e); // 将seq中的元素替换成迭代器b、e所表示范围中的元素
seq.assign(il);   // 将seq中的元素替换成初始化列表il中的元素，比如il={1,2,3,4}，为值列表
seq.assign(n,t); // 将seq中的元素替换成n个元素t

c.insert(p, t); // 在迭代器p之前添加元素t，返回添加元素的迭代器
c.insert(p, n, t); // 在迭代器p之前添加n个元素t，返回第一个添加的元素的迭代器
c.insert(p, b, e); // 在迭代器p之前添加迭代器b、e之间的元素
c.insert(p, il);
</code></pre><p><strong>向一个vector、string、deque插入元素会使所有的指向容器的迭代器、引用和指针失效</strong></p>
<ul>
<li><code>emplace_front, emplace_back, emplace</code>分别对应<code>push_front, push_back, insert</code></li>
<li>这些函数可以构造元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    person(string nm, <span class="keyword">int</span> ag);</span><br><span class="line">&#125;</span><br><span class="line">c.emplace_front(<span class="string">"zhangsan"</span>, <span class="number">10</span>); <span class="comment">// 插入10岁的zhangsan的元素</span></span><br><span class="line">c.push_front(<span class="string">"zhangsan"</span>, <span class="number">10</span>); <span class="comment">// 错误，没有接受三个参数的push_front版本</span></span><br><span class="line">c.push_front(person(<span class="string">"zhangsan"</span>,<span class="number">10</span>)); <span class="comment">// 正确，先构造对象</span></span><br></pre></td></tr></table></figure>
<p>顺序容器还支持关系运算符，从头向尾比较，比较直观。</p>
<h6 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h6><pre><code>c1.swap(c2);
swap(c1, c2);
</code></pre><ul>
<li>swap交换元素很快，因为元素本身没有交换，swap只是交换了两个容器的内部数据结构</li>
<li>array是个例外，swap真正交换元素，所以交换所需时间与元素数目成正比</li>
</ul>
<h6 id="改变容器大小、容量"><a href="#改变容器大小、容量" class="headerlink" title="改变容器大小、容量"></a>改变容器大小、容量</h6><p><strong>改变size</strong>：size是容器当前大小，采用多退少补的方法</p>
<ul>
<li>函数resize可以改变改变容器大小<code>resize(n)</code>，也可以将新添加的元素设置为t <code>resize(n,t)</code></li>
<li>array不支持</li>
</ul>
<p><strong>改变capacity</strong>：capacity是容器的最大容量</p>
<ul>
<li><code>capacity()</code>获取容量</li>
<li><code>reserve(n)</code>分布至少能容纳n个元素的内存空间</li>
<li><code>shrink_to_fit()</code>将<code>capacity</code>减少为<code>size</code>大小</li>
</ul>
<h6 id="string的搜索操作"><a href="#string的搜索操作" class="headerlink" title="string的搜索操作"></a>string的搜索操作</h6><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find(args)</td>
<td>s中args第一次出现的位置</td>
</tr>
<tr>
<td>s.rfind(args)</td>
<td>s中args最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_of(args)</td>
<td>s中查找args中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td>s.find_last_of(args)</td>
<td>s中查找args中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_not_of(args)</td>
<td>s中查找第一个不在args中的字符</td>
</tr>
<tr>
<td>s.find_last_not_of(args)</td>
<td>s中查找最后一个不在args中的字符</td>
</tr>
</tbody>
</table>
</div>
<p>其中<code>args</code>的形式为包括（pos默认为0）</p>
<pre><code>c, pos ：    pos为开始查找的位置，c是一个字符
s2, pos：    s2是字符串
cp, pos：    cp是指向c风格的字符串的指针（以&#39;\0&#39;结尾）
cp, pos, n： n表示只看前n个字符
</code></pre><p>搜索失败则返回一个名为<code>string::npos</code>的static成员，其值初始化为-1.</p>
<h6 id="string数制转换"><a href="#string数制转换" class="headerlink" title="string数制转换"></a>string数制转换</h6><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_string(val)</td>
<td>任何算术类型向string转换</td>
</tr>
<tr>
<td>stoi(s, p, b)</td>
<td>string转int，s是字符串</td>
</tr>
<tr>
<td>stol(s, p, b)</td>
<td>string转long，b是转换基数（默认为10，十进制）</td>
</tr>
<tr>
<td>stoul(s, p, b)</td>
<td>string转unsigned long，p是起始位置</td>
</tr>
<tr>
<td>stoll(s, p, b)</td>
<td>string转long long</td>
</tr>
<tr>
<td>stoull(s, p, b)</td>
<td>string转unsigned long long</td>
</tr>
<tr>
<td>stof(s, p)</td>
<td>string转float，p是起始位置</td>
</tr>
<tr>
<td>stod(s, p)</td>
<td>string转double</td>
</tr>
<tr>
<td>stold(s, p)</td>
<td>string转long double</td>
</tr>
</tbody>
</table>
</div>
<h5 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h5><p><strong>适配器是一种机制，能使某种事物的行为看起来像另外一种事物</strong><br>标准库中有三个顺序容器适配器，<code>stack、queue、priority_queue</code></p>
<h4 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h4><ul>
<li>泛型算法定义在头文件<code>numeric</code>中</li>
</ul>
<h5 id="几个基本的泛型算法"><a href="#几个基本的泛型算法" class="headerlink" title="几个基本的泛型算法"></a>几个基本的泛型算法</h5><ul>
<li><code>find(iter1, iter2, val);</code> // 元素查找，iter1、iter2迭代器至少查找的范围，val是查找的元素。查找失败返回iter2，否则返回对应的迭代器</li>
<li><code>accumulate(iter1, iter2, sum);</code>  // 元素累加，执行+运算，sum是和的初值，返回最终的和</li>
<li><code>equal(iter1, iter2, another_iter);</code>  //  比较两个序列元素是否完全一致，一致返回true。another_iter表示第二个序列的起始迭代器</li>
<li><code>fill(iter1, iter2, val);</code>  // 将迭代器范围中的每个值置为val</li>
<li><code>fill_n(iter, n, val);</code>  // 将从iter起的n个元素置为val（必须保证有n个元素）</li>
<li><code>copy(iter1, iter2, another_iter);</code>  // 将iter1-iter2范围内的元素拷贝到以another_iter起始的位置上，要求another_iter对应的容器大小不能比iter1对应的容器小，返回another_iter的位置迭代器位置</li>
<li><code>replace(iter1, iter2, val, new_val);</code>  // 迭代器范围内，将所有的val换成 new_val</li>
<li><code>replace_copy(iter1, iter2, new_iter, val, new_val);</code>  // 保持iter1对应的容器不变，将替换后的结果写入new_iter对应的容器中</li>
<li><code>unique(iter1, iter2);</code>  // 去重，返回指向不重复区域之后一个位置的迭代器</li>
</ul>
<h5 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h5><h6 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h6><pre><code>[捕获列表] (参数列表) -&gt; 返回类型 {函数体};
</code></pre><ul>
<li>lambda可以理解成未命名的inline函数</li>
<li>捕获列表：表达式所在函数的局部变量列表，局部变量间以<code>,</code>分隔，通常为空。<code>&amp;</code>引用捕获，<code>=</code></li>
<li>参数列表、返回类型、函数体和普通函数一个意思</li>
<li><strong>参数列表和返回类型可以忽略，但捕获列表和函数体必须存在</strong></li>
<li>lambda表达式的返回值是一个可调用对象，不接收参数，直接带括号调用。可调用对象包括函数、函数指针、lambda表达式等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto f = []&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125; <span class="comment">// f是可调用对象</span></span><br><span class="line">cout &lt;&lt; f() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h6 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h6><ul>
<li>头文件为<code>functional</code></li>
<li>接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表</li>
<li>可以看成一个通用的函数适配器</li>
<li><p>bind在绑定过程中都是采用参数拷贝的方式，所以对于需要引用的类型，可以使用<code>ref</code>、<code>cref</code>函数表示引用（常量c）</p>
<p>  <code>auto newCallable = bind(callable, arg_list);</code></p>
</li>
</ul>
<p><code>arg_list</code>中可能包含<code>_n</code>这样的名字（n是整数），这些是占位符，表示newCallable的参数。<code>_n</code>表示第n个参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f是有5个参数的可调用对象</span></span><br><span class="line">auto g = bind(f, a, b, _2, c, _1);</span><br><span class="line"><span class="comment">// 传递给g的参数会被分别绑定到_1、_2位置上</span></span><br><span class="line"><span class="comment">// g(X, Y) 等价于 f(a, b, Y, c, X)</span></span><br><span class="line"></span><br><span class="line">ostream &amp;print(ostream &amp;os, string &amp;s, <span class="keyword">char</span> c) &#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; s &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line">for_each(words.begin(), words.end(), bind(print, os, _1, <span class="string">' '</span>));  <span class="comment">// 错误，os不能拷贝</span></span><br><span class="line">for_each(words.begin(), words.end(), bind(print, ref(os), _1, <span class="string">' '</span>));  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p>
<h5 id="特殊迭代器"><a href="#特殊迭代器" class="headerlink" title="特殊迭代器"></a>特殊迭代器</h5><h6 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h6><p>包括<code>back_inserter, front_inserter, inserter</code>三种，分别创建使用<code>push_back, push_front, insert</code>的迭代器。<br>使用 <code>inserter(c, iter)</code>时，插入元素位置在iter位置之前，并且插入前后，iter指向的元素不变；但是<code>front_inserter(c)</code>就一直在容器头部插入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; lst2, lst3;</span><br><span class="line"><span class="comment">// 插入后lst2为 4 3 2 1</span></span><br><span class="line">copy(lst.begin(), lst.end(), front_inserter(lst2));</span><br><span class="line"><span class="comment">// 插入后lst3为 1 2 3 4</span></span><br><span class="line">copy(lst.begin(), lst.end(), inserter(lst3, lst3.begin()));</span><br></pre></td></tr></table></figure></p>
<h6 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h6><ul>
<li>使用流迭代器，必须指定读写对象的类型</li>
<li>istream_iterator迭代器要读取的内容必须定义了<code>&gt;&gt;</code>运算符，ostream_iterator迭代器要读取的内容必须定义了<code>&lt;&lt;</code>运算符</li>
<li>默认初始化istream_iterator迭代器，创建一个当作尾后值使用的迭代器</li>
<li>流迭代器不支持递减<code>--</code>操作</li>
<li>istream_iterator迭代器支持<code>++, *, -&gt;, ==,  !=</code>运算符</li>
<li>ostream_iterator迭代器支持<code>++, =,  *</code>运算符</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;T&gt; <span class="title">in</span><span class="params">(is)</span></span>;  <span class="comment">// 迭代器对象in从输入流is中读取类型为T的值</span></span><br><span class="line">istream_iterator&lt;T&gt; eof;     <span class="comment">// 尾后迭代器</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">vec</span><span class="params">(in, eof)</span></span>;  <span class="comment">// 从迭代器范围构造vector对象</span></span><br><span class="line">accumulate(in, eof, <span class="number">0</span>);   <span class="comment">// 求和</span></span><br><span class="line"></span><br><span class="line"><span class="function">ostream_iterator&lt;T&gt; <span class="title">out</span><span class="params">(os)</span></span>;  <span class="comment">// out将类型为T的输出值写入到输出流os中</span></span><br><span class="line"><span class="function">ostream_iterator&lt;T&gt; <span class="title">out</span><span class="params">(os, d)</span></span>;  <span class="comment">// out将类型为T的输出值写入到输出流os中，每个值后面都额外输出一个d（d是C风格的字符串）</span></span><br><span class="line"><span class="keyword">for</span> (anto e : vec)</span><br><span class="line">    *out++ = e;  <span class="comment">// 直接写out=e;也可以，不过不推荐这么写</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">copy(vec.begin(), vec.end(), out);</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h6 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h6><ul>
<li>在容器中从尾元素向首元素反向移动的迭代器</li>
<li>其递增、递减的操作是反过来的，即<code>++</code>会向前移动，前也是相对移动方向的</li>
<li>除了<code>forward_list</code>外都支持，使用<code>rbegin(),crbegin()</code>等</li>
</ul>
<h6 id="链表类容器的特殊方法"><a href="#链表类容器的特殊方法" class="headerlink" title="链表类容器的特殊方法"></a>链表类容器的特殊方法</h6><p><code>list、forward_list</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>lst.merge(lst2)</td>
<td>将lst2中的元素合并入lst，要求lst、lst2都必须有序</td>
</tr>
<tr>
<td>lst.merge(lst2, comp)</td>
<td>comp为特定的比较函数</td>
</tr>
<tr>
<td>lst.remove(val)</td>
<td>调用erase删除lst内与val相等的元素</td>
</tr>
<tr>
<td>lst.remove(pred)</td>
<td>调用erase删除lst内使得一元谓词pred成立的元素</td>
</tr>
<tr>
<td>lst.reverse()</td>
<td>反转lst中元素的顺序</td>
</tr>
<tr>
<td>lst.sort()</td>
<td>排序，可以使用comp</td>
</tr>
<tr>
<td>lst.unique()</td>
<td>调用erase去重</td>
</tr>
<tr>
<td>lst.unique(pred)</td>
<td>调用erase去重，重复指的是满足二元谓词pred的元素</td>
</tr>
</tbody>
</table>
</div>
<p><strong>谓词是返回可以转换为bool类型值的函数。元对应参数个数</strong></p>
<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4><ul>
<li>关联容器支持高效的关键字查询和访问，可以分为有序集合和无序集合两种</li>
<li>map和set的迭代器都不允许修改关键字<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5>| 有序类型 | 说明 |<br>|————|————|<br>|    map    |     关联数组，保存（key, value）对   |<br>|    set      |       只保存关键字      |<br>|multimap|       关键字可重复出现的map|<br>|multiset|      关键字可重复出现的set    |</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>无序类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unordered_map</td>
<td>用哈希函数组织的map</td>
</tr>
<tr>
<td>unordered_set</td>
<td>用哈希函数组织的set</td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>….</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>….</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    vec.push_back(i);</span><br><span class="line">    vec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(vec.cbegin()</span>, vec.<span class="title">cend</span><span class="params">()</span>)</span>;  <span class="comment">// 10个元素</span></span><br><span class="line"><span class="function">multiset&lt;<span class="keyword">int</span>&gt; <span class="title">imset</span><span class="params">(vec.cbegin()</span>, vec.<span class="title">cend</span><span class="params">()</span>)</span>;  <span class="comment">// 20个元素</span></span><br></pre></td></tr></table></figure>
<h5 id="关键字类型要求"><a href="#关键字类型要求" class="headerlink" title="关键字类型要求"></a>关键字类型要求</h5><ul>
<li>有序元素的关键字类型必须定义元素比较的方法</li>
<li>不支持比较的复杂类型需要自定义比较函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compareClass1是进行Class1对象比较的函数，定义时需要添加比较函数的函数指针</span></span><br><span class="line"><span class="comment">// 直接使用compareClass1也行，因为函数名会转化为函数指针</span></span><br><span class="line"><span class="comment">// 构造函数也使用比较函数的函数指针</span></span><br><span class="line">set&lt;Class1, decltype(compareClass1)*&gt; cls(compareClass1);</span><br></pre></td></tr></table></figure>
<h6 id="关联容器额外的类型别名"><a href="#关联容器额外的类型别名" class="headerlink" title="关联容器额外的类型别名"></a>关联容器额外的类型别名</h6><pre><code>key_type : 容器的关键字类型
value_type : 对于set，与key_type相同；map则是pair&lt;key, value&gt;
mapped_type : 关键字关联的类型
</code></pre><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><pre><code>c.insert(v);
c.emplace(args);
c.insert(iter1, iter2);
c.insert(il);  // 花括号列表，返回void
c.insert(iter, v); // 迭代器指示搜索新元素存储应该存储的位置。返回一个迭代器，指向具有给定关键字的元素
c.emplace(iter, args);
</code></pre><p><strong>对于不包含重复关键字的容器，添加单一元素的inert和emplace返回一个pair，指示插入操作是否成功。pair的首元素（first）是一个迭代器，指向具有指定关键字的元素；second是一个bool值，指示元素成功插入还是已经存在于容器中，成功插入为true，否则为false</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto ret = word_count.insert(&#123;<span class="string">"hello"</span>, <span class="number">1</span>&#125;); 尝试插入</span><br><span class="line"><span class="keyword">if</span> (!ret.second) <span class="comment">// 元素已经存在map中</span></span><br><span class="line">    ++ret.first-&gt;second;  <span class="comment">//  ret.first是指向“hello”关键字的迭代器，迭代器指向的second元素是原本"hello"对应的数目，加一即可</span></span><br></pre></td></tr></table></figure></p>
<h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><pre><code>c.find(k);  // 返回指向第一个key为k的迭代器
c.count(k);  // 返回关键字k的个数
c.lower_bound(k); // 返回一个迭代器，指向第一个关键字不小于k的元素
c.upper_bound(k);  // 返回一个迭代器，指向第一个关键字大于k的元素
c.equal_range(k);   //  返回一个迭代器pair，表示关键字等于k的元素的范围。如不存在，则pair的两个成员均为c.end()
</code></pre><p><code>lower_bound</code>和<code>upper_bound</code>只适用于有序容器<br>通过下标访问元素返回左值，既可以读，也可以写回</p>
<h5 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h5><ul>
<li>无序容器在存储上组织为一组桶，每个桶保存0个或多个元素</li>
<li><p>无序容器的性能依赖于哈希函数的质量和桶的大小</p>
<p>  c.bucket_count();  // 正在使用的桶数目<br>  c.max_bucket_count();  // 容器能容纳的最多的桶的数量<br>  c.bucket_size(n);  // 第n个桶中有多少个元素<br>  c.bucket(k);  //  关键字为k的元素在哪个桶中</p>
<p>  local_iterator       // 访问桶中元素的迭代器<br>  const_local_iterator   //  const版本<br>  c.begin(n), c.end(n)   //  桶n元素的首、尾迭代器<br>  c.cbegin(n), c.cend(n)</p>
<p>  c.load_factor();   //  每个桶的平均元素数量，float类型<br>  c.max_load_factor();  // 最大平均桶元素数量，每个桶的平均元素数量大于这个值就需要添加新的桶<br>  c.rehash(n);    //  重组存储，使得bucket_count &gt;= n且bucket_count&gt;size/max_load_factor<br>  c.reserve(n);   //  重组存储，使得c可以保存n个元素且不必rehash</p>
</li>
</ul>
<h6 id="无序容器对关键字的要求"><a href="#无序容器对关键字的要求" class="headerlink" title="无序容器对关键字的要求"></a>无序容器对关键字的要求</h6><ul>
<li>无序容器使用<code>==</code>运算符比较元素</li>
<li>使用<code>hash&lt;key_type&gt;</code>类型的对象生成每个元素的哈希值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_t <span class="title">hasher</span><span class="params">(<span class="keyword">const</span> Class1 &amp; cls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;string&gt;()(cls.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bool <span class="title">eqop</span><span class="params">(<span class="keyword">const</span> Class1 &amp; cls1, <span class="keyword">const</span> Class1 &amp; cls2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cls1.name == cls2.name;</span><br><span class="line">&#125;</span><br><span class="line">using clsset = unordered_set&lt;Class1, hasher, eqop&gt;;</span><br><span class="line"><span class="comment">// 42是桶大小</span></span><br><span class="line"><span class="function">clsset <span class="title">s</span><span class="params">(<span class="number">42</span>, hasher, eqop)</span></span>;</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/02/23/Cpp-Rule-Fragment/" data-id="ckychngoy001q7gphpy8sq9md" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-H-Index" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/02/21/H-Index/">H-Index</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/02/21/H-Index/">
            <time datetime="2017-02-21T12:30:46.000Z" itemprop="datePublished">2017-02-21</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/OJ/">OJ</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/LeetCode/">LeetCode</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="H-Index-I"><a href="#H-Index-I" class="headerlink" title="H-Index I"></a>H-Index I</h5><h6 id="H-Index"><a href="#H-Index" class="headerlink" title="H-Index"></a>H-Index</h6><p>维基百科上H-Index的定义如下</p>
<pre><code>一个科学家的H-Index为h，如果他一共有N篇文章，其中有h篇文章每一篇都至少有h次引用，其他N-h篇论文每一篇都不超过h次引用
</code></pre><p>比如给定<code>citations = [3, 0, 6, 1, 5]</code>，表示当前研究者有5篇论文，其引用为<code>citations</code>中。因为这些论文中有3篇论文每篇都至少有3次引用，其他2篇都没有3次应用，所以他的H-Index为3。</p>
<h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定某个科学家论文引用数目的数组（非负），输出他的H-Index</p>
<h6 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h6><p>首先，一个拥有N篇论文的科学家，他的H-Index不可能会超过N，最大就是N，最小是0。所以如果一篇论文的引用超过N，那么这篇论文的引用在计算H-Index时和N个引用是一样的；如果引用小于N，不妨设置为t，这篇论文只在H-Index小于等于t时有用，如果H-Index大于t，这篇论文不能被计数。</p>
<p>所以，设置一个长度为N+1的辅助数组<code>array</code>，扫描<code>citations</code>数组，对于每个引用t，如果</p>
<ul>
<li>t &lt; N   : array[t]++</li>
<li>t &gt;= N : array[N]++</li>
</ul>
<p>得到数组<code>array</code>数组，从后向前，判断方式为如果$ \sum_{k=i}^{N} array[k] &gt;= i $，那么返回$i$，否则继续向前寻找。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; citations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = citations.size();</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">array</span><span class="params">(N+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (citations[i] &gt; N) array[N]++;</span><br><span class="line">        <span class="keyword">else</span> array[citations[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=N; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        sum += array[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="H-Index-II"><a href="#H-Index-II" class="headerlink" title="H-Index II"></a>H-Index II</h5><h6 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h6><p>在H-Index的基础上，假设给定的<code>citations</code>数据是按升序排序的。求H-Index</p>
<h6 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h6><p>对于第k篇论文，其引用为<code>citations[k]</code>，引用数大于等于<code>citations[k]</code>的论文数量为<code>N-k</code>，所以对应的H-Index为<code>min(N-k, citations[k])</code>。从前向后考虑，开始时始终有<code>citations[k]&lt;N-k</code>，对应的候选H-Index为<code>citations[k]</code>，到后面有<code>citations[k]&gt;N-k</code>，对应的H-Index为<code>N-k</code>。也就是说候选H-Index经历了先增大后减小的过程，转折过程就是<code>citations[k]</code>第一次大于等于<code>N-k</code>的时候。由于H-Index也限制“其他N-h篇论文每一篇都不超过h次引用”，所以我们的目标就是找到第一个<code>citations[k]&gt;=N-k</code>的序号k，因为此时k对应的候选H-Index为<code>N-k</code>，而k-1对应的候选H-Index肯定小于<code>N-k+1</code>，所以k必对应着最优解。</p>
<p>现在有了O(n)复杂度的算法，考虑到引用数据是严格有序的，所以可以使用类似于二分搜索的方法。此时，可以稍微换个角度思考。对于第k篇论文，其引用为<code>citations[k]</code>，如果<code>N-k&gt;=citations[k]</code>，那么<code>citations[k]</code>就是合格的H-Index，此时应该向右尝试寻找更大的H-Index（因为左边的<code>citations</code>小）；如果<code>N-k&lt;citations[k]</code>，那么<code>citations[k]</code>就不是一个当前合法的H-Index（N-k是），所以要向左尝试寻找。</p>
<p>出现<code>N-k=citations[k]</code>直接结束了。否则必然存在k满足<code>citations[k]&lt;N-k &amp;&amp; citations[k+1]&gt;N-k-1</code>，现在考虑<code>k,k+1,left,right</code>最终的可能关系，如下</p>
<pre><code>| k       k+1    |            k     k+1 |  k    k+1            |  k   k+1                   |                   k    k+1  |
| left     right | left    right        |       left     right |              left    right |  left    right               |
后面两种情况不可能出现，前三种情况的最终结果都是 `N-left`
</code></pre><p>再来考虑停止条件，两种情况<code>left=right</code>或者<code>left+1=right</code>。</p>
<ol>
<li>当第一种情况出现，<code>mid=left</code>，此时如果<code>citations[mid] &gt; N-mid</code>，那么<code>mid=left</code>就是最佳位置，H-Index为<code>N-mid</code>；否则最佳位置在left后一位，此时将<code>left=mid+1</code>后，<code>N-left</code>就是最佳H-Index。</li>
<li>当第二种情况出现，<code>left+1=right</code>，<code>mid=left</code>，此时如果<code>citations[mid] &gt; N-mid</code>，那么<code>mid=left</code>就是最佳位置，H-Index为<code>N-mid</code>；否则，设置<code>left=mid+1</code>，回到了第一种情况。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=citations.size(), left=<span class="number">0</span>, right=N-<span class="number">1</span>, ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (citations[mid] == N-mid) <span class="keyword">return</span> N-mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (citations[mid] &gt; N-mid) right = mid-<span class="number">1</span>; <span class="comment">// 向左寻找</span></span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;                                     <span class="comment">// 向右寻找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> N-left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/02/21/H-Index/" data-id="ckychngr700457gphzq4n2xgt" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Partition" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/02/21/Partition/">Partition</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/02/21/Partition/">
            <time datetime="2017-02-21T05:38:18.000Z" itemprop="datePublished">2017-02-21</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/OJ/">OJ</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/LeetCode/">LeetCode</a>, <a class="tag-link" href="/tags/Sort/">Sort</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="partition函数"><a href="#partition函数" class="headerlink" title="partition函数"></a>partition函数</h5><p><code>partition</code>函数是快速排序的核心部分，选定一个基准，然后将大于和小于基准的数分别放置于基准的两边，有多种实现方式，以下是参考</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start, end表明作用范围</span></span><br><span class="line"><span class="comment">// pivotIndex表示基准的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; A, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start, j = end;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = rand() % (end-start+<span class="number">1</span>) + start; <span class="comment">// 随机选择基准位置</span></span><br><span class="line">    <span class="keyword">int</span> pivot = A[pivotIndex];</span><br><span class="line">    <span class="comment">// 把基准换到最后</span></span><br><span class="line">    swap&lt;<span class="keyword">int</span>&gt;(A[end], A[pivotIndex]);</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; A[i] &lt; pivot) ++i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; A[j] &gt;= pivot) --j;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) swap&lt;<span class="keyword">int</span>&gt;(A[i], A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap&lt;<span class="keyword">int</span>&gt;(A[end], A[i]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再提供另一种实现方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr[]为数组，start、end分别为数组第一个元素和最后一个元素的索引</span></span><br><span class="line"><span class="comment">// povitIndex为数组中任意选中的数的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> pivotIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[pivotIndex];</span><br><span class="line">    swap(arr[pivotIndex], arr[end]);</span><br><span class="line">    <span class="keyword">int</span> storeIndex = start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; end; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; pivot) &#123;</span><br><span class="line">            swap(arr[i], arr[storeIndex]);</span><br><span class="line">            ++storeIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[storeIndex], arr[end]);</span><br><span class="line">    <span class="keyword">return</span> storeIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Partition函数的应用"><a href="#Partition函数的应用" class="headerlink" title="Partition函数的应用"></a>Partition函数的应用</h5><h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = partition(A, start, end);</span><br><span class="line">    <span class="keyword">if</span> (mid-start &gt; <span class="number">2</span>) quick_sort(A, start, mid-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (end-mid &gt; <span class="number">2</span>) quick_sort(A, mid+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h6><p>给定未排序数组A，求排好序的数组中的第k个大个数。因为上面的<code>partition</code>函数是左小右大，所以我们考虑寻找第<code>A.size()-k</code>小的数。<br>思路是<strong>调用partition函数，返回基准位置，如果基准位置正好是k，那么返回其对应的值<br>否则，如果基准在k左侧，则考虑基准右边的元素；否则考虑左边的元素。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, end=A.size()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(A, start, end);</span><br><span class="line">        <span class="keyword">if</span> (mid == k-<span class="number">1</span>) <span class="keyword">return</span> A[k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; k-<span class="number">1</span>) start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> end = mid-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/02/21/Partition/" data-id="ckychngu4007i7gpho3w0pndu" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Sliding-Window-Maximum" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/02/16/Sliding-Window-Maximum/">Sliding Window Maximum</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/02/16/Sliding-Window-Maximum/">
            <time datetime="2017-02-16T07:31:45.000Z" itemprop="datePublished">2017-02-16</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/OJ/">OJ</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Sliding-window/">Sliding window</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定数组<code>nums</code>，和滑动窗口的长度<code>k</code>，输出滑动窗口一次一个元素地向前滑动时每一时刻滑动窗口内的最大值。要求在<code>O(n)</code>复杂度内完成。</p>
<pre><code>nums = [1,3,-1,-3,5,3,6,7],  k = 3
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
---------------               -----
output [3,3,5,5,6,7]
</code></pre><h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>滑动窗口内添加新元素简单，但是删除时比较麻烦，所以简单使用堆的思路不行。</p>
<p>双端队列对滑动窗口有比较好的模拟，其尾部、头部都可以添加和删除元素（也有受限的应用版本）。</p>
<p>本题使用的方法也称作<strong>单调队列</strong>，其定义如下：</p>
<pre><code>队列中元素之间的关系具有单调性，而且，队首和队尾都可以进行出队操作，只有队尾可以进行入队操作
</code></pre><p>以单调不减队列为例，队列内的元素$(e_1,e_2,…,e_n)$存在$(e_1\le e_2\le…\le e_n)$的关系，所以队首元素$e_1$一定是最小的元素。与优先队列不同的是，<strong>当有一个新的元素$e$入队时，先要将队尾的所有大于$e$的元素弹出，以保证单调性，再让元素$e$入队尾</strong>。</p>
<p>所以本题的方法描述如下：</p>
<ul>
<li>队列元素如果超过了k的限制，那么从队头剔除</li>
<li>从队尾起，如果队尾的元素小于当前需要添加的元素，那么剔除队尾元素（它不可能成为最大值），直到队尾元素大于等于当前需要添加的元素。</li>
<li>此时，队列是非递减队列，所以队头元素就是最大值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">if</span> (nums.size()&lt;<span class="number">1</span> || k&lt;=<span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!window.empty() &amp;&amp; window.front()&lt;i-k+<span class="number">1</span>)</span><br><span class="line">            window.pop_front();</span><br><span class="line">        <span class="keyword">while</span> (!window.empty() &amp;&amp; nums[window.back()]&lt;nums[i])</span><br><span class="line">            window.pop_back();</span><br><span class="line">        window.push_back(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k-<span class="number">1</span>) ret.push_back(nums[window.front()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/02/16/Sliding-Window-Maximum/" data-id="ckychngvh009b7gph757cj6xe" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Java-Future" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/01/18/Java-Future/">Java Future</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/01/18/Java-Future/">
            <time datetime="2017-01-18T02:25:54.000Z" itemprop="datePublished">2017-01-18</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Dev/">Dev</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Java/">Java</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="Callable与Runnable"><a href="#Callable与Runnable" class="headerlink" title="Callable与Runnable"></a>Callable与Runnable</h6><p>Java中的多线程实现可以通过继承<code>Thread</code>或者实现<code>Runnable</code>接口来实现，但是这两种方法都不能将执行结果取回。<code>Runnable</code>接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>run()</code>方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p>
<p><code>Callable</code>位于java.util.concurrent包下，它也是一个泛型接口，在它里面也只声明了一个方法<code>call()</code>，返回的类型就是传递进来的<code>V</code>类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Callable</code>一般情况下是配合<code>ExecutorService</code>来使用的，在<code>ExecutorService</code>接口中声明了若干个<code>submit</code>方法的重载版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure></p>
<p>这三个方法中，常用的是第一个和第三个。</p>
<hr>
<h6 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h6><p><code>Future</code>是一个接口，位于<code>java.util.concurrent</code>包下，定义如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过<code>get</code>方法获取执行结果，此方法会阻塞直到任务返回结果。上述方法中：</p>
<hr>
<p>1 <code>cancel</code>方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数<code>mayInterruptIfRunning</code>表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论<code>mayInterruptIfRunning</code>为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若<code>mayInterruptIfRunning</code>设置为true，则返回true，若<code>mayInterruptIfRunning</code>设置为false，则返回false；如果任务还没有执行，则无论<code>mayInterruptIfRunning</code>为true还是false，肯定返回true</p>
<p>2 <code>isCancelled</code>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true</p>
<p>3 <code>isDone</code>方法表示任务是否已经完成，若任务完成，则返回true</p>
<p>4 <code>get()</code>方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回</p>
<p>5 <code>get(long timeout, TimeUnit unit)</code>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null</p>
<hr>
<h6 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h6><p>由于<code>Future</code>是个接口，所以其不能实例化，<code>FutureTask</code>应运而生，也是<code>Future</code>接口的唯一实现类。</p>
<p>FutureTask类实现了RunnableFuture接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>RunnableFuture</code>继承了<code>Runnable</code>接口和<code>Future</code>接口，而<code>FutureTask</code>实现了<code>RunnableFuture</code>接口，关系如图所示。所以它既可以作为<code>Runnable</code>被线程执行，又可以作为<code>Future</code>得到<code>Callable</code>的返回值。</p>
<center>![关系图](http://wx1.sinaimg.cn/mw690/9bcfe727ly1fbumuzrzbaj20hz0dhq31.jpg)</center>

<p>FutureTask提供了2个构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h6><p>使用<code>Callable + Future</code>获取执行结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">Task task = <span class="keyword">new</span> Task();</span><br><span class="line">Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">executor.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"task运行结果"</span>+result.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>使用<code>Callable + FutureTask</code>获取执行结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">Task task = <span class="keyword">new</span> Task();</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line"></span><br><span class="line">executor.submit(futureTask);</span><br><span class="line">executor.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"task运行结果"</span>+futureTask.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/01/18/Java-Future/" data-id="ckychngrt004w7gphy3jfnpa8" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Java-Thread-Pool" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/01/17/Java-Thread-Pool/">Java Thread Pool</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/01/17/Java-Thread-Pool/">
            <time datetime="2017-01-17T06:43:08.000Z" itemprop="datePublished">2017-01-17</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Dev/">Dev</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Java/">Java</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><hr>
<h6 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h6><p><code>java.uitl.concurrent.ThreadPoolExecutor</code>类是线程池中最核心的一个类，继承自<code>AbstractExecutorService</code>，<code>AbstractExecutorService</code>是一个抽象类，它实现了ExecutorService接口。<code>ThreadPoolExecutor</code>的构造方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面三个构造器都是调用的第四个构造器进行的初始化工作，参数介绍如下：</p>
<hr>
<p>1 <code>corePoolSize</code> : 核心池的大小。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中。（正式工）<br>2 <code>maximumPoolSize</code> : 线程池最大线程数，表示在线程池中最多能创建多少个线程。最大线程数意味着当核心池不够用时可以额外开辟新线程，但这些新加入的线程在空闲时可以销毁（临时工）。<br>3 <code>keepAliveTime</code> : 线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于<code>corePoolSize</code>时，<code>keepAliveTime</code>才会起作用，直到线程池中的线程数不大于<code>corePoolSize</code>，即当线程池中的线程数大于<code>corePoolSize</code>时，如果一个线程空闲的时间达到<code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过<code>corePoolSize</code>。但是如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，在线程池中的线程数不大于<code>corePoolSize</code>时，<code>keepAliveTime</code>参数也会起作用，直到线程池中的线程数为0。<br>4 <code>unit</code> : <code>keepAliveTime</code>的时间单位. 包括</p>
<pre><code>TimeUnit.DAYS
TimeUnit.HOURS
TimeUnit.MINUTES
TimeUnit.SECONDS
TimeUnit.MILLISECONDS
TimeUnit.MICROSECONDS
TimeUnit.NANOSECONDS
</code></pre><p>5 <code>workQueue</code> : 一个阻塞队列，用来存储等待执行的任务。可以是如下三种，其中<code>ArrayBlockingQueue</code>和<code>PriorityBlockingQueue</code>使用较少，一般使用<code>LinkedBlockingQueue</code>和<code>Synchronous</code>。线程池的排队策略与BlockingQueue有关。</p>
<pre><code>ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小
LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE
SynchronousQueue：不会保存提交的任务，而是将直接新建一个线程来执行新来的任务
PriorityBlockingQueue
</code></pre><p>6 <code>threadFactory</code> ：线程工厂，主要用来创建线程<br>7 <code>handler</code> ：表示当拒绝处理任务时的策略，可以是</p>
<pre><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
</code></pre><hr>
<h6 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h6><p><code>Executor</code>是一个顶层接口，在它里面只声明了一个方法<code>execute(Runnable)</code>，返回值为void，参数为<code>Runnable</code>类型，从字面意思可以理解，就是用来执行传进去的任务的。</p>
<p><code>ExecutorService</code>接口继承了<code>Executor</code>接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等。</p>
<p>抽象类<code>AbstractExecutorService</code>实现了<code>ExecutorService</code>接口，基本实现了<code>ExecutorService</code>中声明的所有方法。</p>
<p><code>ThreadPoolExecutor</code>继承了类<code>AbstractExecutorService</code>。在<code>ThreadPoolExecutor</code>类中有几个非常重要的方法：</p>
<hr>
<p>1 <code>execute()</code> : <code>execute()</code>方法实际上是<code>Executor</code>中声明的方法，在<code>ThreadPoolExecutor</code>进行了具体的实现，这个方法是<code>ThreadPoolExecutor</code>的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p>
<p>2 <code>submit()</code> : <code>submit()</code>方法是在<code>ExecutorService</code>中声明的方法，在<code>AbstractExecutorService</code>就已经有了具体的实现，在<code>ThreadPoolExecutor</code>中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和<code>execute()</code>方法不同，它能够返回任务执行的结果(<code>Future</code>)</p>
<p>3 <code>shutdown()</code> : 关闭线程池，不再接受新的任务，等到所有线程完成任务关闭线程池</p>
<p>4 <code>shutdownNow()</code> : 立即结束所有线程，关闭线程池</p>
<hr>
<h5 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h5><hr>
<h6 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h6><p><code>ThreadPoolExecutor</code>中定义了一个<code>volatile</code>变量<code>volatile int runState</code>表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性。还有几个<code>static final</code>变量表示<code>runState</code>可能的几个取值：</p>
<pre><code>static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
</code></pre><p>创建线程池后，初始时，线程池处于<code>RUNNING</code>状态。<br>调用了<code>shutdown()</code>方法，则线程池处于<code>SHUTDOWN</code>状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕。<br>调用了<code>shutdownNow()</code>方法，则线程池处于<code>STOP</code>状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务。<br>当线程池处于<code>SHUTDOWN</code>或<code>STOP</code>状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<code>TERMINATED</code>状态。</p>
<hr>
<h6 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h6><p><code>ThreadPoolExecutor</code>类中其他的一些比较重要成员变量如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;  <span class="comment">//任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//线程池的主要状态锁，对线程池状态（比如线程池大小、runState等）的改变都要使用这个锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();  <span class="comment">//用来存放工作集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>  keepAliveTime;    <span class="comment">//线程存货时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   corePoolSize;     <span class="comment">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   maximumPoolSize;   <span class="comment">//线程池最大能容忍的线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   poolSize;       <span class="comment">//线程池中当前的线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler; <span class="comment">//任务拒绝策略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;   <span class="comment">//线程工厂，用来创建线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;   <span class="comment">//用来记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   <span class="comment">//用来记录已经执行完毕的任务个数</span></span><br></pre></td></tr></table></figure></p>
<p>任务提交执行依靠<code>execute()</code>方法，<code>submit()</code>也是提交任务的方法，但是它也是调用了<code>execute()</code>方法。<code>execute()</code>方法处理方法的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，判断提交的任务<code>command</code>是否为<code>null</code>，若是<code>null</code>，则抛出空指针异常。接着还是一个判断语句，如果线程池中当前线程数不小于核心池大小，直接执行判断语句中的代码；否则执行<code>addIfUnderCorePoolSize(command)</code>，如果返回false，则继续执行判断语句中的代码，否则整个方法就直接执行完毕了。</p>
<p>第二层判断语句中，如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列(<code>workQueue.offer(command)</code>就是将任务放入缓存队列)；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行<code>addIfUnderMaximumPoolSize(command)</code>，如果执行<code>addIfUnderMaximumPoolSize</code>方法失败，则执行<code>reject()</code>方法进行任务拒绝处理。</p>
<p>如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续执行第三层判断语句<code>if (runState != RUNNING || poolSize == 0)</code>，这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用<code>shutdown</code>或者<code>shutdownNow</code>方法关闭了线程池的一种应急措施，如果是这样就需要应急处理<code>ensureQueuedTaskHandled(command)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderCorePoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);        <span class="comment">//创建线程去执行firstTask任务</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到的<code>addIfUnderCorePoolSize</code>方法，由字面意思是当低于核心池大小时执行的方法，因为涉及线程池的变化，所以需要加锁。if语句判断当前线程池中的线程数目是否小于核心池大小，虽然前面在<code>execute()</code>方法中已经判断过了，但是没有加锁。因此可能在<code>execute</code>方法判断的时候<code>poolSize</code>小于<code>corePoolSize</code>，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致<code>poolSize</code>不小于<code>corePoolSize</code>了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Thread <span class="title">addThread</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">    Worker w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    Thread t = threadFactory.newThread(w);  <span class="comment">//创建一个线程，执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        w.thread = t;            <span class="comment">//将创建的线程的引用赋值为w的成员变量</span></span><br><span class="line">        workers.add(w);</span><br><span class="line">        <span class="keyword">int</span> nt = ++poolSize;     <span class="comment">//当前线程数加1</span></span><br><span class="line">        <span class="keyword">if</span> (nt &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = nt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>runState</code>的判断也是类似的。满足条件的话，通过<code>addThread</code>方法创建线程，创建成功则启动线程。在<code>addThread</code>方法中，首先用提交的任务创建了一个<code>Worker</code>对象，然后调用线程工厂<code>threadFactory</code>创建了一个新的线程<code>t</code>，然后将线程<code>t</code>的引用赋值给了<code>Worker</code>对象的成员变量<code>thread</code>，接着通过<code>workers.add(w)</code>将<code>Worker</code>对象添加到工作集当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runTask(task);</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Worker</code>类实现了<code>Runnable</code>接口，在其<code>run</code>函数中首先执行的是通过构造器传进来的任务<code>firstTask</code>，在调用<code>runTask()</code>执行完<code>firstTask</code>之后，在<code>while</code>循环里面不断通过<code>getTask()</code>去取新的任务来执行，<code>getTask</code>是<code>ThreadPoolExecutor</code>类中的方法，从任务缓存队列中取。</p>
<p>任务提交后，线程池的处理策略总结如下：</p>
<ul>
<li>如果当前线程池中的线程数目小于<code>corePoolSize</code>，则每来一个任务，就会创建一个线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目&gt;=<code>corePoolSize</code>，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目达到<code>maximumPoolSize</code>，则会采取任务拒绝策略进行处理；</li>
<li>如果线程池中的线程数量大于<code>corePoolSize</code>时，如果某线程空闲时间超过<code>keepAliveTime</code>，线程将被终止，直至线程池中的线程数目不大于<code>corePoolSize</code>；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过<code>keepAliveTime</code>，线程也会被终止。</li>
</ul>
<hr>
<h6 id="线程初始化"><a href="#线程初始化" class="headerlink" title="线程初始化"></a>线程初始化</h6><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个核心线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addIfUnderCorePoolSize(<span class="keyword">null</span>); <span class="comment">//注意传进去的参数是null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化所有核心线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addIfUnderCorePoolSize(<span class="keyword">null</span>))<span class="comment">//注意传进去的参数是null</span></span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面传入参数为null，最后执行线程会阻塞在<code>getTask</code>方法中的<code>workQueue.take()</code>，等待直到任务队列中有任务。</p>
<hr>
<h6 id="容量的动态调整"><a href="#容量的动态调整" class="headerlink" title="容量的动态调整"></a>容量的动态调整</h6><pre><code>setCorePoolSize：设置核心池大小
setMaximumPoolSize：设置线程池最大能创建的线程数目大小
</code></pre><hr>
<h5 id="线程池应用"><a href="#线程池应用" class="headerlink" title="线程池应用"></a>线程池应用</h5><hr>
<h6 id="ThreadPoolExecutor-1"><a href="#ThreadPoolExecutor-1" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存任务队列大小为8，核心池大小为5</span></span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">8</span>));</span><br><span class="line">executor.execute(myTask);</span><br><span class="line"><span class="comment">// myTask 应该是显示了Runnable的类的对象</span></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="推荐实现"><a href="#推荐实现" class="headerlink" title="推荐实现"></a>推荐实现</h6><p>Java官方不推荐直接使用<code>ThreadPoolExecutor</code>，而是使用<code>Executors</code>类中提供的几个静态方法来创建线程池。分别是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool();        <span class="comment">//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span></span><br><span class="line">Executors.newSingleThreadExecutor();   <span class="comment">//创建容量为1的缓冲池</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="keyword">int</span>);    <span class="comment">//创建固定容量大小的缓冲池</span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="keyword">int</span>); <span class="comment">//创建固定容量的延迟连接池</span></span><br></pre></td></tr></table></figure></p>
<p>这三种方法也都是调用了<code>ThreadPoolExecutor</code>，支持参数设定不同而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">pool.execute(t1);</span><br><span class="line">pool.execute(t2);</span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line">ExecutorService pool = Executors.newSingleThreadExecutor();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">pool.execute(t1);</span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">pool.execute(t1);</span><br><span class="line">pool.execute(t2);</span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t3 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">pool.execute(t1);</span><br><span class="line"></span><br><span class="line">pool.schedule(t2, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">pool.schedule(t3, <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>
<p><code>newFixedThreadPool</code>创建的线程池<code>corePoolSize</code>和<code>maximumPoolSize</code>值是相等的，它使用的<code>LinkedBlockingQueue</code>；</p>
<p><code>newSingleThreadExecutor</code>将<code>corePoolSize</code>和<code>maximumPoolSize</code>都设置为1，也使用的<code>LinkedBlockingQueue</code>；</p>
<p><code>newCachedThreadPool</code>将<code>corePoolSize</code>设置为0，将<code>maximumPoolSize</code>设置为<code>Integer.MAX_VALUE</code>，使用的<code>SynchronousQueue</code>，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p>
<hr>
<p>感谢<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">原文</a></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/01/17/Java-Thread-Pool/" data-id="ckychngro004t7gphwaw73tph" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/4/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/6/">下一页 &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/01/31/DeepFM/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2021/01/31/DeepFM/" class="title">DeepFM</a></p>
                            <p class="item-date"><time datetime="2021-01-31T09:35:23.000Z" itemprop="datePublished">2021-01-31</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/01/02/Monotonous-Sequence/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/OJ/">OJ</a></p>
                            <p class="item-title"><a href="/2021/01/02/Monotonous-Sequence/" class="title">Monotonous Sequence</a></p>
                            <p class="item-date"><time datetime="2021-01-02T08:12:40.000Z" itemprop="datePublished">2021-01-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2021/01/02/Factorization-Machines/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2021/01/02/Factorization-Machines/" class="title">Factorization Machines</a></p>
                            <p class="item-date"><time datetime="2021-01-02T07:49:44.000Z" itemprop="datePublished">2021-01-02</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/09/01/Python-Functions/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Dev/">Dev</a></p>
                            <p class="item-title"><a href="/2020/09/01/Python-Functions/" class="title">Python Functions</a></p>
                            <p class="item-date"><time datetime="2020-09-01T15:15:14.000Z" itemprop="datePublished">2020-09-01</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/09/01/Bounds-in-Binary-Search/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/OJ/">OJ</a></p>
                            <p class="item-title"><a href="/2020/09/01/Bounds-in-Binary-Search/" class="title">Bounds in Binary Search</a></p>
                            <p class="item-date"><time datetime="2020-09-01T15:12:12.000Z" itemprop="datePublished">2020-09-01</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">52</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/">Dev</a><span class="category-list-count">21</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OJ/">OJ</a><span class="category-list-count">57</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">35</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">8</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Backtracking/" style="font-size: 11.11px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 12.22px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 16.67px;">Binary Tree</a> <a href="/tags/Cpp/" style="font-size: 15.56px;">Cpp</a> <a href="/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/tags/DP/" style="font-size: 16.67px;">DP</a> <a href="/tags/Deep-Learning/" style="font-size: 10px;">Deep Learning</a> <a href="/tags/Divide-Conquer/" style="font-size: 10px;">Divide & Conquer</a> <a href="/tags/Game-Theory/" style="font-size: 10px;">Game Theory</a> <a href="/tags/Geometry/" style="font-size: 10px;">Geometry</a> <a href="/tags/Graph/" style="font-size: 11.11px;">Graph</a> <a href="/tags/Greedy/" style="font-size: 13.33px;">Greedy</a> <a href="/tags/IPython/" style="font-size: 10px;">IPython</a> <a href="/tags/IR/" style="font-size: 11.11px;">IR</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 20px;">LeetCode</a> <a href="/tags/Leetcode/" style="font-size: 11.11px;">Leetcode</a> <a href="/tags/MIR/" style="font-size: 10px;">MIR</a> <a href="/tags/Machine-Learning/" style="font-size: 10px;">Machine Learning</a> <a href="/tags/Math/" style="font-size: 12.22px;">Math</a> <a href="/tags/Matlab/" style="font-size: 10px;">Matlab</a> <a href="/tags/NLP/" style="font-size: 14.44px;">NLP</a> <a href="/tags/Optimization/" style="font-size: 10px;">Optimization</a> <a href="/tags/POJ/" style="font-size: 11.11px;">POJ</a> <a href="/tags/Permutation/" style="font-size: 10px;">Permutation</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/Sliding-window/" style="font-size: 14.44px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.11px;">Sort</a> <a href="/tags/State-Machine/" style="font-size: 10px;">State Machine</a> <a href="/tags/String/" style="font-size: 14.44px;">String</a> <a href="/tags/Tree/" style="font-size: 10px;">Tree</a> <a href="/tags/bit/" style="font-size: 10px;">bit</a> <a href="/tags/deep-learning/" style="font-size: 16.67px;">deep learning</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/machine-learning/" style="font-size: 18.89px;">machine learning</a> <a href="/tags/numpy/" style="font-size: 11.11px;">numpy</a> <a href="/tags/other/" style="font-size: 10px;">other</a> <a href="/tags/pandas/" style="font-size: 11.11px;">pandas</a> <a href="/tags/prime/" style="font-size: 10px;">prime</a> <a href="/tags/python/" style="font-size: 17.78px;">python</a> <a href="/tags/random-algorithm/" style="font-size: 12.22px;">random algorithm</a> <a href="/tags/recommendation/" style="font-size: 11.11px;">recommendation</a> <a href="/tags/recommender-system/" style="font-size: 10px;">recommender system</a> <a href="/tags/time-series-data/" style="font-size: 10px;">time_series_data</a> <a href="/tags/visualization/" style="font-size: 10px;">visualization</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/数据分析/" style="font-size: 10px;">数据分析</a> <a href="/tags/文件/" style="font-size: 10px;">文件</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="https://xueshu.glgoo.org/">Google Scholar Mirror</a>
                    </li>
                
                    <li>
                        <a href="https://www.kaggle.com/">Kaggle</a>
                    </li>
                
                    <li>
                        <a href="http://mlr.cs.umass.edu/ml/datasets.html">UCI dataset</a>
                    </li>
                
                    <li>
                        <a href="https://leetcode.com/problemset/algorithms/">LeetCode</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fas fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2022 曹文强<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        </div>
    </div>
</footer>
        


    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>