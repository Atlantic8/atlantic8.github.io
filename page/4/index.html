<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    <title>atlantic8</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="A note is preferable to the best memory">
<meta property="og:type" content="website">
<meta property="og:title" content="atlantic8">
<meta property="og:url" content="atlantic8.github.io/page/4/index.html">
<meta property="og:site_name" content="atlantic8">
<meta property="og:description" content="A note is preferable to the best memory">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="atlantic8">
<meta name="twitter:description" content="A note is preferable to the best memory">
    

    

    
        <link rel="icon" href="/css/images/logo.png">
    

    <link rel="stylesheet" href="/libs/font-awesome5/css/fontawesome.min.css">
    <link rel="stylesheet" href="/libs/font-awesome5/css/fa-brands.min.css">
    <link rel="stylesheet" href="/libs/font-awesome5/css/fa-solid.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?ff86ad40748d96af89d192e9b0a3ae62";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    


</head>
</html>
<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">atlantic8</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories/OJ">OJ</a>
                
                    <a class="main-nav-link" href="/categories/Algorithm">Algorithm</a>
                
                    <a class="main-nav-link" href="/categories/Math">Math</a>
                
                    <a class="main-nav-link" href="/categories/Dev">Dev</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/me.png" />
                            <i class="fas fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fas fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories/OJ">OJ</a></td>
                
                    <td><a class="main-nav-link" href="/categories/Algorithm">Algorithm</a></td>
                
                    <td><a class="main-nav-link" href="/categories/Math">Math</a></td>
                
                    <td><a class="main-nav-link" href="/categories/Dev">Dev</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/me.png" />
            <h2 id="name">Atlantic8</h2>
            <h3 id="title">algorithm engineer</h3>
            <span id="location"><i class="fas fa-map-marker-alt" style="padding-right: 5px"></i>Beijing, China</span>
            <a id="follow" target="_blank" href="https://github.com/Atlantic8">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                124
                <span>文章</span>
            </div>
            <div class="article-info-block">
                46
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/Atlantic8" target="_blank" title="github" class=tooltip>
                            
                                <i class="fab fa-github"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://www.linkedin.com/in/wenqiang-cao-704236b8/" target="_blank" title="linkedin" class=tooltip>
                            
                                <i class="fab fa-linkedin"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="mailto:atlantic8@outlook.com" target="_blank" title="envelope" class=tooltip>
                            
                                <i class="fas fa-envelope"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="http://weibo.com/2614093607" target="_blank" title="weibo" class=tooltip>
                            
                                <i class="fab fa-weibo"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="facebook" class=tooltip>
                            
                                <i class="fab fa-facebook"></i>
                            
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-BM" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/04/BM/">BM</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/04/BM/">
            <time datetime="2017-03-04T12:33:18.000Z" itemprop="datePublished">2017-03-04</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/String/">String</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="BM介绍"><a href="#BM介绍" class="headerlink" title="BM介绍"></a>BM介绍</h6><p>KMP算法是一种利用模式串前缀移动的字符串匹配算法，时间复杂度为<code>O(n)</code>。<br>BM算法是一种使用了两个跳转表的字符串匹配算法，单模式匹配有更加出色的表现。</p>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fdb3b45fkbj216t0d8753" alt=""></p>
<p>上图表述了BM算法的大致过程，模式串是<code>AT-THAT</code>，于KMP不同，BM算法<strong>对每一次匹配尝试从后向前匹配的方法</strong>。</p>
<ol>
<li><p>第一次匹配从第7位开始。第7为不能匹配，移动模式串，注意到目标串第7为为<code>F</code>，<code>F</code>不在模式串中，所以可以直接将模式串的首位移到目标串第8位。</p>
</li>
<li><p>接着从后向前匹配，目标串的14位<code>-</code>与模式串最后一位不匹配，但是<code>-</code>在模式串中，所以将模式串中最靠后的<code>-</code>移到与目标串的14位对齐。</p>
</li>
<li><p>再从后向前匹配，目标串的第18位<code>T</code>与模式串的最后一位匹配，向前看一位，17位<code>L</code>不匹配，且<code>L</code>不在模式串中，所以把模式串第一位移到目标串第18位。</p>
</li>
<li><p>接着从后向前匹配，第23、24位匹配，22位不匹配，由于模式串的前两位等于后两位，所以将模式串移动使其前两位到后两位的位置上。</p>
</li>
</ol>
<h6 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h6><p>假设目标串T长度为n，模式串P长度为m</p>
<p>坏字符规则分为两种情况：</p>
<ul>
<li>坏字符没出现在模式串中，这时可以把模式串首移动到坏字符的下一个字符</li>
<li>坏字符出现在模式串中，这时可以<strong>把模式串第一个出现的坏字符和母串的坏字符对齐</strong>（当然，这样可能造成模式串倒退移动）</li>
</ul>
<p>使用一个数组<code>bad</code>，<code>bad[&#39;k&#39;]</code>表示坏字符在模式串中最左侧的字符<code>&#39;k&#39;</code>距离模式串末尾的长度，如果字符’k’不在模式串中，<code>bad[&#39;k&#39;]=m</code>。那么遇到坏字符时模式串可以移动的距离为：<code>bad[T[i]]-(m-1-i)</code>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// m为模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_bad</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* P, <span class="keyword">int</span> m, <span class="keyword">int</span>* bad)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">256</span>; i++)</span><br><span class="line">         bad[i] = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++)</span><br><span class="line">        bad[P[i]] = m-i-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h6><p>发现某个字符不匹配的同时，已有部分字符匹配成功。假设模式串P已经匹配成功的部分为Q</p>
<ul>
<li>模式串中有子串匹配上好后缀，此时移动模式串，让该子串和好后缀对齐即可，如果超过一个子串匹配上好后缀，则选择最靠左边的子串对齐</li>
<li>模式串中没有子串匹配上好后缀，此时需要寻找模式串的一个最长前缀，并让该前缀等于好后缀的后缀，寻找到该前缀后，让该前缀和好后缀对齐即可</li>
<li>模式串中没有子串匹配上后后缀，并且在模式串中找不到最长前缀，让该前缀等于好后缀的后缀。此时，直接移动模式到好后缀的下一个字符</li>
</ul>
<p>为了实现好后缀规则，需要定义一个数组<code>suffix[]</code>，其中<code>suffix[i] = s</code> 表示以<code>i</code>为右边界，与模式串后缀匹配的最大长度为<code>s</code>，即<code>P[i-s:s]==P[m-s:m]</code>，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">suffixes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *P, <span class="keyword">int</span> m, <span class="keyword">int</span> *suff)</span> </span>&#123;</span><br><span class="line">    suff[m-<span class="number">1</span>]=m;</span><br><span class="line">        <span class="keyword">for</span> (i=m-<span class="number">2</span>；i&gt;=<span class="number">0</span>；--i)&#123;</span><br><span class="line">            q=i;</span><br><span class="line">            <span class="keyword">while</span>(q&gt;=<span class="number">0</span>&amp;&amp;P[q]==P[m-<span class="number">1</span>-i+q])</span><br><span class="line">                --q;</span><br><span class="line">            suff[i]=i-q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义<code>good[]</code>数组表示遇到好后缀时，模式串应该移动的距离。其中<code>i</code>表示好后缀前面一个字符的位置（也就是坏字符的位置）.对应上面三种情况，<code>good</code>数组构建方法如下：<br><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fdb6nka0aqj20y013zgq7" alt=""></p>
<p>上面的三种情况，移动的距离是逐渐增大的，在满足不止一种情况时，应该移动最小的距离。所以分三部分考虑，</p>
<ul>
<li>对第三种情况，移动距离就是P的长度</li>
<li>对第二种情况，我们要找前缀，所以如果位置<code>i</code>到第一个是满足条件的话，必然有<code>suff[i]=i+1</code>，满足条件时，坏字符出现在<code>[0,m-1-i)</code>位置上时都可以移动<code>m-1-i</code>位使得模式串前<code>i+1</code>位与后<code>i+1</code>位重叠。对于<code>i</code>，从大到小计算是因为越长的前缀意味着越小的移动步数，我们希望找到小的，更新时判断<code>good[j]==m</code>也是为了不多次更新。</li>
<li>对第一种情况，我们知道当<code>m-1-suff[i]</code>位置为坏字符时，需要移动<code>m-i-1</code>位</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_good</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *P, <span class="keyword">int</span> m, <span class="keyword">int</span> bmGs[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, suff[<span class="number">256</span>];</span><br><span class="line">    suffixes(x, m, suff);</span><br><span class="line">    <span class="comment">// 第三种情况</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">        good[i] = m;</span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第二种情况</span></span><br><span class="line">    <span class="keyword">for</span> (i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (suff[i] == i + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span> (; j &lt; m - <span class="number">1</span> - i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (good[j] == m)</span><br><span class="line">                good[j] = m - <span class="number">1</span> - i;</span><br><span class="line">     <span class="comment">// 第一种情况</span></span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= m - <span class="number">2</span>; ++i)</span><br><span class="line">          good[m - <span class="number">1</span> - suff[i]] = m - <span class="number">1</span> - i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后给出BM算法，<strong>对于出现无法匹配的时候，移动步数取好后缀和坏字符两种情况的最大值</strong>。完整代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BM</span><span class="params">(<span class="keyword">char</span> *P, <span class="keyword">int</span> m, <span class="keyword">char</span> *S, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, good[m], bad[<span class="number">256</span>], k=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Preprocessing */</span></span><br><span class="line">    get_bad(P, m, bad);</span><br><span class="line">    get_good(P, m, good);</span><br><span class="line">    i = j = m-<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* Searching */</span></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= n - m) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i!=<span class="number">0</span> &amp;&amp; P[i]==S[j]) &#123;  <span class="comment">// 从后向前匹配、直到找到不匹配或者完全匹配</span></span><br><span class="line">            --i;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到一个匹配</span></span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span> &amp;&amp; P[i]==S[j]) &#123;</span><br><span class="line">            m++;</span><br><span class="line">            j += good[<span class="number">0</span>];  <span class="comment">// 找到匹配算是好后缀情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            j += good[i]&gt;bad[S[j]] ? good[i] : bad[S[j]];</span><br><span class="line">        &#125;</span><br><span class="line">        i = m-<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/04/BM/" data-id="ckeiowf5t00014gphau34vrgo" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Decision-Tree" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/02/Decision-Tree/">Decision Tree</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/02/Decision-Tree/">
            <time datetime="2017-03-02T01:39:28.000Z" itemprop="datePublished">2017-03-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/machine-learning/">machine learning</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="决策树模型"><a href="#决策树模型" class="headerlink" title="决策树模型"></a>决策树模型</h5><ul>
<li>决策树是一种基本的分类与回归的方法</li>
<li>决策树由节点和有向边组成</li>
<li>节点分为内部节点和叶节点</li>
<li><strong>决策树的学习其实就是特征选择的过程</strong></li>
</ul>
<h5 id="决策树学习"><a href="#决策树学习" class="headerlink" title="决策树学习"></a>决策树学习</h5><p><strong>决策树学习算法包含特征选择、决策树的生成和决策树的剪枝过程</strong></p>
<p>给定数据集$D=\lbrace (x_1,y_1),…,(x_m,y_m) \rbrace$其中$m$为样本容量，$x_i=(x_i^{(1)},…,x_i^{(n)})$，$n$为特征个数；$y_i\in \lbrace 1,2,…,K \rbrace$为类标记。</p>
<h6 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h6><p>统计学中，熵是随机变量不确定性的度量，即混乱程度。假设$X$是一个取有限个值的离散随机变量，其概率分布为$P(X=x_i)=p_i,i=1,..,N$，那么$X$的熵定义为<script type="math/tex">H(X)=-\sum_{i=1}^n p_i log p_i</script>条件熵$H(Y|X)$可以表示为已知随机变量$X$的条件下，随机变量$Y$的不确定性，也可以表示成<script type="math/tex">H(Y|X)=\sum_{i=1}^N p_iH(Y|X=x_i)</script>其中$p_i=P(X=x_i)$。<strong>当熵和条件熵中的概率由数据估计得到时，则分别称之为经验熵和条件经验熵</strong>，如果出现0概率，则令$0log0=0$。</p>
<p><strong>信息增益表示在得知特征$X$的情况下而使得$Y$的不确定性减少的程度</strong>，形式化表述为：特征$A$对训练数据集$D$的信息增益$g(D,A)$，定义为<script type="math/tex">g(D,A)=H(D)-H(D|A)</script>这里的<strong>信息增益等价于训练数据集中类与特征的互信息</strong>。计算信息增益的算法如下：</p>
<hr>
<p>输入：数据集$D$和特征$A$</p>
<hr>
<p>1 计算数据集$D$的经验熵$H(D)=-\sum_{k=1}^K \frac{|C_k|}{|D|}log_2\frac{|C_k|}{|D|}$<br>2 计算特征$A$对数据集$D$的经验条件熵<script type="math/tex">H(D|A)=\sum_{i=1}^N \frac{|D_i|}{|D|}H(D_i)=-\sum_{i=1}^N \frac{|D_i|}{|D|}\sum_{k=1}^K\frac{|D_{ik}|}{|D_i|}log_2\frac{|D_{ik}|}{|D_i|}</script><br>3 计算信息增益$g(D,A)=H(D)-H(D|A)$.</p>
<hr>
<p>输出信息增益</p>
<hr>
<h6 id="信息增益比"><a href="#信息增益比" class="headerlink" title="信息增益比"></a>信息增益比</h6><p><strong>以信息增益作为划分训练数据集的特征，存在偏向于选择取值较多的特征的问题</strong>，使用信息增益比可以缓解这个问题。特征$A$对训练数据集$D$的信息增益比定义为其增益信息$g(D,A)$与训练数据集$D$关于特征$A$的值的熵$H_A(D)$之比，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
g_R(D,A)=\frac{g(D,A)}{H_A(D)}
\end{aligned}</script><p>其中，$H_A(D)=-\sum_{i=1}^{A_n}\frac{|D_i|}{|D|}log_2\frac{|D_i|}{|D|}$，$A_n$是特征$A$取值的个数。</p>
<h6 id="ID3"><a href="#ID3" class="headerlink" title="ID3"></a>ID3</h6><p>ID3算法采用<strong>自上而下递归式的算法构建决策树，它使用信息增益作为特征选择的标准</strong>。停止条件是节点所有特征的信息增益都很小（阈值$\epsilon$）或没有特征可以选择为止。</p>
<hr>
<p>输入：训练数据集$D$，特征集$A$，阈值$\epsilon$</p>
<hr>
<p>1 若$D$中所有实例属于同一类$C_k$，$T$为单节点树，$C_k$为该节点的类标记，返回$T$<br>2 若$A=\emptyset$则$T$为单节点树，将$D$中实例数最大的类$C_k$作为该节点的类标记，返回$T$<br>3 否则，分别计算$A$中各特征对$D$的信息增益，选择信息增益最大的特征$A_g$<br>4 如果$A_g&lt;\epsilon$，则置T为单节点树，将$D$中实例数最大的类$C_k$作为该节点的类标记，返回$T$<br>5 否则，对$A_g$的每一个可能值$a_i$，根据$A_g=a_i$将$D$分割成若干非空子集$D_i$，将$D_i$中实例数最大的类作为标记，构建子节点，由节点及其子节点构成树$T$，返回$T$<br>6 对每个子节点$i$，以$D_i$为训练集，以$A-A_g$为特征集，递归调用以上步骤</p>
<hr>
<p>输出：决策树$T$</p>
<hr>
<h6 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h6><p><strong>C4.5与ID3的差异在于C4.5使用信息增益比进行选择选择</strong></p>
<h6 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h6><p><strong>基尼指数表示不确定程度，基尼指数越大，样本集的不确定程度就越大、纯度越低。</strong></p>
<p>分类问题中，假设有$K$个类，样本点属于第$k$类的概率为$p_k$，则概率分布的基尼指数定义为<script type="math/tex">Gini(p)=1-\sum_{k=1}^K p_k^2</script>对于给定的样本集$D$，其基尼指数为<script type="math/tex">Gini(D)=1-\sum_{k=1}^K\left( \frac{|C_k|}{|D|} \right)^2</script>其中$C_k$表示第$k$类的样本子集。表示集合$D$的不确定性。</p>
<p>假设样本集$D$根据特征$A$的不同取值被分成$A_n$个部分，则定义在特征$A$下集合$D$的基尼指数为</p>
<script type="math/tex; mode=display">
\begin{aligned}
Gini(D,A)=\sum_{i=1}^{A_n} \frac{|D_i|}{|D|}Gini(D_i)
\end{aligned}</script><h6 id="CART"><a href="#CART" class="headerlink" title="CART"></a>CART</h6><p><strong>CART分类树</strong><br>使用基尼指数作为划分属性的标准，每次选择基尼指数最小的属性。</p>
<p><strong>CART回归模型</strong><br>假设已将输入空间划分为$M$个单元$R_1,…,R_M$，并且在每个单元$R_m$上有一个固定的输出值$c_m$，回归树模型可以表示为<script type="math/tex">f(x)=\sum_{m=1}^Mc_mI(x\in R_m)</script>当输入空间划分确定时，可以用平方误差$\sum_{x_i}(y_i-f(x_i))^2$表示训练误差,<strong> $c_m$输出值为对应$R_m$上所有样本输出值的均值</strong>。</p>
<p>使用启发式的方法划分输入空间，遍历输入变量和可能的切分变量找到最优的切分变量$j$和切分点$s$，即找到切分后部分的误差最小：</p>
<script type="math/tex; mode=display">
\begin{aligned}
&R_1(j,s)=\lbrace{x|x^{(j)}\le s\rbrace}  \\
&R_2(j,s)=\lbrace x|x^{(j)}> s \rbrace  \\
&\min_{j,s} \left[ \min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2 + \min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2  \right]
\end{aligned}</script><p>其中$c_1,c_2$是划分后部分中输出值的均值。最小二乘回归树算法描述如下：</p>
<hr>
<p>输入：训练集$D$</p>
<hr>
<ol>
<li>选择最优切分变量$j$与最优切分点$s$，求解$\min_{j,s} \left[ \min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2 + \min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2  \right]$</li>
<li>用选定的对$(j,s)$划分区域并决定相应输出值：$R_1,R_2,c_1,c_2$</li>
<li>继续对两个子区域调用步骤1、2直至满足停止条件</li>
<li>将输入空间划分为$M$个区域$R_1,…,R_M$，生成CART树$f(x)=\sum_{m=1}^Mc_mI(x\in R_m)$</li>
</ol>
<hr>
<p>输出：$f(x)$</p>
<hr>
<h5 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h5><p>以上方法可能会产生过拟合现象，适当剪枝会使得决策树的泛化效果变得更好<br>剪枝分为预剪枝和后剪枝两种，预剪枝指的是在决策树生成的过程中进行剪枝，后剪枝则是在生成决策树之后再进行剪枝。</p>
<h6 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h6><p>大致过程描述：对于一个节点，考虑其剪枝或者不剪枝的情况，看这两种情况下哪种正确率高（一个节点的类别由其包含同类样本数最多的决定），由此决定是否剪枝。</p>
<p><strong>预剪枝基于贪心本质禁止某些节点展开，而这些节点第一次展开效果可能不好，但后续表现可能显著提高，所以会带来欠拟合的风险</strong>。</p>
<h6 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h6><p>大致过程描述：自下而上，叶节点不考虑，考虑其父节点F是否需要剪枝，可以仅仅通过父节点包含的样本，在剪枝和不剪枝的情况下分别计算准确率，然后确定是否需要剪枝。</p>
<p>下面是令一种后剪枝的方法（我不是很了解）：<br>通过<strong>极小化决策树整体的损失函数来实现</strong>。设树的叶节点个数为$|T|$，$t$是树$T$的叶节点，此叶节点上有$N_t$个样本，属于类$C_k$的样本有$N_{tk}$个，$H_t(T)$为叶节点$t$上的经验熵，$\alpha \ge 0$为参数，则决策树学习的损失函数可以定义为</p>
<script type="math/tex; mode=display">
\begin{aligned}
C_{\alpha}(T)=\sum_{t=1}^{|T|} N_tH_t(T)+\alpha |T|=C(T)+\alpha |T|
\end{aligned}</script><p>其中经验熵为$H_t(T)=-\sum_k \frac{N_{tk}}{N_t}log_2  \frac{N_{tk}}{N_t}$。$C(T)$表示模型对训练数据的预测误差，|T|表示模型的复杂度。剪枝算法描述如下：</p>
<hr>
<p>输入：决策树$T$，参数$\alpha$</p>
<hr>
<p>1 计算每个节点的经验熵<br>2 递归地从树的节点向上回溯，如果保留子节点的损失函数更大，剪枝以父节点作为叶子<br>3 返回2直到不能继续为止</p>
<hr>
<p>输出：修建后的决策树$T_{\alpha}$</p>
<hr>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/02/Decision-Tree/" data-id="ckeiowf7600244gph5pgogblr" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Bayesian-Classifier" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/02/26/Bayesian-Classifier/">Bayesian Classifier</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/02/26/Bayesian-Classifier/">
            <time datetime="2017-02-26T06:49:57.000Z" itemprop="datePublished">2017-02-26</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/machine-learning/">machine learning</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="朴素贝叶斯分类器"><a href="#朴素贝叶斯分类器" class="headerlink" title="朴素贝叶斯分类器"></a>朴素贝叶斯分类器</h6><p>输入空间$\mathbb{R}$为$n$维向量的集合，输出空间为类标记集合$\mathcal{Y}=\lbrace c_1,c_2,…,c_K \rbrace$，给定训练数据集<script type="math/tex">T=\lbrace (x_1,y_1),...,(x_N,y_N) \rbrace</script>由联合概率分布$P(X,Y)$独立同分布产生。</p>
<p>朴素贝叶斯分类器旨在<strong>最大化后验概率</strong>，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
c&=\arg\max_{c_k} P(Y=c_k|X=x) \\
 &=\arg\max_{c_k} \frac{P(X=x|Y=c_k)P(Y=c_k)} {\sum_k P(X=x|Y=c_k)P(Y=c_k)}
\end{aligned}</script><p>由于对于每一个不同的类别，上式中的分母都是一样的，所以上面的目标公式可以写成</p>
<script type="math/tex; mode=display">
\begin{aligned}
c=\arg\max_{c_k} P(X=x|Y=c_k)P(Y=c_k)
\end{aligned}</script><p>对于这个优化目标，可做如下统计</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(Y=c_k) &= \frac{ I\lbrace Y=c_k \rbrace }{N}
\end{aligned}</script><p>朴素贝叶斯分类器对条件概率分布进行了<strong>条件独立性</strong>的假设 而$P(X=x|Y=c_k)$可以分解为</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(X=x|Y=c_k)=\prod_j^n P(X^{(j)}=x^{(j)}|Y=c_k)
\end{aligned}</script><p>所以上式可以分开考虑，即在满足$Y=c_k$的集合中分别考虑，$P(X^{(1)}=x^{(1)}|Y=c_k)$就等于$Y=c_k$的集合中第一个属性为$x^{(1)}$样本所占的比例，所以上式可以写成</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(X=x|Y=c_k)=\prod_j^n \frac {I\lbrace X^{(j)}=x^{(j)}|Y=c_k \rbrace} {I\lbrace Y=c_k \rbrace}
\end{aligned}</script><p>所以，经过统计，就可以使用后验概率最大准则进行分类。</p>
<p>当然，也可以使用极大似然估计对单个属性和属性进行建模，用$D_c$表示数据集中第$c$类样本的集合，参数$\theta_c$表示对第$c$类样本的建模，所以有</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathcal{l} &= log \prod_{x\in D_c}P(x|\theta_c) \\
 &= \sum_{x\in D_c} logP(x|\theta_c)
\end{aligned}</script><p>对$P(x|\theta_c)$进行适当建模，比如$P(x|\theta_c) \sim \mathcal{N}(\mu_c, \sigma^2_c)$，然后用经典的极大似然估计进行估值即可。</p>
<h6 id="贝叶斯估计"><a href="#贝叶斯估计" class="headerlink" title="贝叶斯估计"></a>贝叶斯估计</h6><p>对于朴素贝叶斯分类器，做如下统计计算时</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(X=x|Y=c_k)=\prod_j^n \frac {I\lbrace X^{(j)}=x^{(j)}|Y=c_k \rbrace} {I\lbrace Y=c_k \rbrace}
\end{aligned}</script><p>分子、分母可能为0，所以这里使用<strong>拉普拉斯平滑</strong>，所以统计方法如下</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(Y=c_k) &= \frac{ I\lbrace Y=c_k \rbrace+\lambda }{N+\lambda K} \\
P(X=x|Y=c_k)&=\prod_j^n \frac {I\lbrace X^{(j)}=x^{(j)}|Y=c_k \rbrace+\lambda} {I\lbrace Y=c_k \rbrace+\lambda K_j}
\end{aligned}</script><p>其中，$K$是分类类别总数，而$K_j$表示第$j$个属性的可能取值数，$\lambda$是平滑参数，为1时则为Laplace平滑。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/02/26/Bayesian-Classifier/" data-id="ckeiowf5y00044gphln4dkhwg" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Cpp-Rule-Fragment" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/02/23/Cpp-Rule-Fragment/">Cpp Rule Fragment</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/02/23/Cpp-Rule-Fragment/">
            <time datetime="2017-02-23T00:50:23.000Z" itemprop="datePublished">2017-02-23</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Dev/">Dev</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Cpp/">Cpp</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h4 id="变量和基本类型"><a href="#变量和基本类型" class="headerlink" title="变量和基本类型"></a>变量和基本类型</h4><h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><h6 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h6><p>C++11中，一下初始化方法都是成立的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> x&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>使用花括号初始化变量在C++11中得到全面应用，但是用于内置类型的变量时，使用花括号初始化形式有个重要的特点：</p>
<pre><code>使用列表初始化且初始化存在丢失信息的风险，编译器将报错
</code></pre><p>比如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> db = <span class="number">3.141592653</span>;</span><br><span class="line"><span class="keyword">int</span> x&#123;db&#125;;              <span class="comment">// 错误，转换存在丢失信息的风险</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">y</span><span class="params">(db)</span></span>;              <span class="comment">// 正确，转换执行，丢失部分信息</span></span><br></pre></td></tr></table></figure>
<h6 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h6><p>如果内置类型的变量未被显示初始化，它的值由定义的位置决定。<strong>定义与任何函数体之外的变量初始化为0，定义于函数体内部的内置类型将不会被初始化</strong>。</p>
<h5 id="定义与声明"><a href="#定义与声明" class="headerlink" title="定义与声明"></a>定义与声明</h5><ul>
<li>声明使得名字为程序所知，定义负责创建与名字关联的实体</li>
<li>只声明一个变量而非定义它，使用<code>extern</code>关键字，不要显示初始化</li>
<li>任何包含了显示初始化的声明即成了定义</li>
<li>变量只能定义一次，但是可以声明多次</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="keyword">int</span> i;     <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">int</span> j;            <span class="comment">// 声明且定义</span></span><br><span class="line">extern <span class="keyword">int</span> k = <span class="number">2</span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<h5 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h5><h6 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h6><ul>
<li>引用必须被初始化，因为引用是要和初始值绑定到一起的</li>
<li>引用不能被重新绑定到另一个对象</li>
<li>引用不能被绑定到字面值、表达式计算结果</li>
<li>引用类型要与绑定对象类型严格匹配，只在极少数情况下有例外</li>
<li>因为引用不是对象，所以不能创建引用的引用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>, &amp;y = x, z=<span class="number">20</span>;</span><br><span class="line">&amp;y = z;         <span class="comment">// 错误，不能重新绑定</span></span><br><span class="line">y = z;          <span class="comment">// 正确，相当于赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;i = <span class="number">10</span>;   <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">double</span> j = <span class="number">2.55</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;k = j;    <span class="comment">// 错误，类型不匹配</span></span><br></pre></td></tr></table></figure>
<h6 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h6><ul>
<li>指针是一个对象，可以有指针的指针，且无需定义时赋初值</li>
<li>指针类型要与其指向对象类型严格匹配，只在极少数情况下有例外</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成空指针的方法</span></span><br><span class="line"><span class="keyword">int</span> *p1 = nullptr;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3 = NULL;</span><br></pre></td></tr></table></figure>
<p>void*指针</p>
<ul>
<li>可以存放任意对象的地址</li>
<li>不能直接操作void*指针指向的对象，因为不知道其类型</li>
</ul>
<h5 id="const"><a href="#const" class="headerlink" title="const"></a>const</h5><ul>
<li>const对象必须初始化，一旦创建，不能修改</li>
<li>利用一个对象去初始化另一个对象，无论他们是不是const都无关紧要，因为拷贝不会改变什么</li>
<li>默认情况下，const变量尽在文件内有效</li>
<li>多个文件共享的方法：声明、定义都添加extern关键字</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file 1，定义、初始化</span></span><br><span class="line">extern <span class="keyword">const</span> <span class="keyword">int</span> x = getSize();</span><br><span class="line"></span><br><span class="line"><span class="comment">// file 2，再次声明一下，与file 1中的是同一个</span></span><br><span class="line">extern <span class="keyword">const</span> <span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure>
<h6 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h6><ul>
<li>不能通过引用改变常量的值</li>
<li>初始化常量引用时允许用任意表达式作为初始值，只要表达式结果能转换成引用类型即可</li>
<li><strong>允许为一个常量引用绑定非常量对象、字面值，甚至表达式</strong>，非常量不行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i; <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>; <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span>; <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1*<span class="number">2</span>;     <span class="comment">// 错误，r4是非常量引用</span></span><br></pre></td></tr></table></figure>
<h6 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和const</h6><p><strong>指向常量的指针</strong></p>
<ul>
<li><strong>允许指向常量的指针指向非常量对象</strong></li>
<li>常量对象的地址只能存在指向常量的指针里</li>
</ul>
<p><strong>常量指针</strong></p>
<ul>
<li>常量指针是常量，必须初始化，且一旦初始化就不能改变，但其指向的对象可以被改变</li>
</ul>
<p><strong>顶层const</strong><br>顶层const表示指针本身是个常量，顶层const表示指针指向一个常量<br>左为底，右为顶即可分辨<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k=<span class="number">0</span>; <span class="comment">// 这个也是顶层const</span></span><br></pre></td></tr></table></figure></p>
<h6 id="constexpr和常量表达式"><a href="#constexpr和常量表达式" class="headerlink" title="constexpr和常量表达式"></a>constexpr和常量表达式</h6><ul>
<li>常量表达式的值不会改变，且在编译时期就能得到结果</li>
<li>C++11中将变量声明为constexpr类型，由编译器验证变量的值是否为常量表达式</li>
<li><strong>声明为constexpr的变量一定是常量，且必须用常量表达式初始化</strong></li>
<li>一个constexpr指针的初始值必须是nullprt或者0，或是存储与某个固定地址（比如全局变量，局部变量不行）中的对象</li>
<li>constexpr声明的指针，仅对指针有约束，不能约束指向的对象，顶层const</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">constexpr <span class="keyword">int</span> * p = nullptr; <span class="comment">// p是指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<h5 id="处理类型"><a href="#处理类型" class="headerlink" title="处理类型"></a>处理类型</h5><h6 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h6><p><strong>typedef</strong>和<strong>别名声明</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="keyword">double</span> wage, *p; <span class="comment">// wage是double同义词，p相当于double*</span></span><br><span class="line"></span><br><span class="line">using vi = vector;</span><br></pre></td></tr></table></figure></p>
<h6 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h6><ul>
<li>auto定义的变量必须有初始值</li>
<li>auto可以一次声明多个变量，但是这些变量的初始基本数据类型必须一样</li>
<li>auto推断的类型与原始类型可能会不太一样，比如<strong>auto会忽略掉顶层const</strong></li>
<li>引用类型也可以是auto，原来初始化规则适用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">auto a = i;       <span class="comment">// a是一个整数，顶层const被忽略</span></span><br><span class="line"><span class="keyword">const</span> auto b = i; <span class="comment">// b是一个const int</span></span><br><span class="line"></span><br><span class="line">auto &amp;c = i;</span><br><span class="line">auto &amp;d = <span class="number">42</span>; <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">const</span> auto &amp;e = <span class="number">42</span>; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h6 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h6><ul>
<li>decltype的作用是<strong>选择并返回操作数的严格基本类型</strong></li>
<li>如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括const和引用）</li>
<li>如果表达式内容是解引用，decltype得到引用类型</li>
<li>如果<strong>变量名加上了一层或多层括号，就会被当成表达式，会得到引用类型</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci=<span class="number">0</span>, &amp;cj=ci;</span><br><span class="line">decltype(ci) x=<span class="number">0</span>;  <span class="comment">// x为const int</span></span><br><span class="line">decltype(cj) y=x;  <span class="comment">// y为const int&amp;，y绑定到x</span></span><br><span class="line">decltype(cj) z;    <span class="comment">// 错误，z是引用，必须初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">42</span>, *p=&amp;i;</span><br><span class="line">decltype(*p) c;    <span class="comment">// 错误，c是int&amp;，必须初始化</span></span><br><span class="line"></span><br><span class="line">decltype(i) m;     <span class="comment">// 正确，一个未初始化的int</span></span><br><span class="line">decltype((i)) n;   <span class="comment">// 错误，int&amp; 必须初始化</span></span><br></pre></td></tr></table></figure>
<h4 id="字符串，向量，数组"><a href="#字符串，向量，数组" class="headerlink" title="字符串，向量，数组"></a>字符串，向量，数组</h4><p>数组不允许直接拷贝、赋值</p>
<h5 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h5><p>字符数组可以使用字符串字面值进行初始化，但字符串结尾处还有一个空字符<code>&#39;\0&#39;</code>，这个空字符也会被拷贝到数组中去</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'c'</span>,<span class="string">'+'</span>, <span class="string">'+'</span>&#125;;         <span class="comment">// 长度为3</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">'c'</span>,<span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;  <span class="comment">// 长度为4</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"c++"</span>;              <span class="comment">// 长度为4</span></span><br><span class="line"><span class="keyword">char</span> a4[<span class="number">3</span>] = <span class="string">"c++"</span>;            <span class="comment">// 错误，数组空间不足</span></span><br></pre></td></tr></table></figure>
<h5 id="负载数组声明"><a href="#负载数组声明" class="headerlink" title="负载数组声明"></a>负载数组声明</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * ptr[<span class="number">10</span>];           <span class="comment">// 含义10个整型指针的数组 </span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]=<span class="comment">/*...*/</span>  <span class="comment">// 不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>];     <span class="comment">// 指向一个10个整型元素数组的指针</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>]     <span class="comment">// 引用一个10个整型元素数组的指针</span></span><br></pre></td></tr></table></figure>
<h5 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h5><h6 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h6><p><strong><code>static_cast</code>可以完成任何具有明确定义的类型转换(支持强制转换)，只要不包含底层const</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i=<span class="number">2</span>,j=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> slope = static_cast&lt;<span class="keyword">double</span>&gt;(j) / i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>* p = &amp;d;</span><br><span class="line"><span class="keyword">double</span> *dp = static_cast&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure></p>
<h6 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h6><p><strong><code>const_cast</code>只能改变运算对象的底层const</strong>，通常用于有函数重载的上下文中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p = const_cast&lt;<span class="keyword">char</span>*&gt;(pc);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp;</span><br><span class="line"><span class="keyword">char</span> *q = static_cast&lt;<span class="keyword">char</span>*&gt;(cp);  <span class="comment">// 错误，static_cast不能转换掉const性质</span></span><br><span class="line">static_cast&lt;string&gt;(cp);           <span class="comment">// 正确，字符串字面值转换成string属性</span></span><br><span class="line"><span class="keyword">const</span>&lt;string&gt;(cp);                 <span class="comment">// 错误，const_cast只改变常量属性</span></span><br></pre></td></tr></table></figure></p>
<h6 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h6><p><strong><code>reinterpret_cast</code>通常为运算对象的位模式提供较低层次上的重新解释</strong>，容易引发错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *cp = reinterpret_cast&lt;<span class="keyword">char</span>*&gt;(ip); <span class="comment">// 虽然转换，但pc所指对象依旧是int型</span></span><br></pre></td></tr></table></figure></p>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><ul>
<li><strong>用实参初始化形参时会忽略掉顶层const，也就是说给形参传递常量对象或者非常量对象都可以</strong></li>
<li>由于顶层const被忽略，只有形参顶层const差异的函数会被当成同一个函数</li>
<li><strong>可以使用一个非常量初始化一个底层const对象，但是反过来不行</strong></li>
<li><strong>普通引用必须用同类型的对象初始化</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;...&#125;        <span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>&#123;...&#125;  <span class="comment">// 错误，重复定义func</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//————————————————————————————————————————————————————————</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(<span class="keyword">int</span> &amp;i)</span></span>&#123;i=<span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line">string::size_type ctr = <span class="number">0</span>;</span><br><span class="line">reset(&amp;i);           <span class="comment">// 调用形参类型是int*的reset函数</span></span><br><span class="line">reset(i);            <span class="comment">// 调用形参类型是int&amp;的reset函数</span></span><br><span class="line">reset(&amp;ci);          <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br><span class="line">reset(ci);           <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br><span class="line">reset(<span class="number">42</span>);           <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br><span class="line">reset(ctr);          <span class="comment">// 错误，普通引用必须用同类型的对象初始化</span></span><br></pre></td></tr></table></figure>
<h5 id="引用返回左值"><a href="#引用返回左值" class="headerlink" title="引用返回左值"></a>引用返回左值</h5><ul>
<li>一般函数的返回值均为右值，但也有返回左值的函数</li>
<li>由函数的返回值类型决定，具体来说，<strong>调用一个返回引用的函数得到左值，其他类型为右值</strong></li>
<li><strong>左值可以被赋值，右值不行</strong></li>
<li>如果返回值类型是常量引用，那么就不能赋值了（常量不能修改啊）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;get_val(string &amp;s, string::size_type ix) &#123; <span class="comment">//返回的是引用</span></span><br><span class="line">    <span class="keyword">return</span> s[ix];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line">get_val(s,<span class="number">3</span>) = <span class="string">'A'</span>;       <span class="comment">// 可以对左值进行赋值</span></span><br></pre></td></tr></table></figure>
<h5 id="返回数组指针"><a href="#返回数组指针" class="headerlink" title="返回数组指针"></a>返回数组指针</h5><p>普通的数组指针声明如下</p>
<pre><code>type (*name)[dimension]
</code></pre><p>返回数组指针的函数形式如下</p>
<pre><code>type ( *function(parameter_list) ) [dimension]
</code></pre><h6 id="类型别名-1"><a href="#类型别名-1" class="headerlink" title="类型别名"></a>类型别名</h6><p>也可以考虑使用类型别名</p>
<pre><code>typedef int arrT[10];
using arrT = int[10];
arrt* func(int i);
</code></pre><h6 id="尾置返回类型"><a href="#尾置返回类型" class="headerlink" title="尾置返回类型"></a>尾置返回类型</h6><ul>
<li>任何函数都可以使用尾置返回类型</li>
<li>这种返回方法对复杂的返回类型比较有效</li>
<li>尾置返回类型跟在形参列表后面，以<code>-&gt;</code>开头，在原本返回类型出现的地方加上<code>auto</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span> [10]</span>;</span><br></pre></td></tr></table></figure>
<h6 id="使用decltype"><a href="#使用decltype" class="headerlink" title="使用decltype"></a>使用decltype</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// decltype(odd) 返回的是数组，需要在加一个*变成指针</span></span><br><span class="line">decltype(odd) * func(<span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="comment">// ...........</span></span><br><span class="line">    <span class="keyword">return</span> &amp;odd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><ul>
<li>重载函数的名字肯定一样，需要形参类型或者数量上有差异</li>
<li>仅仅返回值不一样不是重载函数，而是重定义</li>
<li><strong>仅有顶层const的差异不构成重载，底层const可以</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;      <span class="comment">// 顶层const，重复定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> * i)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *i)</span></span>;     <span class="comment">// 底层const，重载函数，指针换引用也一样</span></span><br></pre></td></tr></table></figure>
<h6 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h6><ul>
<li><strong>如果在内层作用域中声明名字，它将隐藏外层作用域中所有同名的实体</strong></li>
<li>声明在内部作用域的名字可能会是外部作用域中同名的所有重载函数失效（不声明名字就没事）</li>
<li>不同的作用域中无法承载函数名</li>
</ul>
<h5 id="默认语言用途"><a href="#默认语言用途" class="headerlink" title="默认语言用途"></a>默认语言用途</h5><h6 id="默认实参"><a href="#默认实参" class="headerlink" title="默认实参"></a>默认实参</h6><ul>
<li>默认实参填补函数调用缺少的尾部实参，所以默认形参都在尾部</li>
<li>尾部参数没省略时，中间参数不能省略</li>
<li>给定作用域中，一个形参只能被赋予一次默认实参</li>
<li><strong>局部变量不能成为默认实参</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span>=<span class="string">' '</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">screen</span><span class="params">(sz, sz, <span class="keyword">char</span>=<span class="string">'*'</span>)</span></span>;  <span class="comment">// 错误，重复声明</span></span><br></pre></td></tr></table></figure>
<h6 id="函数匹配"><a href="#函数匹配" class="headerlink" title="函数匹配"></a>函数匹配</h6><ul>
<li>优先选择精确匹配、最匹配，所谓最匹配要看实参与形参的接近程度</li>
<li>有且只有一个函数满足以下条件，则匹配成功<ul>
<li>该函数每个函数的匹配都不劣与其他函数需要的匹配</li>
<li>至少有一个实参的匹配优于其他可行函数提供的匹配</li>
</ul>
</li>
<li>上面两步检查后没有函数脱颖而出，那么判定为二义性，报错</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>,<span class="number">2.5</span>);</span><br></pre></td></tr></table></figure>
<p>上面的例子中，对于第一个实参，<code>f(int,int)</code>好；对于第二个实参，<code>f(double,double)</code>好。最终判断此调用具有二义性，拒绝请求。</p>
<p>实参到形参的类型转换分为几个等级，如下</p>
<ol>
<li>精确匹配<ul>
<li>实参、形参类型相同</li>
<li>实参从数组或函数类型转化成对应的指针</li>
<li>向实参添加顶层const、从实参中删除顶层const</li>
</ul>
</li>
<li>通过const转换实现的匹配（比如创建指向非常量的常量指针、引用）</li>
<li>通过类型提升实现的匹配（short+int=int整型提升）</li>
<li>通过算术类型转换（int转double，所有算术类型转换级别一样）或指针实现的匹配</li>
<li>通过类类型转换实现的匹配</li>
</ol>
<h5 id="inline和constexpr"><a href="#inline和constexpr" class="headerlink" title="inline和constexpr"></a>inline和constexpr</h5><ul>
<li>inline函数编译时，一般适用于代码量很少的函数</li>
<li>const是指用于常量表达式的函数，返回类型及所有形参都必须是字面值类型，并且要求有且只有一个return语句</li>
<li>inline函数和constexpr函数可以多次定义，且通常定义在头文件内</li>
</ul>
<h5 id="调试帮助"><a href="#调试帮助" class="headerlink" title="调试帮助"></a>调试帮助</h5><h6 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h6><p>assert的用法是<code>assert(expr);</code>，如果表达式expr的值为true，assert什么也不做；否则，assert输出信息并终止程序执行。</p>
<h6 id="NDEBUG"><a href="#NDEBUG" class="headerlink" title="NDEBUG"></a>NDEBUG</h6><p>如果定义了NDEBUG，那么调试模式就关闭了，assert就不能起作用了。此外，NDEBUG也有助于开发者编写自己的调试代码。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define NDEBUG  // 表示关闭了调试模式</span><br><span class="line"></span><br><span class="line"># ifndef NDEBUG  // 没有关闭调试模式</span><br><span class="line"><span class="comment">// 。。。。</span></span><br><span class="line"># endif</span><br></pre></td></tr></table></figure></p>
<h5 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h5><ul>
<li>函数指针也是指针，可以赋值为nullptr、0等</li>
<li>指向不同函数类型的函数指针不存在类型转换</li>
<li><strong>定义重载函数指针时，指针类型必须与重载函数中的某一个精确匹配</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bool <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 定义函数指针</span></span><br><span class="line">bool (*pf)(<span class="keyword">int</span>) = func;     <span class="comment">// 定义指向函数func的函数指针</span></span><br><span class="line">bool (*pf)(<span class="keyword">int</span>) = &amp;func   <span class="comment">// 与上面等价</span></span><br><span class="line"><span class="comment">// 使用函数指针</span></span><br><span class="line">pf(<span class="number">1</span>);</span><br><span class="line">(*pf)(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p><strong>C++中，形参和返回值都不能是函数，但可以是函数指针</strong>，使用类型别名、decltype等可以使得函数指针的声明变得简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等价的两种定义方式，funcp可以使用在函数实参、返回值</span></span><br><span class="line"><span class="function">typedef <span class="title">bool</span> <span class="params">(*funcp)</span> <span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function">typedef <span class="title">decltype</span><span class="params">(func)</span> *funcp</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用using、尾置返回类型</span></span><br><span class="line">using pf = bool(*) (<span class="keyword">int</span>);  <span class="comment">// pf是函数指针</span></span><br><span class="line"><span class="function">pf <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">using f  = bool (<span class="keyword">int</span>);     <span class="comment">// f类型是函数</span></span><br><span class="line">f *f1(<span class="keyword">int</span>);                    <span class="comment">// 显示指定返回类型是指向函数的指针</span></span><br><span class="line"></span><br><span class="line"><span class="function">auto <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> -&gt; <span class="title">bool</span><span class="params">(*)</span> <span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 尾置返回类型指定返回类型</span></span><br><span class="line">decltype(func) *f1(<span class="keyword">int</span>);        <span class="comment">// 知道返回的函数是哪一个更方便</span></span><br></pre></td></tr></table></figure></p>
<h4 id="类"><a href="#类" class="headerlink" title="类"></a>类</h4><h5 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h5><h6 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h6><ul>
<li>const成员函数不能改变调用它的对象的内容</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">const_func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> <span class="keyword">const</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回this对象的函数</span></span><br><span class="line"><span class="comment">// 返回值是引用</span></span><br><span class="line">New_Class&amp; New_Class::hello () &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">    attribute += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">New_Class nc;</span><br><span class="line">nc.hello();  <span class="comment">// nc的attribute属性已经改变了</span></span><br></pre></td></tr></table></figure>
<h6 id="类相关的非成员函数"><a href="#类相关的非成员函数" class="headerlink" title="类相关的非成员函数"></a>类相关的非成员函数</h6><ul>
<li>这里的相关非成员函数包括但不限于<code>read</code>、<code>print</code>等</li>
<li>如果非成员函数是类接口的组成部分，这些函数的声明应当与类在同一个头文件内</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IO类型不能拷贝，所以只能以引用的形式加入形参</span></span><br><span class="line"><span class="comment">// 最后需要返回IO类型的引用</span></span><br><span class="line"><span class="comment">// ostream、print也类似，定义输出函数应该尽量减少对格式的控制</span></span><br><span class="line">istream &amp;read(istream &amp;is, New_Class &amp;item) &#123;</span><br><span class="line">    is &gt;&gt; item.a1 &gt;&gt; item.a2 &gt;&gt; item.a3;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">istream &amp;is;</span><br><span class="line">read(is, *<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>
<h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><ul>
<li><strong>构造函数不能为const</strong></li>
<li><strong>const对象和引用都应该在初始值列表中初始化</strong></li>
<li>初始化列表：成员初始化的顺序与类定义中的顺序一致</li>
<li>构造const对象时，知道构造函数完成其初始化过程，对象才能取得其“常量”属性</li>
<li>默认构造函数的规则如下：<ul>
<li>如果有别的构造函数，编译器不会生成默认构造函数</li>
<li><strong>如果存在类内初始值，用它来初始化成员</strong></li>
<li>否则，默认初始化（string为””，int块外为0，块内未定义）</li>
</ul>
</li>
<li>C++11中，如果需要默认行为可以在参数列表之后写上 <code>=default</code>要求编译器生成默认构造函数</li>
<li><strong>当某个数据成员被构造函数初始值列表忽略时，它将以合成默认构造函数相同的方式隐式初始化</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有其他构造函数的情况下，还想要默认构造函数可以这样</span></span><br><span class="line">New_Class() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过默认参数也等与实现了默认构造函数</span></span><br><span class="line">New_Class(string s = <span class="string">" "</span>):name(s)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>委托构造函数</strong>就是利用其他构造函数执行自己的初始化过程，其在参数列表初始化位置调用其他构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">New_Class() : New_Class(<span class="string">"zhangsan"</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="隐式类类型转换"><a href="#隐式类类型转换" class="headerlink" title="隐式类类型转换"></a>隐式类类型转换</h6><ul>
<li>通过一个实参调用的构造函数定义一条<strong>从构造函数参数类型向类类型隐式转换</strong>的规则</li>
<li>只允许一步类类型转换，隐式转换可能会出错</li>
<li>抑制隐式转换的方法是在构造函数前加上关键字<code>explicit</code></li>
<li>使用<code>static_cast</code>这样的显式转换也能达到转换的效果<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string lisi = <span class="string">"lisi"</span>;</span><br><span class="line"><span class="function">New_Class <span class="title">zhangsan</span><span class="params">(<span class="string">"zhangsan"</span>)</span></span>;</span><br><span class="line"><span class="comment">// playWith函数的参数类型是New_Class</span></span><br><span class="line">zhangsan.playWith(lisi);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h5><ul>
<li>class和struct定义类时的唯一区别就是默认访问权限</li>
<li>struct默认为public，而class默认为private</li>
</ul>
<h6 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h6><ul>
<li>类中使用<code>friend</code>关键字可以使其他类或者函数成为它的友元</li>
<li>成为友元的类、函数可以访问当前类的非公有成员</li>
<li>友元不是类的成员，不受其所在区域访问控制级别的约束</li>
<li>类内友元函数的声明并非普通意义上的声明，所以在其他地方还得声明一次，即便定义在类内部也还要在外面声明</li>
<li>友元函数也可以定义在类内部，隐式inline</li>
<li><strong>友元关系不存在传递性</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class2</span> </span>&#123;</span><br><span class="line">friend <span class="class"><span class="keyword">class</span> <span class="title">Class1</span></span>;</span><br><span class="line">friend istream &amp; read(istream &amp;is, Class2 &amp; c2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h6><ul>
<li>定义在类内部的成员函数自动是<code>inline</code>类型的</li>
<li><strong><code>mutable</code>成员用于不会是const，即使在const成员函数内他也是可以被改变的</strong></li>
<li>返回<code>*this</code>的函数返回的是左值引用（返回类型是引用），返回的是对象本身而不是副本</li>
</ul>
<h6 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h6><ul>
<li>所有成员都是public</li>
<li>没有定义任何构造函数</li>
<li><strong>没有类内初始值</strong></li>
<li>没有基类、没有虚函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct data &#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    string s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h5><ul>
<li>静态成员于类本身直接相关</li>
<li>静态成员函数不包含this指针、也不能显式、隐式地使用this指针（<strong>不能操作非静态成员</strong>）</li>
<li><strong>静态成员函数不能声明成const</strong></li>
<li>在类的外部定义静态成员时，不能重复static关键字</li>
<li>静态成员变量应该在类的外部定义</li>
<li>静态数据成员可以是不完全类型（类在声明之后、定义之前称为不完全类型）</li>
<li>静态成员可以是默认实参，非静态的不可以</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> A a;  <span class="comment">// 正确，静态成员可以使不完全类型</span></span><br><span class="line">    A b;           <span class="comment">// 错误，数据成员必须是完全类型，不过可以定义指针、引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="IO库与容器库"><a href="#IO库与容器库" class="headerlink" title="IO库与容器库"></a>IO库与容器库</h4><h5 id="string流"><a href="#string流" class="headerlink" title="string流"></a>string流</h5><p><code>sstream</code>包含三个支持string读写的类型，分别是<code>istringstream</code>、<code>ostringstream</code>和<code>stringstream</code>。<br>sstream的使用可以如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sstream strm;</span><br><span class="line"><span class="function">sstream <span class="title">strm</span><span class="params">(s)</span></span>; <span class="comment">// strm是sstream的对象，保存string s的拷贝</span></span><br><span class="line"></span><br><span class="line">strm.str()           <span class="comment">// 返回strm所保存的string的拷贝</span></span><br><span class="line">strm.str(s)         <span class="comment">// copy string s to strm, return void</span></span><br></pre></td></tr></table></figure></p>
<p><code>istringstream</code>、<code>ostringstream</code>的用法也很简单，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">line</span><span class="params">(<span class="string">"suck my balls"</span>)</span>, word</span>;</span><br><span class="line"><span class="function">istringstream <span class="title">is</span><span class="params">(line)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (is &gt;&gt; word)</span><br><span class="line">    cout &lt;&lt; word &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<p>向<code>ostringstream</code>对象写入string其实就是将string添加字符。</p>
<h6 id="array"><a href="#array" class="headerlink" title="array"></a>array</h6><ul>
<li>array容器的大小是一定的，其大小也是类型的一部分</li>
<li>array容器与普通数组不同的是，array支持拷贝与赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="keyword">int</span>&gt; arr;  <span class="comment">// 错误，缺少大小</span></span><br><span class="line">array&lt;<span class="keyword">int</span>, <span class="number">10</span>&gt; arr1 <span class="comment">// 正确</span></span><br><span class="line"></span><br><span class="line">array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; arr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">array&lt;<span class="keyword">int</span>, <span class="number">3</span>&gt; arr1 = arr;  <span class="comment">//正确，类型一定要一致</span></span><br></pre></td></tr></table></figure>
<h6 id="顺序容器的操作"><a href="#顺序容器的操作" class="headerlink" title="顺序容器的操作"></a>顺序容器的操作</h6><pre><code>seq.assign(b,e); // 将seq中的元素替换成迭代器b、e所表示范围中的元素
seq.assign(il);   // 将seq中的元素替换成初始化列表il中的元素，比如il={1,2,3,4}，为值列表
seq.assign(n,t); // 将seq中的元素替换成n个元素t

c.insert(p, t); // 在迭代器p之前添加元素t，返回添加元素的迭代器
c.insert(p, n, t); // 在迭代器p之前添加n个元素t，返回第一个添加的元素的迭代器
c.insert(p, b, e); // 在迭代器p之前添加迭代器b、e之间的元素
c.insert(p, il);
</code></pre><p><strong>向一个vector、string、deque插入元素会使所有的指向容器的迭代器、引用和指针失效</strong></p>
<ul>
<li><code>emplace_front, emplace_back, emplace</code>分别对应<code>push_front, push_back, insert</code></li>
<li>这些函数可以构造元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    person(string nm, <span class="keyword">int</span> ag);</span><br><span class="line">&#125;</span><br><span class="line">c.emplace_front(<span class="string">"zhangsan"</span>, <span class="number">10</span>); <span class="comment">// 插入10岁的zhangsan的元素</span></span><br><span class="line">c.push_front(<span class="string">"zhangsan"</span>, <span class="number">10</span>); <span class="comment">// 错误，没有接受三个参数的push_front版本</span></span><br><span class="line">c.push_front(person(<span class="string">"zhangsan"</span>,<span class="number">10</span>)); <span class="comment">// 正确，先构造对象</span></span><br></pre></td></tr></table></figure>
<p>顺序容器还支持关系运算符，从头向尾比较，比较直观。</p>
<h6 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h6><pre><code>c1.swap(c2);
swap(c1, c2);
</code></pre><ul>
<li>swap交换元素很快，因为元素本身没有交换，swap只是交换了两个容器的内部数据结构</li>
<li>array是个例外，swap真正交换元素，所以交换所需时间与元素数目成正比</li>
</ul>
<h6 id="改变容器大小、容量"><a href="#改变容器大小、容量" class="headerlink" title="改变容器大小、容量"></a>改变容器大小、容量</h6><p><strong>改变size</strong>：size是容器当前大小，采用多退少补的方法</p>
<ul>
<li>函数resize可以改变改变容器大小<code>resize(n)</code>，也可以将新添加的元素设置为t <code>resize(n,t)</code></li>
<li>array不支持</li>
</ul>
<p><strong>改变capacity</strong>：capacity是容器的最大容量</p>
<ul>
<li><code>capacity()</code>获取容量</li>
<li><code>reserve(n)</code>分布至少能容纳n个元素的内存空间</li>
<li><code>shrink_to_fit()</code>将<code>capacity</code>减少为<code>size</code>大小</li>
</ul>
<h6 id="string的搜索操作"><a href="#string的搜索操作" class="headerlink" title="string的搜索操作"></a>string的搜索操作</h6><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>s.find(args)</td>
<td>s中args第一次出现的位置</td>
</tr>
<tr>
<td>s.rfind(args)</td>
<td>s中args最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_of(args)</td>
<td>s中查找args中任何一个字符第一次出现的位置</td>
</tr>
<tr>
<td>s.find_last_of(args)</td>
<td>s中查找args中任何一个字符最后一次出现的位置</td>
</tr>
<tr>
<td>s.find_first_not_of(args)</td>
<td>s中查找第一个不在args中的字符</td>
</tr>
<tr>
<td>s.find_last_not_of(args)</td>
<td>s中查找最后一个不在args中的字符</td>
</tr>
</tbody>
</table>
</div>
<p>其中<code>args</code>的形式为包括（pos默认为0）</p>
<pre><code>c, pos ：    pos为开始查找的位置，c是一个字符
s2, pos：    s2是字符串
cp, pos：    cp是指向c风格的字符串的指针（以&#39;\0&#39;结尾）
cp, pos, n： n表示只看前n个字符
</code></pre><p>搜索失败则返回一个名为<code>string::npos</code>的static成员，其值初始化为-1.</p>
<h6 id="string数制转换"><a href="#string数制转换" class="headerlink" title="string数制转换"></a>string数制转换</h6><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>to_string(val)</td>
<td>任何算术类型向string转换</td>
</tr>
<tr>
<td>stoi(s, p, b)</td>
<td>string转int，s是字符串</td>
</tr>
<tr>
<td>stol(s, p, b)</td>
<td>string转long，b是转换基数（默认为10，十进制）</td>
</tr>
<tr>
<td>stoul(s, p, b)</td>
<td>string转unsigned long，p是起始位置</td>
</tr>
<tr>
<td>stoll(s, p, b)</td>
<td>string转long long</td>
</tr>
<tr>
<td>stoull(s, p, b)</td>
<td>string转unsigned long long</td>
</tr>
<tr>
<td>stof(s, p)</td>
<td>string转float，p是起始位置</td>
</tr>
<tr>
<td>stod(s, p)</td>
<td>string转double</td>
</tr>
<tr>
<td>stold(s, p)</td>
<td>string转long double</td>
</tr>
</tbody>
</table>
</div>
<h5 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h5><p><strong>适配器是一种机制，能使某种事物的行为看起来像另外一种事物</strong><br>标准库中有三个顺序容器适配器，<code>stack、queue、priority_queue</code></p>
<h4 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h4><ul>
<li>泛型算法定义在头文件<code>numeric</code>中</li>
</ul>
<h5 id="几个基本的泛型算法"><a href="#几个基本的泛型算法" class="headerlink" title="几个基本的泛型算法"></a>几个基本的泛型算法</h5><ul>
<li><code>find(iter1, iter2, val);</code> // 元素查找，iter1、iter2迭代器至少查找的范围，val是查找的元素。查找失败返回iter2，否则返回对应的迭代器</li>
<li><code>accumulate(iter1, iter2, sum);</code>  // 元素累加，执行+运算，sum是和的初值，返回最终的和</li>
<li><code>equal(iter1, iter2, another_iter);</code>  //  比较两个序列元素是否完全一致，一致返回true。another_iter表示第二个序列的起始迭代器</li>
<li><code>fill(iter1, iter2, val);</code>  // 将迭代器范围中的每个值置为val</li>
<li><code>fill_n(iter, n, val);</code>  // 将从iter起的n个元素置为val（必须保证有n个元素）</li>
<li><code>copy(iter1, iter2, another_iter);</code>  // 将iter1-iter2范围内的元素拷贝到以another_iter起始的位置上，要求another_iter对应的容器大小不能比iter1对应的容器小，返回another_iter的位置迭代器位置</li>
<li><code>replace(iter1, iter2, val, new_val);</code>  // 迭代器范围内，将所有的val换成 new_val</li>
<li><code>replace_copy(iter1, iter2, new_iter, val, new_val);</code>  // 保持iter1对应的容器不变，将替换后的结果写入new_iter对应的容器中</li>
<li><code>unique(iter1, iter2);</code>  // 去重，返回指向不重复区域之后一个位置的迭代器</li>
</ul>
<h5 id="定制操作"><a href="#定制操作" class="headerlink" title="定制操作"></a>定制操作</h5><h6 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h6><pre><code>[捕获列表] (参数列表) -&gt; 返回类型 {函数体};
</code></pre><ul>
<li>lambda可以理解成未命名的inline函数</li>
<li>捕获列表：表达式所在函数的局部变量列表，局部变量间以<code>,</code>分隔，通常为空。<code>&amp;</code>引用捕获，<code>=</code></li>
<li>参数列表、返回类型、函数体和普通函数一个意思</li>
<li><strong>参数列表和返回类型可以忽略，但捕获列表和函数体必须存在</strong></li>
<li>lambda表达式的返回值是一个可调用对象，不接收参数，直接带括号调用。可调用对象包括函数、函数指针、lambda表达式等</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto f = []&#123;<span class="keyword">return</span> <span class="number">0</span>;&#125; <span class="comment">// f是可调用对象</span></span><br><span class="line">cout &lt;&lt; f() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h6 id="bind函数"><a href="#bind函数" class="headerlink" title="bind函数"></a>bind函数</h6><ul>
<li>头文件为<code>functional</code></li>
<li>接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表</li>
<li>可以看成一个通用的函数适配器</li>
<li><p>bind在绑定过程中都是采用参数拷贝的方式，所以对于需要引用的类型，可以使用<code>ref</code>、<code>cref</code>函数表示引用（常量c）</p>
<p>  <code>auto newCallable = bind(callable, arg_list);</code></p>
</li>
</ul>
<p><code>arg_list</code>中可能包含<code>_n</code>这样的名字（n是整数），这些是占位符，表示newCallable的参数。<code>_n</code>表示第n个参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f是有5个参数的可调用对象</span></span><br><span class="line">auto g = bind(f, a, b, _2, c, _1);</span><br><span class="line"><span class="comment">// 传递给g的参数会被分别绑定到_1、_2位置上</span></span><br><span class="line"><span class="comment">// g(X, Y) 等价于 f(a, b, Y, c, X)</span></span><br><span class="line"></span><br><span class="line">ostream &amp;print(ostream &amp;os, string &amp;s, <span class="keyword">char</span> c) &#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; s &lt;&lt; c;</span><br><span class="line">&#125;</span><br><span class="line">for_each(words.begin(), words.end(), bind(print, os, _1, <span class="string">' '</span>));  <span class="comment">// 错误，os不能拷贝</span></span><br><span class="line">for_each(words.begin(), words.end(), bind(print, ref(os), _1, <span class="string">' '</span>));  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure></p>
<h5 id="特殊迭代器"><a href="#特殊迭代器" class="headerlink" title="特殊迭代器"></a>特殊迭代器</h5><h6 id="插入迭代器"><a href="#插入迭代器" class="headerlink" title="插入迭代器"></a>插入迭代器</h6><p>包括<code>back_inserter, front_inserter, inserter</code>三种，分别创建使用<code>push_back, push_front, insert</code>的迭代器。<br>使用 <code>inserter(c, iter)</code>时，插入元素位置在iter位置之前，并且插入前后，iter指向的元素不变；但是<code>front_inserter(c)</code>就一直在容器头部插入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">list&lt;<span class="keyword">int</span>&gt; lst2, lst3;</span><br><span class="line"><span class="comment">// 插入后lst2为 4 3 2 1</span></span><br><span class="line">copy(lst.begin(), lst.end(), front_inserter(lst2));</span><br><span class="line"><span class="comment">// 插入后lst3为 1 2 3 4</span></span><br><span class="line">copy(lst.begin(), lst.end(), inserter(lst3, lst3.begin()));</span><br></pre></td></tr></table></figure></p>
<h6 id="iostream迭代器"><a href="#iostream迭代器" class="headerlink" title="iostream迭代器"></a>iostream迭代器</h6><ul>
<li>使用流迭代器，必须指定读写对象的类型</li>
<li>istream_iterator迭代器要读取的内容必须定义了<code>&gt;&gt;</code>运算符，ostream_iterator迭代器要读取的内容必须定义了<code>&lt;&lt;</code>运算符</li>
<li>默认初始化istream_iterator迭代器，创建一个当作尾后值使用的迭代器</li>
<li>流迭代器不支持递减<code>--</code>操作</li>
<li>istream_iterator迭代器支持<code>++, *, -&gt;, ==,  !=</code>运算符</li>
<li>ostream_iterator迭代器支持<code>++, =,  *</code>运算符</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;T&gt; <span class="title">in</span><span class="params">(is)</span></span>;  <span class="comment">// 迭代器对象in从输入流is中读取类型为T的值</span></span><br><span class="line">istream_iterator&lt;T&gt; eof;     <span class="comment">// 尾后迭代器</span></span><br><span class="line"><span class="function">vector&lt;T&gt; <span class="title">vec</span><span class="params">(in, eof)</span></span>;  <span class="comment">// 从迭代器范围构造vector对象</span></span><br><span class="line">accumulate(in, eof, <span class="number">0</span>);   <span class="comment">// 求和</span></span><br><span class="line"></span><br><span class="line"><span class="function">ostream_iterator&lt;T&gt; <span class="title">out</span><span class="params">(os)</span></span>;  <span class="comment">// out将类型为T的输出值写入到输出流os中</span></span><br><span class="line"><span class="function">ostream_iterator&lt;T&gt; <span class="title">out</span><span class="params">(os, d)</span></span>;  <span class="comment">// out将类型为T的输出值写入到输出流os中，每个值后面都额外输出一个d（d是C风格的字符串）</span></span><br><span class="line"><span class="keyword">for</span> (anto e : vec)</span><br><span class="line">    *out++ = e;  <span class="comment">// 直接写out=e;也可以，不过不推荐这么写</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">copy(vec.begin(), vec.end(), out);</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h6 id="反向迭代器"><a href="#反向迭代器" class="headerlink" title="反向迭代器"></a>反向迭代器</h6><ul>
<li>在容器中从尾元素向首元素反向移动的迭代器</li>
<li>其递增、递减的操作是反过来的，即<code>++</code>会向前移动，前也是相对移动方向的</li>
<li>除了<code>forward_list</code>外都支持，使用<code>rbegin(),crbegin()</code>等</li>
</ul>
<h6 id="链表类容器的特殊方法"><a href="#链表类容器的特殊方法" class="headerlink" title="链表类容器的特殊方法"></a>链表类容器的特殊方法</h6><p><code>list、forward_list</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>lst.merge(lst2)</td>
<td>将lst2中的元素合并入lst，要求lst、lst2都必须有序</td>
</tr>
<tr>
<td>lst.merge(lst2, comp)</td>
<td>comp为特定的比较函数</td>
</tr>
<tr>
<td>lst.remove(val)</td>
<td>调用erase删除lst内与val相等的元素</td>
</tr>
<tr>
<td>lst.remove(pred)</td>
<td>调用erase删除lst内使得一元谓词pred成立的元素</td>
</tr>
<tr>
<td>lst.reverse()</td>
<td>反转lst中元素的顺序</td>
</tr>
<tr>
<td>lst.sort()</td>
<td>排序，可以使用comp</td>
</tr>
<tr>
<td>lst.unique()</td>
<td>调用erase去重</td>
</tr>
<tr>
<td>lst.unique(pred)</td>
<td>调用erase去重，重复指的是满足二元谓词pred的元素</td>
</tr>
</tbody>
</table>
</div>
<p><strong>谓词是返回可以转换为bool类型值的函数。元对应参数个数</strong></p>
<h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4><ul>
<li>关联容器支持高效的关键字查询和访问，可以分为有序集合和无序集合两种</li>
<li>map和set的迭代器都不允许修改关键字<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5>| 有序类型 | 说明 |<br>|————|————|<br>|    map    |     关联数组，保存（key, value）对   |<br>|    set      |       只保存关键字      |<br>|multimap|       关键字可重复出现的map|<br>|multiset|      关键字可重复出现的set    |</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>无序类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>unordered_map</td>
<td>用哈希函数组织的map</td>
</tr>
<tr>
<td>unordered_set</td>
<td>用哈希函数组织的set</td>
</tr>
<tr>
<td>unordered_multimap</td>
<td>….</td>
</tr>
<tr>
<td>unordered_multiset</td>
<td>….</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    vec.push_back(i);</span><br><span class="line">    vec.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">set&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(vec.cbegin()</span>, vec.<span class="title">cend</span><span class="params">()</span>)</span>;  <span class="comment">// 10个元素</span></span><br><span class="line"><span class="function">multiset&lt;<span class="keyword">int</span>&gt; <span class="title">imset</span><span class="params">(vec.cbegin()</span>, vec.<span class="title">cend</span><span class="params">()</span>)</span>;  <span class="comment">// 20个元素</span></span><br></pre></td></tr></table></figure>
<h5 id="关键字类型要求"><a href="#关键字类型要求" class="headerlink" title="关键字类型要求"></a>关键字类型要求</h5><ul>
<li>有序元素的关键字类型必须定义元素比较的方法</li>
<li>不支持比较的复杂类型需要自定义比较函数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compareClass1是进行Class1对象比较的函数，定义时需要添加比较函数的函数指针</span></span><br><span class="line"><span class="comment">// 直接使用compareClass1也行，因为函数名会转化为函数指针</span></span><br><span class="line"><span class="comment">// 构造函数也使用比较函数的函数指针</span></span><br><span class="line">set&lt;Class1, decltype(compareClass1)*&gt; cls(compareClass1);</span><br></pre></td></tr></table></figure>
<h6 id="关联容器额外的类型别名"><a href="#关联容器额外的类型别名" class="headerlink" title="关联容器额外的类型别名"></a>关联容器额外的类型别名</h6><pre><code>key_type : 容器的关键字类型
value_type : 对于set，与key_type相同；map则是pair&lt;key, value&gt;
mapped_type : 关键字关联的类型
</code></pre><h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><pre><code>c.insert(v);
c.emplace(args);
c.insert(iter1, iter2);
c.insert(il);  // 花括号列表，返回void
c.insert(iter, v); // 迭代器指示搜索新元素存储应该存储的位置。返回一个迭代器，指向具有给定关键字的元素
c.emplace(iter, args);
</code></pre><p><strong>对于不包含重复关键字的容器，添加单一元素的inert和emplace返回一个pair，指示插入操作是否成功。pair的首元素（first）是一个迭代器，指向具有指定关键字的元素；second是一个bool值，指示元素成功插入还是已经存在于容器中，成功插入为true，否则为false</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto ret = word_count.insert(&#123;<span class="string">"hello"</span>, <span class="number">1</span>&#125;); 尝试插入</span><br><span class="line"><span class="keyword">if</span> (!ret.second) <span class="comment">// 元素已经存在map中</span></span><br><span class="line">    ++ret.first-&gt;second;  <span class="comment">//  ret.first是指向“hello”关键字的迭代器，迭代器指向的second元素是原本"hello"对应的数目，加一即可</span></span><br></pre></td></tr></table></figure></p>
<h5 id="访问元素"><a href="#访问元素" class="headerlink" title="访问元素"></a>访问元素</h5><pre><code>c.find(k);  // 返回指向第一个key为k的迭代器
c.count(k);  // 返回关键字k的个数
c.lower_bound(k); // 返回一个迭代器，指向第一个关键字不小于k的元素
c.upper_bound(k);  // 返回一个迭代器，指向第一个关键字大于k的元素
c.equal_range(k);   //  返回一个迭代器pair，表示关键字等于k的元素的范围。如不存在，则pair的两个成员均为c.end()
</code></pre><p><code>lower_bound</code>和<code>upper_bound</code>只适用于有序容器<br>通过下标访问元素返回左值，既可以读，也可以写回</p>
<h5 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h5><ul>
<li>无序容器在存储上组织为一组桶，每个桶保存0个或多个元素</li>
<li><p>无序容器的性能依赖于哈希函数的质量和桶的大小</p>
<p>  c.bucket_count();  // 正在使用的桶数目<br>  c.max_bucket_count();  // 容器能容纳的最多的桶的数量<br>  c.bucket_size(n);  // 第n个桶中有多少个元素<br>  c.bucket(k);  //  关键字为k的元素在哪个桶中</p>
<p>  local_iterator       // 访问桶中元素的迭代器<br>  const_local_iterator   //  const版本<br>  c.begin(n), c.end(n)   //  桶n元素的首、尾迭代器<br>  c.cbegin(n), c.cend(n)</p>
<p>  c.load_factor();   //  每个桶的平均元素数量，float类型<br>  c.max_load_factor();  // 最大平均桶元素数量，每个桶的平均元素数量大于这个值就需要添加新的桶<br>  c.rehash(n);    //  重组存储，使得bucket_count &gt;= n且bucket_count&gt;size/max_load_factor<br>  c.reserve(n);   //  重组存储，使得c可以保存n个元素且不必rehash</p>
</li>
</ul>
<h6 id="无序容器对关键字的要求"><a href="#无序容器对关键字的要求" class="headerlink" title="无序容器对关键字的要求"></a>无序容器对关键字的要求</h6><ul>
<li>无序容器使用<code>==</code>运算符比较元素</li>
<li>使用<code>hash&lt;key_type&gt;</code>类型的对象生成每个元素的哈希值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">size_t <span class="title">hasher</span><span class="params">(<span class="keyword">const</span> Class1 &amp; cls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;string&gt;()(cls.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">bool <span class="title">eqop</span><span class="params">(<span class="keyword">const</span> Class1 &amp; cls1, <span class="keyword">const</span> Class1 &amp; cls2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cls1.name == cls2.name;</span><br><span class="line">&#125;</span><br><span class="line">using clsset = unordered_set&lt;Class1, hasher, eqop&gt;;</span><br><span class="line"><span class="comment">// 42是桶大小</span></span><br><span class="line"><span class="function">clsset <span class="title">s</span><span class="params">(<span class="number">42</span>, hasher, eqop)</span></span>;</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/02/23/Cpp-Rule-Fragment/" data-id="ckeiowf6y001n4gphws34cgkg" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-H-Index" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/02/21/H-Index/">H-Index</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/02/21/H-Index/">
            <time datetime="2017-02-21T12:30:46.000Z" itemprop="datePublished">2017-02-21</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/OJ/">OJ</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/LeetCode/">LeetCode</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="H-Index-I"><a href="#H-Index-I" class="headerlink" title="H-Index I"></a>H-Index I</h5><h6 id="H-Index"><a href="#H-Index" class="headerlink" title="H-Index"></a>H-Index</h6><p>维基百科上H-Index的定义如下</p>
<pre><code>一个科学家的H-Index为h，如果他一共有N篇文章，其中有h篇文章每一篇都至少有h次引用，其他N-h篇论文每一篇都不超过h次引用
</code></pre><p>比如给定<code>citations = [3, 0, 6, 1, 5]</code>，表示当前研究者有5篇论文，其引用为<code>citations</code>中。因为这些论文中有3篇论文每篇都至少有3次引用，其他2篇都没有3次应用，所以他的H-Index为3。</p>
<h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定某个科学家论文引用数目的数组（非负），输出他的H-Index</p>
<h6 id="解题方案"><a href="#解题方案" class="headerlink" title="解题方案"></a>解题方案</h6><p>首先，一个拥有N篇论文的科学家，他的H-Index不可能会超过N，最大就是N，最小是0。所以如果一篇论文的引用超过N，那么这篇论文的引用在计算H-Index时和N个引用是一样的；如果引用小于N，不妨设置为t，这篇论文只在H-Index小于等于t时有用，如果H-Index大于t，这篇论文不能被计数。</p>
<p>所以，设置一个长度为N+1的辅助数组<code>array</code>，扫描<code>citations</code>数组，对于每个引用t，如果</p>
<ul>
<li>t &lt; N   : array[t]++</li>
<li>t &gt;= N : array[N]++</li>
</ul>
<p>得到数组<code>array</code>数组，从后向前，判断方式为如果$ \sum_{k=i}^{N} array[k] &gt;= i $，那么返回$i$，否则继续向前寻找。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; citations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = citations.size();</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">array</span><span class="params">(N+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (citations[i] &gt; N) array[N]++;</span><br><span class="line">        <span class="keyword">else</span> array[citations[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=N; i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">        sum += array[i];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt;= i) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="H-Index-II"><a href="#H-Index-II" class="headerlink" title="H-Index II"></a>H-Index II</h5><h6 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h6><p>在H-Index的基础上，假设给定的<code>citations</code>数据是按升序排序的。求H-Index</p>
<h6 id="解题方案-1"><a href="#解题方案-1" class="headerlink" title="解题方案"></a>解题方案</h6><p>对于第k篇论文，其引用为<code>citations[k]</code>，引用数大于等于<code>citations[k]</code>的论文数量为<code>N-k</code>，所以对应的H-Index为<code>min(N-k, citations[k])</code>。从前向后考虑，开始时始终有<code>citations[k]&lt;N-k</code>，对应的候选H-Index为<code>citations[k]</code>，到后面有<code>citations[k]&gt;N-k</code>，对应的H-Index为<code>N-k</code>。也就是说候选H-Index经历了先增大后减小的过程，转折过程就是<code>citations[k]</code>第一次大于等于<code>N-k</code>的时候。由于H-Index也限制“其他N-h篇论文每一篇都不超过h次引用”，所以我们的目标就是找到第一个<code>citations[k]&gt;=N-k</code>的序号k，因为此时k对应的候选H-Index为<code>N-k</code>，而k-1对应的候选H-Index肯定小于<code>N-k+1</code>，所以k必对应着最优解。</p>
<p>现在有了O(n)复杂度的算法，考虑到引用数据是严格有序的，所以可以使用类似于二分搜索的方法。此时，可以稍微换个角度思考。对于第k篇论文，其引用为<code>citations[k]</code>，如果<code>N-k&gt;=citations[k]</code>，那么<code>citations[k]</code>就是合格的H-Index，此时应该向右尝试寻找更大的H-Index（因为左边的<code>citations</code>小）；如果<code>N-k&lt;citations[k]</code>，那么<code>citations[k]</code>就不是一个当前合法的H-Index（N-k是），所以要向左尝试寻找。</p>
<p>出现<code>N-k=citations[k]</code>直接结束了。否则必然存在k满足<code>citations[k]&lt;N-k &amp;&amp; citations[k+1]&gt;N-k-1</code>，现在考虑<code>k,k+1,left,right</code>最终的可能关系，如下</p>
<pre><code>| k       k+1    |            k     k+1 |  k    k+1            |  k   k+1                   |                   k    k+1  |
| left     right | left    right        |       left     right |              left    right |  left    right               |
后面两种情况不可能出现，前三种情况的最终结果都是 `N-left`
</code></pre><p>再来考虑停止条件，两种情况<code>left=right</code>或者<code>left+1=right</code>。</p>
<ol>
<li>当第一种情况出现，<code>mid=left</code>，此时如果<code>citations[mid] &gt; N-mid</code>，那么<code>mid=left</code>就是最佳位置，H-Index为<code>N-mid</code>；否则最佳位置在left后一位，此时将<code>left=mid+1</code>后，<code>N-left</code>就是最佳H-Index。</li>
<li>当第二种情况出现，<code>left+1=right</code>，<code>mid=left</code>，此时如果<code>citations[mid] &gt; N-mid</code>，那么<code>mid=left</code>就是最佳位置，H-Index为<code>N-mid</code>；否则，设置<code>left=mid+1</code>，回到了第一种情况。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N=citations.size(), left=<span class="number">0</span>, right=N-<span class="number">1</span>, ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (citations[mid] == N-mid) <span class="keyword">return</span> N-mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (citations[mid] &gt; N-mid) right = mid-<span class="number">1</span>; <span class="comment">// 向左寻找</span></span><br><span class="line">        <span class="keyword">else</span> left = mid+<span class="number">1</span>;                                     <span class="comment">// 向右寻找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> N-left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/02/21/H-Index/" data-id="ckeiowf7q003e4gphn52gg307" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Partition" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/02/21/Partition/">Partition</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/02/21/Partition/">
            <time datetime="2017-02-21T05:38:18.000Z" itemprop="datePublished">2017-02-21</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/OJ/">OJ</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/LeetCode/">LeetCode</a>, <a class="tag-link" href="/tags/Sort/">Sort</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="partition函数"><a href="#partition函数" class="headerlink" title="partition函数"></a>partition函数</h5><p><code>partition</code>函数是快速排序的核心部分，选定一个基准，然后将大于和小于基准的数分别放置于基准的两边，有多种实现方式，以下是参考</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start, end表明作用范围</span></span><br><span class="line"><span class="comment">// pivotIndex表示基准的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp; A, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start, j = end;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = rand() % (end-start+<span class="number">1</span>) + start; <span class="comment">// 随机选择基准位置</span></span><br><span class="line">    <span class="keyword">int</span> pivot = A[pivotIndex];</span><br><span class="line">    <span class="comment">// 把基准换到最后</span></span><br><span class="line">    swap&lt;<span class="keyword">int</span>&gt;(A[end], A[pivotIndex]);</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; A[i] &lt; pivot) ++i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; A[j] &gt;= pivot) --j;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) swap&lt;<span class="keyword">int</span>&gt;(A[i], A[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    swap&lt;<span class="keyword">int</span>&gt;(A[end], A[i]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再提供另一种实现方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arr[]为数组，start、end分别为数组第一个元素和最后一个元素的索引</span></span><br><span class="line"><span class="comment">// povitIndex为数组中任意选中的数的索引</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> pivotIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[pivotIndex];</span><br><span class="line">    swap(arr[pivotIndex], arr[end]);</span><br><span class="line">    <span class="keyword">int</span> storeIndex = start;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; end; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; pivot) &#123;</span><br><span class="line">            swap(arr[i], arr[storeIndex]);</span><br><span class="line">            ++storeIndex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr[storeIndex], arr[end]);</span><br><span class="line">    <span class="keyword">return</span> storeIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Partition函数的应用"><a href="#Partition函数的应用" class="headerlink" title="Partition函数的应用"></a>Partition函数的应用</h5><h6 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = partition(A, start, end);</span><br><span class="line">    <span class="keyword">if</span> (mid-start &gt; <span class="number">2</span>) quick_sort(A, start, mid-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (end-mid &gt; <span class="number">2</span>) quick_sort(A, mid+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h6><p>给定未排序数组A，求排好序的数组中的第k个大个数。因为上面的<code>partition</code>函数是左小右大，所以我们考虑寻找第<code>A.size()-k</code>小的数。<br>思路是<strong>调用partition函数，返回基准位置，如果基准位置正好是k，那么返回其对应的值<br>否则，如果基准在k左侧，则考虑基准右边的元素；否则考虑左边的元素。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>, end=A.size()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = partition(A, start, end);</span><br><span class="line">        <span class="keyword">if</span> (mid == k-<span class="number">1</span>) <span class="keyword">return</span> A[k-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (mid &lt; k-<span class="number">1</span>) start = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> end = mid-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/02/21/Partition/" data-id="ckeiowf9p006u4gph6k2czo8i" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Sliding-Window-Maximum" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/02/16/Sliding-Window-Maximum/">Sliding Window Maximum</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/02/16/Sliding-Window-Maximum/">
            <time datetime="2017-02-16T07:31:45.000Z" itemprop="datePublished">2017-02-16</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/OJ/">OJ</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Sliding-window/">Sliding window</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定数组<code>nums</code>，和滑动窗口的长度<code>k</code>，输出滑动窗口一次一个元素地向前滑动时每一时刻滑动窗口内的最大值。要求在<code>O(n)</code>复杂度内完成。</p>
<pre><code>nums = [1,3,-1,-3,5,3,6,7],  k = 3
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
---------------               -----
output [3,3,5,5,6,7]
</code></pre><h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>滑动窗口内添加新元素简单，但是删除时比较麻烦，所以简单使用堆的思路不行。</p>
<p>双端队列对滑动窗口有比较好的模拟，其尾部、头部都可以添加和删除元素（也有受限的应用版本）。</p>
<p>本题使用的方法也称作<strong>单调队列</strong>，其定义如下：</p>
<pre><code>队列中元素之间的关系具有单调性，而且，队首和队尾都可以进行出队操作，只有队尾可以进行入队操作
</code></pre><p>以单调不减队列为例，队列内的元素$(e_1,e_2,…,e_n)$存在$(e_1\le e_2\le…\le e_n)$的关系，所以队首元素$e_1$一定是最小的元素。与优先队列不同的是，<strong>当有一个新的元素$e$入队时，先要将队尾的所有大于$e$的元素弹出，以保证单调性，再让元素$e$入队尾</strong>。</p>
<p>所以本题的方法描述如下：</p>
<ul>
<li>队列元素如果超过了k的限制，那么从队头剔除</li>
<li>从队尾起，如果队尾的元素小于当前需要添加的元素，那么剔除队尾元素（它不可能成为最大值），直到队尾元素大于等于当前需要添加的元素。</li>
<li>此时，队列是非递减队列，所以队头元素就是最大值</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; ret;</span><br><span class="line">    deque&lt;<span class="keyword">int</span>&gt; window;</span><br><span class="line">    <span class="keyword">if</span> (nums.size()&lt;<span class="number">1</span> || k&lt;=<span class="number">0</span>) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!window.empty() &amp;&amp; window.front()&lt;i-k+<span class="number">1</span>)</span><br><span class="line">            window.pop_front();</span><br><span class="line">        <span class="keyword">while</span> (!window.empty() &amp;&amp; nums[window.back()]&lt;nums[i])</span><br><span class="line">            window.pop_back();</span><br><span class="line">        window.push_back(i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k-<span class="number">1</span>) ret.push_back(nums[window.front()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/02/16/Sliding-Window-Maximum/" data-id="ckeiowfaf00874gphb8tfc98z" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Java-Future" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/01/18/Java-Future/">Java Future</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/01/18/Java-Future/">
            <time datetime="2017-01-18T02:25:54.000Z" itemprop="datePublished">2017-01-18</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Dev/">Dev</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Java/">Java</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="Callable与Runnable"><a href="#Callable与Runnable" class="headerlink" title="Callable与Runnable"></a>Callable与Runnable</h6><p>Java中的多线程实现可以通过继承<code>Thread</code>或者实现<code>Runnable</code>接口来实现，但是这两种方法都不能将执行结果取回。<code>Runnable</code>接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>run()</code>方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p>
<p><code>Callable</code>位于java.util.concurrent包下，它也是一个泛型接口，在它里面也只声明了一个方法<code>call()</code>，返回的类型就是传递进来的<code>V</code>类型：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Callable</code>一般情况下是配合<code>ExecutorService</code>来使用的，在<code>ExecutorService</code>接口中声明了若干个<code>submit</code>方法的重载版本：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure></p>
<p>这三个方法中，常用的是第一个和第三个。</p>
<hr>
<h6 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h6><p><code>Future</code>是一个接口，位于<code>java.util.concurrent</code>包下，定义如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Future</code>就是对于具体的<code>Runnable</code>或者<code>Callable</code>任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过<code>get</code>方法获取执行结果，此方法会阻塞直到任务返回结果。上述方法中：</p>
<hr>
<p>1 <code>cancel</code>方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数<code>mayInterruptIfRunning</code>表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论<code>mayInterruptIfRunning</code>为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若<code>mayInterruptIfRunning</code>设置为true，则返回true，若<code>mayInterruptIfRunning</code>设置为false，则返回false；如果任务还没有执行，则无论<code>mayInterruptIfRunning</code>为true还是false，肯定返回true</p>
<p>2 <code>isCancelled</code>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true</p>
<p>3 <code>isDone</code>方法表示任务是否已经完成，若任务完成，则返回true</p>
<p>4 <code>get()</code>方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回</p>
<p>5 <code>get(long timeout, TimeUnit unit)</code>用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null</p>
<hr>
<h6 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h6><p>由于<code>Future</code>是个接口，所以其不能实例化，<code>FutureTask</code>应运而生，也是<code>Future</code>接口的唯一实现类。</p>
<p>FutureTask类实现了RunnableFuture接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>RunnableFuture</code>继承了<code>Runnable</code>接口和<code>Future</code>接口，而<code>FutureTask</code>实现了<code>RunnableFuture</code>接口，关系如图所示。所以它既可以作为<code>Runnable</code>被线程执行，又可以作为<code>Future</code>得到<code>Callable</code>的返回值。</p>
<center>![关系图](http://wx1.sinaimg.cn/mw690/9bcfe727ly1fbumuzrzbaj20hz0dhq31.jpg)</center>

<p>FutureTask提供了2个构造器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h6><p>使用<code>Callable + Future</code>获取执行结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">Task task = <span class="keyword">new</span> Task();</span><br><span class="line">Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">executor.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"task运行结果"</span>+result.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>使用<code>Callable + FutureTask</code>获取执行结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">Task task = <span class="keyword">new</span> Task();</span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line"></span><br><span class="line">executor.submit(futureTask);</span><br><span class="line">executor.shutdown();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"task运行结果"</span>+futureTask.get());</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/01/18/Java-Future/" data-id="ckeiowf8400464gphqvj79si5" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Java-Thread-Pool" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/01/17/Java-Thread-Pool/">Java Thread Pool</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/01/17/Java-Thread-Pool/">
            <time datetime="2017-01-17T06:43:08.000Z" itemprop="datePublished">2017-01-17</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Dev/">Dev</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Java/">Java</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><hr>
<h6 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h6><p><code>java.uitl.concurrent.ThreadPoolExecutor</code>类是线程池中最核心的一个类，继承自<code>AbstractExecutorService</code>，<code>AbstractExecutorService</code>是一个抽象类，它实现了ExecutorService接口。<code>ThreadPoolExecutor</code>的构造方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,<span class="keyword">int</span> maximumPoolSize,<span class="keyword">long</span> keepAliveTime,TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面三个构造器都是调用的第四个构造器进行的初始化工作，参数介绍如下：</p>
<hr>
<p>1 <code>corePoolSize</code> : 核心池的大小。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到<code>corePoolSize</code>后，就会把到达的任务放到缓存队列当中。（正式工）<br>2 <code>maximumPoolSize</code> : 线程池最大线程数，表示在线程池中最多能创建多少个线程。最大线程数意味着当核心池不够用时可以额外开辟新线程，但这些新加入的线程在空闲时可以销毁（临时工）。<br>3 <code>keepAliveTime</code> : 线程没有任务执行时最多保持多久时间会终止。默认情况下，只有当线程池中的线程数大于<code>corePoolSize</code>时，<code>keepAliveTime</code>才会起作用，直到线程池中的线程数不大于<code>corePoolSize</code>，即当线程池中的线程数大于<code>corePoolSize</code>时，如果一个线程空闲的时间达到<code>keepAliveTime</code>，则会终止，直到线程池中的线程数不超过<code>corePoolSize</code>。但是如果调用了<code>allowCoreThreadTimeOut(boolean)</code>方法，在线程池中的线程数不大于<code>corePoolSize</code>时，<code>keepAliveTime</code>参数也会起作用，直到线程池中的线程数为0。<br>4 <code>unit</code> : <code>keepAliveTime</code>的时间单位. 包括</p>
<pre><code>TimeUnit.DAYS
TimeUnit.HOURS
TimeUnit.MINUTES
TimeUnit.SECONDS
TimeUnit.MILLISECONDS
TimeUnit.MICROSECONDS
TimeUnit.NANOSECONDS
</code></pre><p>5 <code>workQueue</code> : 一个阻塞队列，用来存储等待执行的任务。可以是如下三种，其中<code>ArrayBlockingQueue</code>和<code>PriorityBlockingQueue</code>使用较少，一般使用<code>LinkedBlockingQueue</code>和<code>Synchronous</code>。线程池的排队策略与BlockingQueue有关。</p>
<pre><code>ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小
LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE
SynchronousQueue：不会保存提交的任务，而是将直接新建一个线程来执行新来的任务
PriorityBlockingQueue
</code></pre><p>6 <code>threadFactory</code> ：线程工厂，主要用来创建线程<br>7 <code>handler</code> ：表示当拒绝处理任务时的策略，可以是</p>
<pre><code>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常
ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常
ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
</code></pre><hr>
<h6 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h6><p><code>Executor</code>是一个顶层接口，在它里面只声明了一个方法<code>execute(Runnable)</code>，返回值为void，参数为<code>Runnable</code>类型，从字面意思可以理解，就是用来执行传进去的任务的。</p>
<p><code>ExecutorService</code>接口继承了<code>Executor</code>接口，并声明了一些方法：<code>submit</code>、<code>invokeAll</code>、<code>invokeAny</code>以及<code>shutDown</code>等。</p>
<p>抽象类<code>AbstractExecutorService</code>实现了<code>ExecutorService</code>接口，基本实现了<code>ExecutorService</code>中声明的所有方法。</p>
<p><code>ThreadPoolExecutor</code>继承了类<code>AbstractExecutorService</code>。在<code>ThreadPoolExecutor</code>类中有几个非常重要的方法：</p>
<hr>
<p>1 <code>execute()</code> : <code>execute()</code>方法实际上是<code>Executor</code>中声明的方法，在<code>ThreadPoolExecutor</code>进行了具体的实现，这个方法是<code>ThreadPoolExecutor</code>的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p>
<p>2 <code>submit()</code> : <code>submit()</code>方法是在<code>ExecutorService</code>中声明的方法，在<code>AbstractExecutorService</code>就已经有了具体的实现，在<code>ThreadPoolExecutor</code>中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和<code>execute()</code>方法不同，它能够返回任务执行的结果(<code>Future</code>)</p>
<p>3 <code>shutdown()</code> : 关闭线程池，不再接受新的任务，等到所有线程完成任务关闭线程池</p>
<p>4 <code>shutdownNow()</code> : 立即结束所有线程，关闭线程池</p>
<hr>
<h5 id="线程池实现原理"><a href="#线程池实现原理" class="headerlink" title="线程池实现原理"></a>线程池实现原理</h5><hr>
<h6 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h6><p><code>ThreadPoolExecutor</code>中定义了一个<code>volatile</code>变量<code>volatile int runState</code>表示当前线程池的状态，它是一个volatile变量用来保证线程之间的可见性。还有几个<code>static final</code>变量表示<code>runState</code>可能的几个取值：</p>
<pre><code>static final int RUNNING    = 0;
static final int SHUTDOWN   = 1;
static final int STOP       = 2;
static final int TERMINATED = 3;
</code></pre><p>创建线程池后，初始时，线程池处于<code>RUNNING</code>状态。<br>调用了<code>shutdown()</code>方法，则线程池处于<code>SHUTDOWN</code>状态，此时线程池不能够接受新的任务，它会等待所有任务执行完毕。<br>调用了<code>shutdownNow()</code>方法，则线程池处于<code>STOP</code>状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务。<br>当线程池处于<code>SHUTDOWN</code>或<code>STOP</code>状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<code>TERMINATED</code>状态。</p>
<hr>
<h6 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h6><p><code>ThreadPoolExecutor</code>类中其他的一些比较重要成员变量如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;  <span class="comment">//任务缓存队列，用来存放等待执行的任务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">//线程池的主要状态锁，对线程池状态（比如线程池大小、runState等）的改变都要使用这个锁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();  <span class="comment">//用来存放工作集</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span>  keepAliveTime;    <span class="comment">//线程存货时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;   <span class="comment">//是否允许为核心线程设置存活时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   corePoolSize;     <span class="comment">//核心池的大小（即线程池中的线程数目大于这个参数时，提交的任务会被放进任务缓存队列）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   maximumPoolSize;   <span class="comment">//线程池最大能容忍的线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span>   poolSize;       <span class="comment">//线程池中当前的线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler; <span class="comment">//任务拒绝策略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;   <span class="comment">//线程工厂，用来创建线程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;   <span class="comment">//用来记录线程池中曾经出现过的最大线程数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;   <span class="comment">//用来记录已经执行完毕的任务个数</span></span><br></pre></td></tr></table></figure></p>
<p>任务提交执行依靠<code>execute()</code>方法，<code>submit()</code>也是提交任务的方法，但是它也是调用了<code>execute()</code>方法。<code>execute()</code>方法处理方法的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，判断提交的任务<code>command</code>是否为<code>null</code>，若是<code>null</code>，则抛出空指针异常。接着还是一个判断语句，如果线程池中当前线程数不小于核心池大小，直接执行判断语句中的代码；否则执行<code>addIfUnderCorePoolSize(command)</code>，如果返回false，则继续执行判断语句中的代码，否则整个方法就直接执行完毕了。</p>
<p>第二层判断语句中，如果当前线程池处于RUNNING状态，则将任务放入任务缓存队列(<code>workQueue.offer(command)</code>就是将任务放入缓存队列)；如果当前线程池不处于RUNNING状态或者任务放入缓存队列失败，则执行<code>addIfUnderMaximumPoolSize(command)</code>，如果执行<code>addIfUnderMaximumPoolSize</code>方法失败，则执行<code>reject()</code>方法进行任务拒绝处理。</p>
<p>如果说当前线程池处于RUNNING状态且将任务放入任务缓存队列成功，则继续执行第三层判断语句<code>if (runState != RUNNING || poolSize == 0)</code>，这句判断是为了防止在将此任务添加进任务缓存队列的同时其他线程突然调用<code>shutdown</code>或者<code>shutdownNow</code>方法关闭了线程池的一种应急措施，如果是这样就需要应急处理<code>ensureQueuedTaskHandled(command)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addIfUnderCorePoolSize</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)</span><br><span class="line">            t = addThread(firstTask);        <span class="comment">//创建线程去执行firstTask任务</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    t.start();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到的<code>addIfUnderCorePoolSize</code>方法，由字面意思是当低于核心池大小时执行的方法，因为涉及线程池的变化，所以需要加锁。if语句判断当前线程池中的线程数目是否小于核心池大小，虽然前面在<code>execute()</code>方法中已经判断过了，但是没有加锁。因此可能在<code>execute</code>方法判断的时候<code>poolSize</code>小于<code>corePoolSize</code>，而判断完之后，在其他线程中又向线程池提交了任务，就可能导致<code>poolSize</code>不小于<code>corePoolSize</code>了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Thread <span class="title">addThread</span><span class="params">(Runnable firstTask)</span> </span>&#123;</span><br><span class="line">    Worker w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    Thread t = threadFactory.newThread(w);  <span class="comment">//创建一个线程，执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        w.thread = t;            <span class="comment">//将创建的线程的引用赋值为w的成员变量</span></span><br><span class="line">        workers.add(w);</span><br><span class="line">        <span class="keyword">int</span> nt = ++poolSize;     <span class="comment">//当前线程数加1</span></span><br><span class="line">        <span class="keyword">if</span> (nt &gt; largestPoolSize)</span><br><span class="line">            largestPoolSize = nt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于<code>runState</code>的判断也是类似的。满足条件的话，通过<code>addThread</code>方法创建线程，创建成功则启动线程。在<code>addThread</code>方法中，首先用提交的任务创建了一个<code>Worker</code>对象，然后调用线程工厂<code>threadFactory</code>创建了一个新的线程<code>t</code>，然后将线程<code>t</code>的引用赋值给了<code>Worker</code>对象的成员变量<code>thread</code>，接着通过<code>workers.add(w)</code>将<code>Worker</code>对象添加到工作集当中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            runTask(task);</span><br><span class="line">            task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Worker</code>类实现了<code>Runnable</code>接口，在其<code>run</code>函数中首先执行的是通过构造器传进来的任务<code>firstTask</code>，在调用<code>runTask()</code>执行完<code>firstTask</code>之后，在<code>while</code>循环里面不断通过<code>getTask()</code>去取新的任务来执行，<code>getTask</code>是<code>ThreadPoolExecutor</code>类中的方法，从任务缓存队列中取。</p>
<p>任务提交后，线程池的处理策略总结如下：</p>
<ul>
<li>如果当前线程池中的线程数目小于<code>corePoolSize</code>，则每来一个任务，就会创建一个线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目&gt;=<code>corePoolSize</code>，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；</li>
<li>如果当前线程池中的线程数目达到<code>maximumPoolSize</code>，则会采取任务拒绝策略进行处理；</li>
<li>如果线程池中的线程数量大于<code>corePoolSize</code>时，如果某线程空闲时间超过<code>keepAliveTime</code>，线程将被终止，直至线程池中的线程数目不大于<code>corePoolSize</code>；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过<code>keepAliveTime</code>，线程也会被终止。</li>
</ul>
<hr>
<h6 id="线程初始化"><a href="#线程初始化" class="headerlink" title="线程初始化"></a>线程初始化</h6><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化一个核心线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prestartCoreThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addIfUnderCorePoolSize(<span class="keyword">null</span>); <span class="comment">//注意传进去的参数是null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化所有核心线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">prestartAllCoreThreads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (addIfUnderCorePoolSize(<span class="keyword">null</span>))<span class="comment">//注意传进去的参数是null</span></span><br><span class="line">        ++n;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面传入参数为null，最后执行线程会阻塞在<code>getTask</code>方法中的<code>workQueue.take()</code>，等待直到任务队列中有任务。</p>
<hr>
<h6 id="容量的动态调整"><a href="#容量的动态调整" class="headerlink" title="容量的动态调整"></a>容量的动态调整</h6><pre><code>setCorePoolSize：设置核心池大小
setMaximumPoolSize：设置线程池最大能创建的线程数目大小
</code></pre><hr>
<h5 id="线程池应用"><a href="#线程池应用" class="headerlink" title="线程池应用"></a>线程池应用</h5><hr>
<h6 id="ThreadPoolExecutor-1"><a href="#ThreadPoolExecutor-1" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存任务队列大小为8，核心池大小为5</span></span><br><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">200</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">8</span>));</span><br><span class="line">executor.execute(myTask);</span><br><span class="line"><span class="comment">// myTask 应该是显示了Runnable的类的对象</span></span><br><span class="line">executor.shutdown();</span><br></pre></td></tr></table></figure>
<hr>
<h6 id="推荐实现"><a href="#推荐实现" class="headerlink" title="推荐实现"></a>推荐实现</h6><p>Java官方不推荐直接使用<code>ThreadPoolExecutor</code>，而是使用<code>Executors</code>类中提供的几个静态方法来创建线程池。分别是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Executors.newCachedThreadPool();        <span class="comment">//创建一个缓冲池，缓冲池容量大小为Integer.MAX_VALUE</span></span><br><span class="line">Executors.newSingleThreadExecutor();   <span class="comment">//创建容量为1的缓冲池</span></span><br><span class="line">Executors.newFixedThreadPool(<span class="keyword">int</span>);    <span class="comment">//创建固定容量大小的缓冲池</span></span><br><span class="line">Executors.newScheduledThreadPool(<span class="keyword">int</span>); <span class="comment">//创建固定容量的延迟连接池</span></span><br></pre></td></tr></table></figure></p>
<p>这三种方法也都是调用了<code>ThreadPoolExecutor</code>，支持参数设定不同而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">pool.execute(t1);</span><br><span class="line">pool.execute(t2);</span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line">ExecutorService pool = Executors.newSingleThreadExecutor();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">pool.execute(t1);</span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line">ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">pool.execute(t1);</span><br><span class="line">pool.execute(t2);</span><br><span class="line">pool.shutdown();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread t3 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">pool.execute(t1);</span><br><span class="line"></span><br><span class="line">pool.schedule(t2, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">pool.schedule(t3, <span class="number">10</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">pool.shutdown();</span><br></pre></td></tr></table></figure>
<p><code>newFixedThreadPool</code>创建的线程池<code>corePoolSize</code>和<code>maximumPoolSize</code>值是相等的，它使用的<code>LinkedBlockingQueue</code>；</p>
<p><code>newSingleThreadExecutor</code>将<code>corePoolSize</code>和<code>maximumPoolSize</code>都设置为1，也使用的<code>LinkedBlockingQueue</code>；</p>
<p><code>newCachedThreadPool</code>将<code>corePoolSize</code>设置为0，将<code>maximumPoolSize</code>设置为<code>Integer.MAX_VALUE</code>，使用的<code>SynchronousQueue</code>，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。</p>
<hr>
<p>感谢<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html" target="_blank" rel="noopener">原文</a></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/01/17/Java-Thread-Pool/" data-id="ckeiowf8500494gphwjx7w5py" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Boosting" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/01/13/Boosting/">Boosting</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/01/13/Boosting/">
            <time datetime="2017-01-13T11:50:41.000Z" itemprop="datePublished">2017-01-13</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/machine-learning/">machine learning</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>Boosting是集成学习中的典型代表之一，与随机森林的不同在于：Boosting中的个体学习器之间有着强依赖、必须串行生成。Boosting族最典型的算法是AdaBoost。<b>AdaBoost每轮迭代尝试调整训练数据的分布以使得下一轮的基学习器能够修正现有学习器的一些错误</b>。Boosting算法从“偏差-方差”的角度看更加专注于降低偏差。</p>
<hr>
<h5 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h5><hr>
<h6 id="指数损失函数"><a href="#指数损失函数" class="headerlink" title="指数损失函数"></a>指数损失函数</h6><p>AdaBoost可以理解成基学习器的叠加，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
H(x)=\sum_{t=1}^T \alpha_th_t(x)
\end{aligned}</script><p>来最小化损失函数</p>
<script type="math/tex; mode=display">
\begin{aligned}
l_{exp}(H|\mathcal{D})&=E_{x\sim D}[e^{-f(x)H(x)}] \\
&= E_{x\sim D}[e^{-H(x)}P(f(x)=1|x) + e^{H(x)}P(f(x)=-1|x)]
\end{aligned}</script><p>其中$\mathcal{D}$表示数据集$D$的分布，也就是每个样本出现的概率。要选取最佳的$H(x)$使得损失函数$l$最小。这里假设原始数据集的标签$y_i\in \lbrace -1,+1 \rbrace$，$f(x)$是真实函数。自然地考虑$l_{exp}(H|\mathcal{D})$对$H(x)$求偏导数并且设置为0</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial l_{exp}(H|\mathcal{D})}{\partial H(x)} &= -e^{-H(x)}P(f(x)=1|x) + e^{H(x)}P(f(x)=-1|x) = 0 \\
H(x) &= \frac{1}{2} ln \frac{P(f(x)=1|x)}{P(f(x)=-1|x)}
\end{aligned}</script><p>其中，$H(x)$与真实函数输出一致，那么$-f(x)H(x)$为-1；反之$-f(x)H(x)=1$，所以最小化上述损失函数的意义就是希望$H(x)$与真实函数$f(x)$输出尽量一致。最后，考虑到问题本质，$sign \left( \frac{1}{2} ln \frac {P(f(x)=1|x)} {P(f(x)=-1|x)}\right) $还需要</p>
<script type="math/tex; mode=display">
sign(H(x)) = sign \left( \frac{1}{2} ln \frac {P(f(x)=1|x)} {P(f(x)=-1|x)} \right) = \begin{cases}
 1 & {P(f(x)=1|x) \ge P(f(x)=-1|x)} \\
-1 & {P(f(x)=1|x) < P(f(x)=-1|x)}
\end{cases}</script><p>表明$sign(H(x))$达到了贝叶斯最优错误率，也就是：若指数损失函数最小化，那么分类错误率最小化。</p>
<hr>
<h6 id="权重更新"><a href="#权重更新" class="headerlink" title="权重更新"></a>权重更新</h6><p>AdaBoost中，第一个分类器$h_1$通过直接将基学习算法用于初始数据分布$\mathcal{D}$而得，此后迭代地生成$h_t,\alpha_t$。当基分类器$h_t$基于分布$\mathcal{D}_t$产生后，$h_t$对应的权重$\alpha_t$应该使得$\alpha_th_t$最小化指数损失函数</p>
<script type="math/tex; mode=display">
\begin{aligned}
l_{exp}(\alpha_th_t|\mathcal{D}_t) &= E_{x\sim \mathcal{D}_t} \left[ e^{-f(x)\alpha_th_t(x)} \right] \\
&= E_{x\sim \mathcal{D}_t} \left[ e^{-\alpha_t}I(f(x)=h_t(x)) + e^{\alpha_t}I(f(x)\neq h_t(x)) \right] \\
&= e^{-\alpha_t}P_{x\sim \mathcal{D}_t}(f(x)=h_t(x)) + e^{\alpha_t}P_{x\sim \mathcal{D}_t}(f(x)\neq h_t(x)) \\
&= e^{-\alpha_t}(1-\epsilon_t) + e^{\alpha_t}\epsilon_t
\end{aligned}</script><p>其中，$\epsilon_t=P_{x\sim \mathcal{D}_t}(f(x)\neq h_t(x))$。上式对$\alpha_t$求导并使之为0可得</p>
<script type="math/tex; mode=display">
\begin{aligned}
\alpha_t=\frac{1}{2} ln\left( \frac{1-\epsilon_t}{\epsilon_t} \right)
\end{aligned}</script><hr>
<h6 id="样本分布调整"><a href="#样本分布调整" class="headerlink" title="样本分布调整"></a>样本分布调整</h6><p>获取$H_{t-1}$之后将样本分布进行调整，使下一轮的基学习器$h_t$能纠正$H_{t-1}$的错误，依旧采用最小化指数损失函数的思想，有</p>
<script type="math/tex; mode=display">
\begin{aligned}
l_{exp}(H_{t-1}+h_t | \mathcal{D}) &= E_{x\sim \mathcal{D}} [e^{ -f(x) ( H_{t-1}(x)+h_t(x) ) }] \\
&= E_{x\sim \mathcal{D}} [ e^{-f(x)H_{t-1}} e^{-f(x)h_t(x)} ] \\
\end{aligned}</script><p>对上式中的$e^{-f(x)h_t(x)}$做二阶泰勒展开，近似为</p>
<script type="math/tex; mode=display">
\begin{aligned}
l_{exp}(H_{t-1}+h_t|\mathcal{D}) &\simeq E_{x\sim \mathcal{D}}\left[e^{-f(x)H_{t-1}(x)} \left( 1-f(x)h_t(x)+\frac{f(x)^2h_t(x)^2}{2} \right) \right] \\
&= E_{x\sim \mathcal{D}}\left[e^{-f(x)H_{t-1}(x)} \left( \frac{3}{2}-f(x)h_t(x) \right)\right] \\
\end{aligned}</script><p>因为$\frac{3}{2}-f(x)h_t(x)&gt;0$并且$f(x)H_{t-1}(x)$也是确定的值，所以最小化上式也就是等价于下式，也可以做一点变化变体</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\to \arg\max_{h} E_{x\sim \mathcal{D}}\left[e^{-f(x)H_{t-1}(x)} f(x)h(x)\right] \\
&\to \arg\max_{h} E_{x\sim \mathcal{D}}\left[\frac{e^{-f(x)H_{t-1}(x)}} {E_{x\sim \mathcal{D}} \left[ e^{-f(x)H_{t-1}(x) } \right] } f(x)h(x)\right]
\end{aligned}</script><p>因为$E_{x\sim \mathcal{D}}e^{-f(x)H_{t-1}(x)}$是一个常数，令$\mathcal{D}_t$表示一个分布</p>
<script type="math/tex; mode=display">
\begin{aligned}
D_t(x)=\mathcal{D}(x) \frac { e^{-f(x)H_{t-1}(x)} }  { E_{x\sim \mathcal{D}} \left[ e^{ -f(x)H_{t-1}(x) } \right] }
\end{aligned}</script><p>根据数学期望的定义，这等价于令</p>
<script type="math/tex; mode=display">
\begin{aligned}
h_t(x) &= \arg\max_{h} E_{x\sim \mathcal{D}}\left[\frac{e^{-f(x)H_{t-1}(x)}} {E_{x\sim \mathcal{D}} [e^{-f(x)H_{t-1}(x)}]} f(x)h(x)\right] \\
&= \arg\max_{h} E_{x\sim \mathcal{D}_t} [f(x)h(x)]
\end{aligned}</script><p>由于$f(x),h(x)$都只能取$\lbrace -1,1 \rbrace$，所以上式中的优化问题也可以变成</p>
<script type="math/tex; mode=display">
\begin{aligned}
h_t(x) = \arg\min_{h} E_{x\sim \mathcal{D}_t} [I(f(x) \neq h(x))]
\end{aligned}</script><p>所以理想的$h_t$将在分布$\mathcal{D}_t$下最小化分类误差，因此弱分类器将基于$\mathcal{D}_t$来训练，且针对$\mathcal{D}_t$的分类误差应该不小于0.5（二分类至少要比猜的强）。根据上面的推导，分布之间的关系应该是</p>
<script type="math/tex; mode=display">
\begin{aligned}
\mathcal{D}_{t+1}(x) &= \mathcal{D}(x) \frac{e^{-f(x)H_{t-1}(x)}} { E_{x\sim \mathcal{D}} [ e^{ -f(x) H_{t-1}(x) } ] } \\
&= \mathcal{D}(x) \frac{ e^{-f(x)H_{t-1}(x)}  e^{-f(x) \alpha_t h_t(x)} } {E_{x\sim \mathcal{D}} [ e^{ -f(x) H_{t-1}(x) } ] } \\
&= \mathcal{D}_{t}(x) e^{-f(x) \alpha_t h_t(x)} \frac{E_{x\sim \mathcal{D}} [ e^{-f(x)H_{t-1}(x)} ]} {E_{x\sim \mathcal{D}} [e^{-f(x)H_{t}(x)}]}
\end{aligned}</script><p>至此，AdaBoost算法流程介绍完毕，下面是其算法描述</p>
<hr>
<p>输入：训练集$D=\lbrace (x_1,y_1),…,(x_m,y_m) \rbrace$；基学习算法$\gamma$；训练轮数$T$</p>
<hr>
<ol>
<li>$\mathcal{D}_{1}(x)=\frac{1}{m}$. //初始为均匀分布</li>
<li>$for\;t=1,…,T$</li>
<li>$h_t=\gamma(D,\mathcal{D}_{t})$.</li>
<li>$\epsilon_t=P_{x\sim \mathcal{D}_{t} }(h_t(x)\neq f(x))$.</li>
<li>$if\;\epsilon_t&gt;0.5\;then\;break\;$. // 错误率大于0.5的不要，至少比随机猜测好</li>
<li>$\alpha_t=\frac{1}{2}ln \frac {1-\epsilon_t}{\epsilon_t}$. //权重更新</li>
<li>$\mathcal{D}_{t+1}=\mathcal{D}_{t} \frac{exp(-\alpha_t f(x) h_t(x))} {Z_t}$. //分布调整</li>
</ol>
<hr>
<p>输出：$H(x)=sign\left( \sum_{t=1}^T \alpha_t h_t(x) \right)$</p>
<hr>
<p>由算法描述的第三行可以看出，基学习算法需要能够对特定的数据分布进行学习，可以通过两种方法实现：</p>
<ul>
<li>重赋权法：每一轮训练过程中，根据样本分布为每个样本重新赋予一个权重。也可以是在计算误差率的时候，为每个样本对应的项加上权重。</li>
<li>重采样法：每一轮训练过程中，根据样本分布进行重采样，用采样的样本集训练数据。（特别用于样本无法接受权值的基算法场景，此方法还可以在基学习器错误率大于0.5时不用退出，创新采样开始）</li>
</ul>
<h5 id="Boosting-Tree"><a href="#Boosting-Tree" class="headerlink" title="Boosting Tree"></a>Boosting Tree</h5><ul>
<li>提升树被认为是统计学习中性能最好的方法之一</li>
<li>与RF类似，提升树也可以通过线性叠加基学习器的方法获得准确率的提升</li>
<li>基学习器为二叉树，分为分类、回归两种</li>
</ul>
<h6 id="提升树"><a href="#提升树" class="headerlink" title="提升树"></a>提升树</h6><p>提升树的模型可以表示为<script type="math/tex">f_M(x)=\sum_{m=1}^MT(x;\theta_m)</script>其中，$M$为树的个数，$T(x;\theta_m)$表示决策树，$\theta_m$为决策树的参数。</p>
<p>步骤：首先确定初始提升树$f_0(x)=0$，第$m$步的模型是<script type="math/tex">f_m(x)=f_{m-1}(x)+T(x;\theta_m)</script>，通过经验风险最小化确定参数$\theta_m$为</p>
<script type="math/tex; mode=display">
\begin{aligned}
\theta_m=\arg\min_{\theta_m^{\*}} \sum_{i=1}^N L \left (y_i,f_{m-1}(x_i)+T(x_i;\theta_m^{\*}) \right)
\end{aligned}</script><p>即使<strong>输入数据与输出数据之间的关系很复杂，树的线性组合也可以很好地拟合训练数据</strong>。</p>
<p>在回归问题中，考虑使用平方误差损失函数，所以损失变为</p>
<script type="math/tex; mode=display">
\begin{aligned}
&L \left(y,f_{m-1}(x)+T(x;\theta_m^{\*})\right) \\
&= \left(y-f_{m-1}(x)-T(x;\theta_m^{\*})\right)^2 \\
&=  \left(r-T(x;\theta_m^{\*})\right)^2
\end{aligned}</script><p>其中$r=y-f_{m-1}(x)$是当前模型拟合数据的残差，所以算法就是<strong>拟合当前模型的残差</strong>，描述如下：</p>
<hr>
<p>输入：训练数据集$D$</p>
<hr>
<ol>
<li>初始化$f_0(x)=0$，迭代次数$M$</li>
<li>对$m=1,…,M$<ul>
<li>计算每个样本的残差$r_{mi}=y_i-f_{m-1}(x_i)$</li>
<li>拟合残差$r_m$得到一个回归树$T(x;\theta_m)$</li>
<li>计算$f_m(x)=f_{m-1}(x)+T(x;\theta_m)$</li>
</ul>
</li>
<li>得到回归提升树$f_M(x)=\sum_{m=1}^MT(x;\theta_m)$</li>
</ol>
<hr>
<p>输出：$F_M(x)$</p>
<hr>
<h6 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h6><ul>
<li>损失函数是平方误差、指数损失函数时每一步优化比较明显；但一般损失函数就不那么容易了</li>
<li>使用最速下降的近似方法</li>
<li><strong>利用损失函数的负梯度在当前模型的值残差的近似值</strong>作为提升回归树的残差近似值</li>
</ul>
<p>下面是梯度提升回归树算法</p>
<hr>
<p>输入：数据集$D$，数量为$N$，迭代次数$M$</p>
<hr>
<ol>
<li>初始化$f_0(x)=\arg\min_{c}\sum_{y=1}^NL(y_i,c)$</li>
<li>对$m=1,…,M$<ul>
<li>计算$r_{mi}=-\left[ \frac{\partial{L(y_i,f_{m-1}(x_i))}}{\partial{f_{m-1}(x_i)}} \right]$</li>
<li>对$r_m$拟合一个回归树，对于它的每一个叶节点$R_{mj}$，确定节点的值为$c_{mj}=\arg\min_c\sum_{x_i\in R_{mj}}L(y_i,f_{m-1}(x_i)+c)$</li>
<li>更新$f_m(x)=f_{m-1}(x)+\sum_{j=1}^Jc_{mj}I(x\in R_{mj})$</li>
</ul>
</li>
<li>得到回归树$f_M(x)=\sum_{m=1}^M\sum_{j=1}^Jc_{mj}I(x\in R_{mj})$</li>
</ol>
<hr>
<p>输出：$f_M(x)$</p>
<hr>
<p><code>GBDT(Gradient Boosting Decision Tree)</code>几乎可用于所有的回归问题</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/01/13/Boosting/" data-id="ckeiowf6b000p4gph3q8mi52v" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/3/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/5/">下一页 &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/30/NLP-Pre-train-Models-after-Bert/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2020/08/30/NLP-Pre-train-Models-after-Bert/" class="title">NLP Pre-train Models after Bert</a></p>
                            <p class="item-date"><time datetime="2020-08-30T05:16:49.000Z" itemprop="datePublished">2020-08-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/30/XGboost/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2020/08/30/XGboost/" class="title">XGboost</a></p>
                            <p class="item-date"><time datetime="2020-08-30T05:00:24.000Z" itemprop="datePublished">2020-08-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/30/Bert/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2020/08/30/Bert/" class="title">Bert</a></p>
                            <p class="item-date"><time datetime="2020-08-30T04:58:01.000Z" itemprop="datePublished">2020-08-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/30/Transformer/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2020/08/30/Transformer/" class="title">Transformer</a></p>
                            <p class="item-date"><time datetime="2020-08-30T04:53:14.000Z" itemprop="datePublished">2020-08-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/30/First-Order-Optimization/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Math/">Math</a></p>
                            <p class="item-title"><a href="/2020/08/30/First-Order-Optimization/" class="title">First Order Optimization</a></p>
                            <p class="item-date"><time datetime="2020-08-30T04:46:31.000Z" itemprop="datePublished">2020-08-30</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/">Dev</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OJ/">OJ</a><span class="category-list-count">55</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">35</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">8</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Backtracking/" style="font-size: 11.11px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 11.11px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 16.67px;">Binary Tree</a> <a href="/tags/Cpp/" style="font-size: 15.56px;">Cpp</a> <a href="/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/tags/DP/" style="font-size: 16.67px;">DP</a> <a href="/tags/Deep-Learning/" style="font-size: 10px;">Deep Learning</a> <a href="/tags/Divide-Conquer/" style="font-size: 10px;">Divide & Conquer</a> <a href="/tags/Game-Theory/" style="font-size: 10px;">Game Theory</a> <a href="/tags/Geometry/" style="font-size: 10px;">Geometry</a> <a href="/tags/Greedy/" style="font-size: 13.33px;">Greedy</a> <a href="/tags/IPython/" style="font-size: 10px;">IPython</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 20px;">LeetCode</a> <a href="/tags/Leetcode/" style="font-size: 11.11px;">Leetcode</a> <a href="/tags/MIR/" style="font-size: 10px;">MIR</a> <a href="/tags/Machine-Learning/" style="font-size: 10px;">Machine Learning</a> <a href="/tags/Math/" style="font-size: 12.22px;">Math</a> <a href="/tags/Matlab/" style="font-size: 10px;">Matlab</a> <a href="/tags/NLP/" style="font-size: 13.33px;">NLP</a> <a href="/tags/Optimization/" style="font-size: 10px;">Optimization</a> <a href="/tags/POJ/" style="font-size: 11.11px;">POJ</a> <a href="/tags/Permutation/" style="font-size: 10px;">Permutation</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/Sliding-window/" style="font-size: 14.44px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.11px;">Sort</a> <a href="/tags/State-Machine/" style="font-size: 10px;">State Machine</a> <a href="/tags/String/" style="font-size: 14.44px;">String</a> <a href="/tags/Tree/" style="font-size: 10px;">Tree</a> <a href="/tags/bit/" style="font-size: 10px;">bit</a> <a href="/tags/deep-learning/" style="font-size: 13.33px;">deep learning</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/machine-learning/" style="font-size: 18.89px;">machine learning</a> <a href="/tags/music-information-retrieval/" style="font-size: 10px;">music information retrieval</a> <a href="/tags/numpy/" style="font-size: 11.11px;">numpy</a> <a href="/tags/other/" style="font-size: 10px;">other</a> <a href="/tags/pandas/" style="font-size: 11.11px;">pandas</a> <a href="/tags/prime/" style="font-size: 10px;">prime</a> <a href="/tags/python/" style="font-size: 17.78px;">python</a> <a href="/tags/random-algorithm/" style="font-size: 12.22px;">random algorithm</a> <a href="/tags/recommender-system/" style="font-size: 10px;">recommender system</a> <a href="/tags/time-series-data/" style="font-size: 10px;">time_series_data</a> <a href="/tags/visualization/" style="font-size: 10px;">visualization</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/数据分析/" style="font-size: 10px;">数据分析</a> <a href="/tags/文件/" style="font-size: 10px;">文件</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="https://xueshu.glgoo.org/">Google Scholar Mirror</a>
                    </li>
                
                    <li>
                        <a href="https://www.kaggle.com/">Kaggle</a>
                    </li>
                
                    <li>
                        <a href="http://mlr.cs.umass.edu/ml/datasets.html">UCI dataset</a>
                    </li>
                
                    <li>
                        <a href="https://leetcode.com/problemset/algorithms/">LeetCode</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fas fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2020 Atlantic8<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        </div>
    </div>
</footer>
        


    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>