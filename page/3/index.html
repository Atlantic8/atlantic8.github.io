<!DOCTYPE html>
<html lang="zh">
<head><meta name="generator" content="Hexo 3.9.0">
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
    
    <title>atlantic8</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="A note is preferable to the best memory">
<meta property="og:type" content="website">
<meta property="og:title" content="atlantic8">
<meta property="og:url" content="atlantic8.github.io/page/3/index.html">
<meta property="og:site_name" content="atlantic8">
<meta property="og:description" content="A note is preferable to the best memory">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="atlantic8">
<meta name="twitter:description" content="A note is preferable to the best memory">
    

    

    
        <link rel="icon" href="/css/images/logo.png">
    

    <link rel="stylesheet" href="/libs/font-awesome5/css/fontawesome.min.css">
    <link rel="stylesheet" href="/libs/font-awesome5/css/fa-brands.min.css">
    <link rel="stylesheet" href="/libs/font-awesome5/css/fa-solid.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    
    
        <script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?ff86ad40748d96af89d192e9b0a3ae62";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

    


</head>
</html>
<body>
    <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">atlantic8</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories/OJ">OJ</a>
                
                    <a class="main-nav-link" href="/categories/Algorithm">Algorithm</a>
                
                    <a class="main-nav-link" href="/categories/Math">Math</a>
                
                    <a class="main-nav-link" href="/categories/Dev">Dev</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/css/images/me.png" />
                            <i class="fas fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fas fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories/OJ">OJ</a></td>
                
                    <td><a class="main-nav-link" href="/categories/Algorithm">Algorithm</a></td>
                
                    <td><a class="main-nav-link" href="/categories/Math">Math</a></td>
                
                    <td><a class="main-nav-link" href="/categories/Dev">Dev</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile" class="profile-fixed">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/css/images/me.png" />
            <h2 id="name">Atlantic8</h2>
            <h3 id="title">algorithm engineer</h3>
            <span id="location"><i class="fas fa-map-marker-alt" style="padding-right: 5px"></i>Beijing, China</span>
            <a id="follow" target="_blank" href="https://github.com/Atlantic8">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                124
                <span>文章</span>
            </div>
            <div class="article-info-block">
                46
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/Atlantic8" target="_blank" title="github" class=tooltip>
                            
                                <i class="fab fa-github"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="https://www.linkedin.com/in/wenqiang-cao-704236b8/" target="_blank" title="linkedin" class=tooltip>
                            
                                <i class="fab fa-linkedin"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="mailto:atlantic8@outlook.com" target="_blank" title="envelope" class=tooltip>
                            
                                <i class="fas fa-envelope"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="http://weibo.com/2614093607" target="_blank" title="weibo" class=tooltip>
                            
                                <i class="fab fa-weibo"></i>
                            
                        </a>
                    </td>
                    
                    <td>
                        <a href="/" target="_blank" title="facebook" class=tooltip>
                            
                                <i class="fab fa-facebook"></i>
                            
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main">
    <article id="post-Super-Washing-Machines" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/04/02/Super-Washing-Machines/">Super Washing Machines</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/04/02/Super-Washing-Machines/">
            <time datetime="2017-04-02T02:08:53.000Z" itemprop="datePublished">2017-04-02</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/OJ/">OJ</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/LeetCode/">LeetCode</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>You have $n$ super washing machines on a line. Initially, each washing machine has some dresses or is empty.</p>
<p>For each move, you could <strong>choose any $m (1 ≤ m ≤ n)$ washing machines, and pass one dress of each washing machine to one of its adjacent washing machines at the same time</strong> .</p>
<p>Given an integer array representing the number of dresses in each washing machine from left to right on the line, you should find the minimum number of moves to make all the washing machines have the same number of dresses. If it is not possible to do it, return -1.</p>
<pre><code>Example1

Input: [1,0,5]
Output: 3

Explanation: 
1st move:    1     0 &lt;-- 5    =&gt;    1     1     4
2nd move:    1 &lt;-- 1 &lt;-- 4    =&gt;    2     1     3    
3rd move:    2     1 &lt;-- 3    =&gt;    2     2     2   
Example2

Input: [0,3,0]
Output: 2

Explanation: 
1st move:    0 &lt;-- 3     0    =&gt;    1     2     0    
2nd move:    1     2 --&gt; 0    =&gt;    1     1     1     
Example3

Input: [0,2,0]
Output: -1

Explanation: 
It&#39;s impossible to make all the three washing machines have the same number of dresses. 
Note:
The range of n is [1, 10000].
The range of dresses number in a super washing machine is [0, 1e5].
</code></pre><h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>首先，如果所有洗衣机的衣服总和不能被$n$整除，返回-1.<br>然后对于每个洗衣机，计算它的<code>gain/lose</code>数组，表示还需要移除多少件衣服使得自己达到平衡状态。</p>
<p>举个栗子：<br>对于<code>[0,0,11,5]</code>，每个洗衣机应该有4件衣服，所以它的<code>gain/lose</code>数组为<code>[-4,-4,7,1]</code>。从第一个机器开始考虑，第一个要加入4件，得从第二个机器中过来，所以这个状态可以以4次移动的代价变成<code>[0,-8,7,1]</code>。同理第二个状态也可以以8次移动的代价变成状态三<code>[0,0,-1,1]</code>，最后以一次移动的代价变成<code>[0,0,0,0]</code>。</p>
<p>因为每一次移动可以选取任意个元素，并朝左边或者右边移动一个元素，所以总共需要的移动次数就是<code>gain/lose</code>数组中出现的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMinMoves</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; machines)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = accumulate(machines.begin(), machines.end(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sum % machines.size() != <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>, tmp=<span class="number">0</span>, n=sum / machines.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : machines) &#123;</span><br><span class="line">        tmp += num-n;</span><br><span class="line">        ret = max(max(ret, num-n), abs(tmp));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中<code>num-n</code>没加绝对值，我的理解是对于初始<code>gain/lose</code>数组的负数，可以从两边同时添加衣服，如果是正数，那么那么每次只能移除一件衣服。而<code>tmp</code>加了绝对值，是因为<code>tmp</code>表示左边一个缺少/多的衣服数，这些衣服得从右边过来，并且一个一个达到当前位置，所以得加绝对值。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/04/02/Super-Washing-Machines/" data-id="ckeiowfb9009c4gphq2nefmp7" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Contiguous-Array" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/04/01/Contiguous-Array/">Contiguous Array</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/04/01/Contiguous-Array/">
            <time datetime="2017-04-01T06:09:56.000Z" itemprop="datePublished">2017-04-01</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/OJ/">OJ</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/LeetCode/">LeetCode</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>给定一个只包含0和1的整形数组，输出最长的连续子串的长度，要求子串中0和1的个数相同。</p>
<pre><code>Input: [0,1]
Output: 2
Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.

Input: [0,1,0]
Output: 2
Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.
</code></pre><p>数组长度不会超过50000.</p>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>$O(n^2)$的思路容易想到，但是数组长度太长，会超时。</p>
<p>方法如下：</p>
<ul>
<li>先将数组中的<code>0</code>变成<code>-1</code>，这样连续子序列的和为<code>0</code>的时候满足条件</li>
<li>记录下<code>0-k</code>位置的和与<code>k</code>的对应关系，可以hash map的方法。和相同的只记录最左边的，毕竟长度要最长嘛</li>
<li>如果后面遇到了记录过的和，位置相减就能得到满足条件的子序列长度</li>
<li>时间复杂度为$O(n)$</li>
</ul>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.size(), ret=<span class="number">0</span>, sum=<span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    map[<span class="number">0</span>] = -<span class="number">1</span>; <span class="comment">// 没有数和也为0，防止只有[0,1]时输出0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) <span class="keyword">if</span> (nums[i]==<span class="number">0</span>) nums[i] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="comment">// 以前遇到过sum值，现在位置-以前位置可以得到一个满足要求的序列长度</span></span><br><span class="line">        <span class="keyword">if</span> (map.find(sum) != map.end()) &#123;</span><br><span class="line">            ret = max(ret, i-map[sum]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第一次遇到sum值，记录就行</span></span><br><span class="line">            map[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/04/01/Contiguous-Array/" data-id="ckeiowf6n000y4gphmw2yge6n" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Remove-Boxes" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/04/01/Remove-Boxes/">Remove Boxes</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/04/01/Remove-Boxes/">
            <time datetime="2017-04-01T02:17:56.000Z" itemprop="datePublished">2017-04-01</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/OJ/">OJ</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/DP/">DP</a>, <a class="tag-link" href="/tags/LeetCode/">LeetCode</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h6><p>Given several boxes with different colors represented by different positive numbers.<br>You may experience several rounds to remove boxes until there is no box left. Each time you can choose some continuous boxes with the same color (composed of k boxes, k &gt;= 1), remove them and get k*k points.<br>Find the maximum points you can get.</p>
<p><code>Example 1</code></p>
<pre><code>Input:
[1, 3, 2, 2, 2, 3, 4, 3, 1]
Output:
23
Explanation:
[1, 3, 2, 2, 2, 3, 4, 3, 1] 
----&gt; [1, 3, 3, 4, 3, 1] (3*3=9 points) 
----&gt; [1, 3, 3, 3, 1] (1*1=1 points) 
----&gt; [1, 1] (3*3=9 points) 
----&gt; [] (2*2=4 points)
</code></pre><p><code>Note: The number of boxes n would not exceed 100.</code></p>
<h6 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h6><p>本题可以采用递归+memory（DP）的方法解决，思路是：使用数组map[i][j][k]表示从第i个元素到第j个元素，并且后面还有k个boxes[j]，也就是说现在至少有k+1个boxes[j]。对于i-j之间的满足boxes[p]=boxes[j]的元素，满足一下条件</p>
<script type="math/tex; mode=display">
\begin{aligned}
for\;& p\; with\;boxes[p]==boxes[j]: \\ 
&map[i][j][k]=\max_p(map[i][j][k], map[i][p][k+1]+map[p+1][r-1][0])
\end{aligned}</script><p>代码为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; boxes, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> k, <span class="keyword">int</span> map[<span class="number">100</span>][<span class="number">100</span>][<span class="number">100</span>])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (map[start][end][k] &gt; <span class="number">0</span>) <span class="keyword">return</span> map[start][end][k];</span><br><span class="line">    <span class="comment">// 记录后面连续boxes[end]的数量</span></span><br><span class="line">    <span class="keyword">while</span> (start&lt;end &amp;&amp; boxes[end-<span class="number">1</span>]==boxes[end]) &#123;--end; ++k;&#125;</span><br><span class="line">    map[start][end][k] = dfs(boxes, start, end-<span class="number">1</span>, <span class="number">0</span>, map)+(k+<span class="number">1</span>)*(k+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=start; i&lt;end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (boxes[i] == boxes[end]) &#123;</span><br><span class="line">            map[start][end][k]=max(map[start][end][k], dfs(boxes, start, i, k+<span class="number">1</span>, map)+dfs(boxes, i+<span class="number">1</span>, end-<span class="number">1</span>, <span class="number">0</span>, map));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map[start][end][k];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeBoxes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; boxes)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> map[<span class="number">100</span>][<span class="number">100</span>][<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> dfs(boxes, <span class="number">0</span>, boxes.size()-<span class="number">1</span>, <span class="number">0</span>, map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/04/01/Remove-Boxes/" data-id="ckeiowfa2007j4gphj1wptxot" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-word2vec" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/31/word2vec/">word2vec</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/31/word2vec/">
            <time datetime="2017-03-31T02:50:31.000Z" itemprop="datePublished">2017-03-31</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/NLP/">NLP</a>, <a class="tag-link" href="/tags/machine-learning/">machine learning</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="统计语言模型"><a href="#统计语言模型" class="headerlink" title="统计语言模型"></a>统计语言模型</h5><p>自然语言处理中的一个基本问题是计算一段文本序列在某种语言下出现的概率，统计语言模型给出了这一类问题的一个基本解决框架。</p>
<p>对于一段文本序列$S=w_1,…,w_T$，它的概率是</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(S)=P(w_1,...,w_T)=\prod_{t=1}^Tp(w_t|w_1,...,w_{t-1})
\end{aligned}</script><p>问题变成了如何去预测这些条件概率.</p>
<h6 id="Ngram"><a href="#Ngram" class="headerlink" title="Ngram"></a>Ngram</h6><p>上述模型的参数空间巨大，一个改进方法是Ngram，有</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(w_t|w_1,...,w_{t-1}) \approx p(w_t|w_{t-n+1},...,w_{t-1})
\end{aligned}</script><p>Ngram本质上是将词当做一个个孤立的原子单元去处理的，用<code>ont-hot</code>的方式向量化word，向量维度等于词典大小。<br>Ngram及其他gram模型仍有局限性：</p>
<ul>
<li>由于参数空间的爆炸式增长，它无法处理更长程的context</li>
<li>没有考虑词与词之间内在的联系性</li>
</ul>
<h5 id="Distributed-Representation"><a href="#Distributed-Representation" class="headerlink" title="Distributed Representation"></a>Distributed Representation</h5><p>用<code>ont-hot</code>的方式向量化单词面临着维度灾难问题，能否用一个连续的稠密向量去刻画一个word的特征呢？这样不仅可以直接刻画词与词之间的相似度，还可以建立一个从向量到概率的平滑函数模型，使得相似的词向量可以映射到相近的概率空间上。这个稠密连续向量也被称为word的<code>distributed representation</code>.</p>
<p>在信息检索领域里，这个概念被称为向量空间模型（<code>Vector Space Model</code>），VSM是基于一种<code>Statistical Semantics Hypothesis</code>，比较广为人知的两个版本是<code>Bag of Words Hypothesis</code>和<code>Distributional Hypothesis</code>，分别表示</p>
<ul>
<li><code>Bag of Words Hypothesis</code>：一篇文档的词频（而不是词序）代表了文档的主题</li>
<li><code>Distributional Hypothesis</code>：上下文环境相似的两个词有着相近的语义</li>
</ul>
<p>基于<code>Bag of Words Hypothesis</code>，我们可以构造一个<code>term-document</code>矩阵$A$，矩阵里的元素$A_{ij}$代表着word $w_i$在文档$D_j$中出现的次数（或频率）。可以提取行向量做为word的语义向量。</p>
<p>基于<code>Distributional Hypothesis</code>，我们可以构造一个<code>word-context</code>的矩阵$B$，矩阵里的元素$B_{ij}$代表着word $w_i$在context $C_j$中出现的次数（或频率）</p>
<p>这种co-occurrence矩阵仍然存在着数据稀疏性和维度灾难的问题，解决方法是基于SVD的稀疏矩阵分解方法。</p>
<h5 id="word2vec原理"><a href="#word2vec原理" class="headerlink" title="word2vec原理"></a>word2vec原理</h5><p>假设预料为$D=\lbrace w_1,…,w_V \rbrace$</p>
<h6 id="CBoW模型（Continuous-Bag-of-Words-Model）"><a href="#CBoW模型（Continuous-Bag-of-Words-Model）" class="headerlink" title="CBoW模型（Continuous Bag-of-Words Model）"></a>CBoW模型（Continuous Bag-of-Words Model）</h6><p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fe4l3rsmdtj20tm10gtee.jpg" alt="Continuous Bag-of-Words Model"></p>
<p><strong>CBoW的描述</strong>(N对应图中的|V|)</p>
<ul>
<li>利用位置$t$前后的$2m$个words，以它们的<code>one-hot</code>编码$x_k$作为输入。通过一个共享的$n\times N$投影矩阵$V$，将每个输入投影成$n$维词向量，$N$是词典大小。$v_{t+j}=Vx_{t+j},j\in \lbrace -m,…-1,1,…,m \rbrace$这里的$V$矩阵最终包含的就是我们要的结果。</li>
<li>在PROJECTION层上，将$2m$个投影结果汇总（平均值，舍弃了位置信息）.$\hat{v_t}=\frac{1}{2m}\sum_{j}v_{t+j},j\in \lbrace -m,…-1,1,…,m \rbrace$，通过矩阵$U_{Nn}(U^T=[u_1,…,u_N])$连接到输出层。</li>
<li>最后是softmax层，$N$个节点，每个节点表示中心词是$w_i$的概率。输出层的输入向量为$z$，$z_i=u_i^T\hat{v_t}$，输出结果为$y$，$\hat{y_i}=softmax(z_i)$</li>
</ul>
<p>模型参数是两个词向量矩阵：$U,V$，对于中心词$w_t$，模型对它的损失函数为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
J_t&=-logP(w_t|w_{t-m},...,w_{t-1},w_{t+1},...,w_{t+m}) \\
 &=-log(softmax(z_t)) \\
 &=-log\frac{e^{u_t^T\hat{v_t}}}{\sum_{k=1}^V e^{u_k^T\hat{v_t}}} \\
 &=-z_t+log\sum_{k=1}^V e^{z_k}
\end{aligned}</script><p>所以，整个模型的经验风险为</p>
<script type="math/tex; mode=display">
\begin{aligned}
J&=\sum_{w_{t+m},w_{t-m}\in D} J_t
\end{aligned}</script><p>风险$J$对$U,V$的导数为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\frac{\partial J}{\partial u_i} &= (\hat{y_i}-y_i)\hat{v_t} \\
\frac{\partial J}{\partial U^T} &= \hat{v_t}(\hat{y_t}-y)^T \\
\frac{\partial J}{\partial v_{t+j}} &= \frac{1}{2m}U^T(\hat{y}-y)
\end{aligned}</script><p>采取sgd更新方式，梯度下降。</p>
<h6 id="Skip-gram"><a href="#Skip-gram" class="headerlink" title="Skip-gram"></a>Skip-gram</h6><p><img src="http://ww1.sinaimg.cn/mw690/9bcfe727ly1ffjr31ab9aj213q0tt1hg.jpg" alt="Skip-gram"></p>
<p>Skip-gram以当前词为中心，预测window内的词语，细节图中描述的很清楚了。为了描述方便，不妨假设图中的矩阵$W,W{\’}$分别为$U,V$。</p>
<p>由于输入向量$w_t$是<code>one-hot</code>向量(不妨假设第$k$行是1)，所以$Uw_t$就相当于$U$的第$k$列，在这里将其命名为$u_k$。经过$V$矩阵，得到$z=Vu_k,z_i=v_iu_k$，$v_i$是$V$的第$i$行。这里$V$也可以看成包含了所有单词对应向量的矩阵，$z$就表示了$u_k$和$V$中其他向量的相似度。最后对$z$做softmax归一化得到结果$y$(假设应该是$w_{t+1}$)，最大的对应输出。</p>
<p>假设真实的输出为$\hat{y}$（<code>one-hot</code>，$p$行为1），损失函数使用交叉熵，则对这单个样例的损失函数为</p>
<script type="math/tex; mode=display">
\begin{aligned}
l(t,t+1)=-logy_p=-log\frac{e^{v_iu_k}}{\sum_ie^{v_iu_k}}
\end{aligned}</script><p>所以一个句子的损失为</p>
<script type="math/tex; mode=display">
\begin{aligned}
L=-\frac{1}{T}\sum_{t=1}^T\sum_{i=t-m}^{t+m}l(t,i)
\end{aligned}</script><p>然后分别对$U,V$求导即可得到梯度。</p>
<h6 id="Negative-Sampling"><a href="#Negative-Sampling" class="headerlink" title="Negative Sampling"></a>Negative Sampling</h6><p>继续<code>skip-gram</code>模型，在计算$l(t,i)$的时候，需要计算$w_t$对应的向量与每一个其他向量的相似程度$v_iu_k$，<code>softmax</code>对于特别大的词汇计算量很大。</p>
<p>负采样的思想就是把这里计算其他所有词的相似度改成只计算一部分的相似度，具体地，将这里的类<code>softmax</code>分类的方法变成<code>logistic regression</code>的方法，当前词的context的词为正样本，然后采样一部分其余的词作为负样本。</p>
<p>也就是将$log\frac{e^{v_iu_k}}{\sum_ie^{v_iu_k}}$变成</p>
<script type="math/tex; mode=display">
\begin{aligned}
log\;\sigma(v_iu_k)+\sum_{j=1}^n E_{w_i\sim p_{neg}(w_t)}[log\;\sigma(-v_ju_k)]
\end{aligned}</script><p>其中，$n$是超参数，表示负采样的数量，一般地，对小的训练集$n\in [20,50]$；对大的数据集，$n$可能只有$[2,5]$之间。$ p_{neg}(w_t)$表示对$w_t$负采样的分布。启发式的采样方法可以如下：</p>
<p>随机选取非正样本$w_i$，然后以一定的概率舍弃之，这个概率是</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(w_i)=1-\sqrt{\frac{c}{f(w_i))}}
\end{aligned}</script><p>其中，$f(w_i)$是词$w_i$的词频，$c$是常数，一般在$10^{-5}$左右。这样选择，会过滤掉词频小于$c$的词，并且保证词频大的词语被选中的概率更大。</p>
<h6 id="层次Softmax"><a href="#层次Softmax" class="headerlink" title="层次Softmax"></a>层次Softmax</h6><p>由于原始的CBoW和skip-gram最后都有softmax层，导致复杂度能达到O(nN)，<strong>Hierarchical Softmax是一种对输出层进行优化的策略，输出层从原始模型的利用softmax计算概率值改为了利用<code>Huffman</code>树计算概率值</strong>。</p>
<ul>
<li>投影层的输出沿着<code>huffman</code>树不断进行logistic二分类，并修正各中间向量和词向量</li>
<li>词表中的<strong>全部词作为叶子节点</strong>，<strong>词频作为节点的权</strong>，叶子结点包含word本身</li>
<li>每一个非叶子结点都看作是一个logistic分类器，决定下一层的走向，它包含权值</li>
<li>从根节点出发，到达指定叶子节点的路径是唯一的</li>
<li>路过非叶子结点，修正logistic参数，并且<strong>累计误差，误差最后用来修正投影矩阵$V$</strong></li>
<li><code>Hierarchical Softmax</code>正是利用这条唯一路径来计算指定词的概率</li>
</ul>
<p>实现过程中，可以</p>
<ul>
<li>不考虑投影矩阵，而是将每个词对应的向量（投影后的）设置为随机向量</li>
<li>通过huffman的每一个节点时都计算累加误差，利用累计误差更新当前节点的LR参数</li>
<li>累计误差将被用来调整词向量</li>
</ul>
<h5 id="word2vec的应用"><a href="#word2vec的应用" class="headerlink" title="word2vec的应用"></a>word2vec的应用</h5><h6 id="广告投放"><a href="#广告投放" class="headerlink" title="广告投放"></a>广告投放</h6><pre><code>U1  a1,a2,a3……
U2  a2,a3,a5,……
U3  a1,a3,a6,……
</code></pre><p>公司A目前有很多用户的浏览数据，如用户u浏览了公司A的页面a1，a2，a3等。把每个用户的整体浏览记录当作一篇doc，每个记录就是一个word。利用word2vec算法，将每个记录转化为一个向量。向量化的页面就能够计算相似度，进而根据各种推荐规则进行推荐。</p>
<h6 id="ctr预估模型"><a href="#ctr预估模型" class="headerlink" title="ctr预估模型"></a>ctr预估模型</h6><p>CTR（Click-Through-Rate）即点击通过率，是互联网广告常用的术语，指网络广告（图片广告/文字广告/关键词广告/排名广告/视频广告等）的点击到达率，即<strong>该广告的实际点击次数（严格的来说，可以是到达目标页面的数量）除以广告的展现量（Show content）</strong>。</p>
<p>广告ctr计算存在<strong>冷启动</strong>的问题，冷启动问题就是一个广告是新上线的，之前没有任何的历史投放数据，这样的广告由于数据不足，点击率模型经常不怎么凑效。</p>
<p>解决方法：<strong>使用同类型广告点击率来缓解</strong>，拿一个同行的广告的各种特征作为这个广告的特征，对这个新广告的点击率进行预估。<br>比如在媒体公司A上面有1000个广告主，它们的主页分别是a1、a2、……、a1000，运行word2vec得到每一个页面的向量，然后运行kmean或者其他聚类算法，把这1000个广告主聚成100个簇，然后每个簇里面的广告主看成是一个。</p>
<p><strong>引用</strong><br>[1] <a href="http://www.cnblogs.com/iloveai/p/word2vec.html" target="_blank" rel="noopener">word2vec前世今生</a><br>[2] <a href="https://www.52ml.net/16951.html" target="_blank" rel="noopener">深度学习word2vec笔记之应用篇</a><br>[3] <a href="http://blog.csdn.net/u014595019/article/details/51884529" target="_blank" rel="noopener">自己动手写word2vec</a><br>[4] <a href="https://github.com/multiangle/pyword2vec" target="_blank" rel="noopener">word2vec的python实现</a></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/31/word2vec/" data-id="ckeiowfcb00bc4gph395if1eh" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Latent-Dirichlet-Allocation" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/31/Latent-Dirichlet-Allocation/">Latent Dirichlet Allocation</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/31/Latent-Dirichlet-Allocation/">
            <time datetime="2017-03-31T02:16:10.000Z" itemprop="datePublished">2017-03-31</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/NLP/">NLP</a>, <a class="tag-link" href="/tags/machine-learning/">machine learning</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h5><p>问题的起源是文档排名，就像使用搜索引擎那样，给定关键字，返回排好序的文档列表。既然提到排序，就肯定有衡量标准，给定关键词，一个文档的重要性或者说相关性如何度量呢？</p>
<h6 id="TF"><a href="#TF" class="headerlink" title="TF"></a>TF</h6><p>首先，直观地，如果一篇文档中出现要查询的词的次数越多，相关性应该越大。于是很容易想到<strong><code>词频(TF)</code></strong>这个标准</p>
<pre><code>词频TF(t)就是关键词t在文档中出现的次数
</code></pre><h6 id="IDF"><a href="#IDF" class="headerlink" title="IDF"></a>IDF</h6><p>但是仅仅考虑词频必然会出现问题，因为不同的词应该有不同的重要性，举个例子：在计算机科学类的paper中，出现算法和文学类paper中出现算法的重要性是不一样的，又或者“的”这个字在汉语中出现的次数相当大，一篇文档中没有“的”字的概率是很小的，此时仅仅按照关键词中的“的”判断文档排名显然是不准确的。于是，我们希望加大稀缺词的权重，所以定义了<strong><code>逆文档频率(IDF)</code></strong>，<code>IDF</code>的定义如下<script type="math/tex">IDF(t) = log\frac{N} {DF(t)}</script>其中，$N$为文档总数，$DF(t)$为所有文档中出现了关键词$t$的文档个数。所以，越是普遍的单词（“的”，“因此”等）<code>IDF</code>越小，而稀缺的单词（如文学paper中的“算法”）就对应着比较大的<code>IDF</code>。</p>
<p>将TF和IDF结合到一起，得到TF-IDF的计算方法：<script type="math/tex">TF-IDF(t,d) = TF(t,d) * IDF(t)</script>所以，<strong>一篇文档和一条Query的相关度为Query中所有单词在这篇文档中的TF-IDF值之和</strong>。而<strong>两个文档间的相关度是文档向量的余弦值</strong>，余弦值越接近1，就表明夹角越接近0度，也就是两个向量越相似，这就叫”余弦相似性”。</p>
<h6 id="TF-IDF的缺陷"><a href="#TF-IDF的缺陷" class="headerlink" title="TF-IDF的缺陷"></a>TF-IDF的缺陷</h6><ul>
<li>单纯地认为文本频数小的单词就越重要，文本频数大的单词就越无用，并不是完全正确的</li>
<li>不能有效地反映单词的重要程度和特征词的分布情况，TF-IDF的精度并不是很高</li>
<li>没有体现出单词的位置信息，这也是空间向量模型的不足</li>
</ul>
<h4 id="主题模型"><a href="#主题模型" class="headerlink" title="主题模型"></a>主题模型</h4><p>TF-IDF模型中没有考虑文字背后的语义关联，即语义层面上的关联，可能在两个文档共同出现的单词很少甚至没有，但两个文档是相似的。判断文档相关性的时候需要考虑到文档的语义，而语义挖掘的利器是主题模型，LDA就是其中一种比较有效的模型。</p>
<p>主题模型的思想源于生成模型，其思想如下：<strong>一篇文章的每个词都是通过：以一定概率选择了某个主题，并从这个主题中以一定概率选择某个词语</strong>，形式化表述为<script type="math/tex">p(word|doc)=\sum_{topic}p(word|topic)\times p(topic|doc)</script>，具体内容在下文中描述。</p>
<p>能够发现文档-词语之间所蕴含的潜在语义关系（即主题）——将文档看成一组主题的混合分布，而主题又是词语的概率分布——从而<strong>将高维度的“文档-词语”向量空间映射到低维度的“文档-主题”和“主题-词语”空间</strong>，有效提高了文本信息处理的性能。</p>
<h5 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h5><h6 id="二项分布（Binomial-distribution）"><a href="#二项分布（Binomial-distribution）" class="headerlink" title="二项分布（Binomial distribution）"></a>二项分布（Binomial distribution）</h6><p>$n$次重复伯努利试验，一次概率为$p$，$k$次试验概率函数为<script type="math/tex">P(K=k)=C_n^kp^k(1-p)^{n-k}</script>，二项分布计为$X\sim b(n,p)$。</p>
<h6 id="多项式分布"><a href="#多项式分布" class="headerlink" title="多项式分布"></a>多项式分布</h6><p>每次试验可能有$k$种结果，每种结果的可能性是$p_i$，则$n$次试验各种结果出现次数分别为$x_1,…,x_k$的概率是</p>
<script type="math/tex; mode=display">
\begin{aligned}
P(x_1,...,x_k;n,p_1,...,p_k)=\frac{n!}{x_1!...x_k!}p_1^{x_1}...p_k^{x_k}
\end{aligned}</script><p>是二项分布的扩展。</p>
<h6 id="gamma函数"><a href="#gamma函数" class="headerlink" title="gamma函数"></a>gamma函数</h6><p>gamma函数形如<script type="math/tex">\Gamma(x)=\int_0^{\infty}t^{x-1}e^{-t}dt</script>这个函数有如下性质$\Gamma(x+1)=x\Gamma(x)$，因此gamma函数可以看作是阶乘在实数集上的延拓<script type="math/tex">\Gamma(n)=(n-1)!</script>此外，gamma函数还有如下性质</p>
<ul>
<li>对$x\in (0,1)$，$\Gamma(1-x)\Gamma(x)=\frac{\pi}{sin(\pi x)}$</li>
<li>$\Gamma(\frac{1}{2})=\sqrt{\pi}$</li>
</ul>
<h6 id="共轭先验分布"><a href="#共轭先验分布" class="headerlink" title="共轭先验分布"></a>共轭先验分布</h6><p><strong>定义</strong><br>设$\theta$是总体分布中的参数，$p(\theta)$是$\theta$的先验密度函数，假如<strong>由抽样信息$x$算得的后验密度函数$p(\theta|x)$与$p(\theta)$有相同的函数形式(同一个分布簇)，则称$p(\theta)$是$p(\theta|x)$的(自然)共轭先验分布</strong>，称$p(\theta)$和$p(\theta|x)$为共轭分布。</p>
<h6 id="Beta分布-二项分布的共轭先验分布"><a href="#Beta分布-二项分布的共轭先验分布" class="headerlink" title="Beta分布-二项分布的共轭先验分布"></a>Beta分布-二项分布的共轭先验分布</h6><p>给定参数$\alpha&gt;0,\beta&gt;0$，取值范围为$[0,1]$的随机变量$x$的概率密度函数为</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(x;\alpha,\beta)&=\frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}x^{\alpha-1}(1-x)^{\beta-1} \\
&=\frac{1}{B(\alpha,\beta)} x^{\alpha-1}(1-x)^{\beta-1}
\end{aligned}</script><p>则称$x$满足Beta分布，Beta分布的均值为$\frac{\alpha}{\alpha+\beta}$，方差为$\frac{\alpha\beta}{(\alpha+\beta)^2(\alpha+\beta+1)}$。参数$\alpha,\beta$共同控制Beta分布的函数的形状，见下图。</p>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fe1c0iuzclj20pb0ko788.jpg" alt=""></p>
<p>假定先验分布$p(\theta)$和似然概率$p(x|\theta)$满足</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(\theta)&=\frac{\Gamma(\alpha+\beta)}{\Gamma(\alpha)\Gamma(\beta)}\theta^{\alpha-1}(1-\theta)^{\beta-1}\\&=\frac{1}{B(\alpha,\beta)}\theta^{\alpha-1}(1-\theta)^{\beta-1} \\
p(x|\theta)&=C_n^k\theta^k(1-\theta)^{n-k}
\end{aligned}</script><p>那么，考虑到$p(x)$为常数项，可知后验概率</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(\theta|x)&=\frac{p(x|\theta)p(\theta)}{p(x)} \\
&= \frac{1}{Z}  \theta^{\alpha+k-1}(1-\theta)^{\beta+n-k-1}.
\end{aligned}</script><p>所以，根据定义，$p(\theta)$和$p(\theta|x)$是共轭分布。</p>
<h6 id="Dirichlet分布"><a href="#Dirichlet分布" class="headerlink" title="Dirichlet分布"></a>Dirichlet分布</h6><p>维度$k \ge 2$的狄利克雷分布在参数$\alpha_1, …, \alpha_k &gt; 0$上，其概率密度函数为</p>
<script type="math/tex; mode=display">
\begin{aligned}
f(\theta_1,..,\theta_k;\alpha_1,...,\alpha_k)&=\frac{1}{B(\alpha)} \prod_{i=1}^k\theta_i^{\alpha_i-1} \\
B(\alpha) &= \frac{\prod_{i=1}^k\Gamma(\alpha_i)}{\Gamma(\sum_{i=1}^k\alpha_i)}
\end{aligned}</script><p>同上，假设$\theta=(\theta_1,…,\theta_k)$有先验分布和似然函数,可以有</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(\theta)&= \frac{1}{B(\alpha)} \prod_{i=1}^k\theta_i^{\alpha_i-1} \\
p(x|\theta)&= \frac{n!}{n_1!...n_k!}\theta_1^{n_1}...\theta_k^{n_k} \\
p(\theta|x)&= \frac{1}{Z} \prod_{i=1}^k\theta_i^{\alpha_i+n_i-1}
\end{aligned}</script><p>和Dirichlet分布形式一致。<br>Dirichlet分布的均值向量为$\left( \frac{\alpha_1}{\sum_i^k \alpha_i},…,\frac{\alpha_k}{\sum_i^k \alpha_i} \right)$。</p>
<h5 id="铺垫模型"><a href="#铺垫模型" class="headerlink" title="铺垫模型"></a>铺垫模型</h5><p>定义：</p>
<ul>
<li>$w$表示词，$V$表示所有单词的个数（固定值）</li>
<li>$z$表示主题，$k$是主题的个数（预先给定，固定值）</li>
<li>$D=(d_1,…,d_M)$表示语料库，其中$M$是语料库中的文档数（固定值）</li>
<li>$d=(w_1,…,w_N)$表示一个文档，其中$N$表示一个文档中的词数（随机变量）</li>
</ul>
<h6 id="Unigram-model"><a href="#Unigram-model" class="headerlink" title="Unigram model"></a>Unigram model</h6><p>对于文档$d=(w_1,…,w_N)$，用$p(w_n)$表示$w_n$的先验概率，生成文档$d$的概率为<script type="math/tex">p(d)=\prod_{n-1}^Np(w_n)</script>unigram model假设文本中的词服从Multinomial分布，而Multinomial分布的先验分布为Dirichlet分布。</p>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fe1cpt0cu9j20j40iudgr.jpg" alt="Unigram model"></p>
<p>上图中，$w_n$是在文本中观察到的第$n$个词，$p$和$α$是隐含未知变量,其中</p>
<ul>
<li>$p$是词服从的Multinomial分布的参数</li>
<li>$\alpha$是Dirichlet分布（即Multinomial分布的先验分布）的参数</li>
</ul>
<p>一般$\alpha$由经验事先给定，$p$由观察到的文本中出现的词学习得到，表示文本中出现每个词的概率。</p>
<h6 id="Mixture-of-unigrams-model"><a href="#Mixture-of-unigrams-model" class="headerlink" title="Mixture of unigrams model"></a>Mixture of unigrams model</h6><p>Mixture of unigrams model生成过程是：给某个文档先选择<strong>一个主题</strong>，再根据该主题生成文档，该文档中的所有词都来自一个主题。假设主题有$z_1,…,z_k$，生成文档$d$的概率为</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(d)=\sum_zp(z) \prod_{n=1}^N p(w_n|z)
\end{aligned}</script><p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fe1cx1ll6gj205a02rwec.jpg" alt="Mixture of unigrams model"></p>
<p>如上图所示。</p>
<h6 id="PLSA模型"><a href="#PLSA模型" class="headerlink" title="PLSA模型"></a>PLSA模型</h6><p>Mixture of unigrams model中假定一篇文档只由一个主题生成，可实际中，一篇文章往往有多个主题，只是这多个主题各自在文档中出现的概率大小不一样。PLSA是一种词袋模型，不关注词和词之间的出现顺序。</p>
<p>假设一组共现(co-occurrence)词项关联着一个隐含的主题类别$z_k\in \lbrace z_1,…,z_K \rbrace$。同时定义</p>
<ul>
<li>$p(d_i)$表示海量文档中某篇文档被选中的概率</li>
<li>$p(w_j|d_i)$表示词$w_j$在给定文档$d_i$中出现的概率</li>
<li>$p(z_k|d_i)$表示具体某个主题$z_k$在给定文档$d_i$下出现的概率</li>
<li>$p(w_j|z_k)$表示具体某个词$w_j$在给定主题$z_k$下出现的概率，与主题关系越密切的词，其条件概率越大</li>
</ul>
<hr>
<p><strong>文档到词项的生成方法</strong></p>
<ol>
<li>按照概率$p(d_i)$选择一篇文档$d_i$</li>
<li>选定文档$d_i$后，从主题分布中按照概率$p(z_k|d_i)$选择一个隐含的主题类别$z_k$</li>
<li>选定$z_k$后，从词分布中按照概率$p(w_j|z_k)$选择一个词$w_j$</li>
</ol>
<p>整个过程便是：选定文档-&gt;生成主题-&gt;确定主题生成词。</p>
<hr>
<p><strong>发现文档集中的主题（分布）</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fe1del7l22j207c02qt8m.jpg" alt="PLSA"></p>
<p>如上图所示，文档$d$和单词$w$是可被观察到的（样本），但主题$z$却是隐藏的。因为$p(w_j|d_i)$是已知的(统计文档词频)，根据大量已知的文档-词项信息可以训练出$p(z_k|d_i),p(w_j|z_k)$。文档中每个词的生成概率为</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(w_j,d_i) &= p(d_i)p(w_j|d_i) \\
&= p(d_i)\sum_{k=1}^Kp(w_j|z_k)p(z_k|d_i)
\end{aligned}</script><p>其中$p(d_i)$可事先计算求出，$p(z_k|d_i),p(w_j|z_k)$未知。</p>
<p>考虑词和词($N$)之间、文档($M$)和文档之间的独立性，则整个语料库中词的分布为</p>
<script type="math/tex; mode=display">
\begin{aligned}
p(w,D)=\prod_{i=1}^M\prod_{j=1}^Np(w_j,d_i)^{n(w_j,d_i)}
\end{aligned}</script><p>其中$n(w_j,d_i)$表示词项$w_j$在文档$d_i$中出现的次数，$n(d_i)$表示文档$d_i$中词的总数，并且令$p(w_j|z_k)=\phi_{kj},p(z_k|d_i)=\theta_{ik}$将未知量矩阵化成$\Phi,\Theta$。所以得到对数似然函数</p>
<script type="math/tex; mode=display">
\begin{aligned}
l(\Phi,\Theta)&= \sum_{i=1}^M\sum_{j=1}^Nn(w_j,d_i)\log p(w_j,d_i) \\
&= \sum_{i=1}^M\sum_{j=1}^Nn(w_j,d_i)\left(\log p(d_i)+\log\sum_{k=1}^Kp(w_j|z_k)p(z_k|d_i)\right) \\
&= \sum_{i=1}^Mn(d_i)\left( \log p(d_i)+ \sum_{j=1}^N \frac{n(w_j,d_i)}{n(d_i)} \log\sum_{k=1}^K \phi_{kj}\theta_{ik} \right) \\
&\propto \sum_{i=1}^M \sum_{j=1}^N n(w_j,d_i) \log\sum_{k=1}^K \phi_{kj}\theta_{ik} \\
& \ge \sum_{i=1}^M \sum_{j=1}^N n(w_j,d_i) \sum_{k=1}^K p(z_k|d_i,w_j) \log(\phi_{kj}\theta_{ik})
\end{aligned}</script><p>含有隐含变量的优化可以使用EM算法求解，很复杂，不具体写了<br><strong>E步</strong></p>
<script type="math/tex; mode=display">
\begin{aligned}
p(z_k|d_i,w_j)&=\frac{p(z_k,d_i,w_j)}{\sum_{l=1}^Kp(z_l,d_i,w_j)}=\frac{\phi_{kj}\theta_{ik}}{\sum_{l=1}^M\phi_{lj}\theta_{il}}
\end{aligned}</script><p><strong>M步</strong><br>经过E步，还需考虑约束条件，即</p>
<script type="math/tex; mode=display">
\begin{aligned}
\sum_{j=1}^N\phi_{kj}&=1 \\
\sum_{k=1}^K\theta_{ik}&=1
\end{aligned}</script><p>用拉格朗日乘子法解得</p>
<script type="math/tex; mode=display">
\begin{aligned}
\phi_{kj} &= \frac{\sum_{i=1}^M n(d_i,w_j)p(z_k|d_i,w_j)} {\sum_{i=1}^M\sum_{j=1}^N n(d_i,w_j)p(z_k|d_i,w_j)} \\
\theta_{ik} &= \frac{\sum_{j=1}^N n(d_i,w_j)p(z_k|d_i,w_j) }{n(d_i)}
\end{aligned}</script><p>这样就求解出了$\Phi,\Theta$。PLSA的模型示意如下图所示:</p>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fe1sf8anmrj20dm09ojsc.jpg" alt="PLSA"></p>
<h5 id="LDA-Latent-Dirichlet-Allocation"><a href="#LDA-Latent-Dirichlet-Allocation" class="headerlink" title="LDA(Latent Dirichlet Allocation)"></a>LDA(Latent Dirichlet Allocation)</h5><p><strong>LDA在pLSA的基础上加层贝叶斯框架</strong>，在贝叶斯框架下的LDA中，我们不再认为<strong>主题分布（各个主题在文档中出现的概率分布）和词分布（各个词语在某个主题下出现的概率分布）是唯一确定的（而是随机变量）</strong>。这体现了贝叶斯派的核心思想，<strong>把未知参数当作是随机变量，不再认为是某一个确定的值</strong>。即选主题和选词依然都是两个随机的过程。</p>
<p>LDA需要两个Dirichlet先验参数，这个Dirichlet先验为某篇文档随机抽取出某个主题分布和词分布。</p>
<h6 id="LDA模型中文档生成方式"><a href="#LDA模型中文档生成方式" class="headerlink" title="LDA模型中文档生成方式"></a>LDA模型中文档生成方式</h6><p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fe2a4qu9g3j20dq06sq2y.jpg" alt=""></p>
<p>$\alpha$是主题分布的先验分布，$\beta$是词分布的先验分布。</p>
<ol>
<li>按照先验概率$p(d_i)$选择一篇文档$d_i$</li>
<li>从Dirichlet分布$\alpha$中取样生成文档$d_i$的主题分布$\theta_i$，换言之，主题分布$\theta_i$由超参数为$\alpha$的Dirichlet分布生成</li>
<li>从主题的多项式分布$\theta_i$中取样生成文档$d_i$第$j$个词的主题$z_{ij}$</li>
<li>从Dirichlet分布$\beta$中取样生成主题$z_{ij}$对应的词语分布$\phi_{z_{ij}}$，换言之，词语分布$\phi_{z_{ij}}$由参数为$\beta$的Dirichlet分布生成</li>
<li>从词语的多项式分布$\phi_{z_{ij}}$中采样最终生成词语$w_{ij}$</li>
</ol>
<p>示意图如下:</p>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fe1sknkxg2j20dm09oq46.jpg" alt="LDA"></p>
<p>LDA在pLSA的基础上给这两参数$p(z_k|d_i),p(w_j|z_k)$加了两个先验分布的参数（贝叶斯化）：一个主题分布的先验分布Dirichlet分布$\alpha$，和一个词语分布的先验分布Dirichlet分布$\beta$。这里$\alpha,\beta$都是参数向量。</p>
<p>LDA生成文档的过程中，先从dirichlet先验中“随机”抽取出主题分布，然后从主题分布中“随机”抽取出主题，最后从确定后的主题对应的词分布中“随机”抽取出词。虽说是随机取值，但是不同的参数$\alpha,\beta$导致可选值的分布是不一样的，如下图所示</p>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fe2a310d1rj20ic07tt9k.jpg" alt="不同参数的dirichlet分布"></p>
<h6 id="LDA发现文档集中的主题"><a href="#LDA发现文档集中的主题" class="headerlink" title="LDA发现文档集中的主题"></a>LDA发现文档集中的主题</h6><p>文档生成后，LDA把这两参数$p(z_k|d_i),p(w_j|z_k)$变成随机变量，且加入dirichlet先验。</p>
<p>在pLSA中，我们使用EM算法去估计“主题-词项”矩阵和“文档-主题”矩阵：$\Phi,\Theta$，这两参数都是个固定的值。在LDA中，估计$\Phi,\Theta$这两未知参数可以用变分(Variational inference)-EM算法，也可以用gibbs采样，前者的思想是最大后验估计MAP（MAP与MLE类似，都把未知参数当作固定的值），后者的思想是贝叶斯估计。</p>
<p><strong>Gibbs采样</strong><br>Gibbs抽样是马尔可夫链蒙特卡尔理论（MCMC）中用来获取一系列近似等于指定多维概率分布（比如2个或者多个随机变量的联合概率分布）观察样本的算法。</p>
<p>给定一个文档集合，$w$是可以观察到的已知变量，$\alpha,\beta$和是根据经验给定的先验参数，其他的变量$z，\Theta和\Phi$都是未知变量。</p>
<p>求解$\Theta,\Phi$的过程很复杂，最终求解的Dirichlet分布期望为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
\phi_{kt}&=\frac{n_k^{t}+\beta_t} {\sum_{t=1}^V(n_k^{t}+\beta_t)} \\
\theta_{mk}&=\frac{n_m^{k}+\alpha_k}{\sum_{k=1}^K(n_m^{k}+\alpha_k)}
\end{aligned}</script><p>其中，$\phi_{kt}=p(w_t|z_k),\theta_{mk}=p(z_k|d_m)$，$n_t^k$是词$w_t$在主题$z_k$中出现的次数，$n_m^k$是主题$z_k$在文章$d_m$中出现的次数。</p>
<p><strong>引用</strong><br>[1] <a href="https://cos.name/2013/01/lda-math-gamma-function/" target="_blank" rel="noopener">LDA-math-神奇的Gamma函数</a><br>[2] <a href="http://blog.csdn.net/u010945683/article/details/49149815" target="_blank" rel="noopener">共轭先验分布</a><br>[3] <a href="http://blog.csdn.net/yhao2014/article/details/51098037" target="_blank" rel="noopener">通俗理解LDA主题模型</a><br>[4] <a href="http://blog.163.com/zzz216@yeah/blog/static/162554684201381382117133/" target="_blank" rel="noopener">关于Beta分布、二项分布与Dirichlet分布、多项分布的关系</a></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/31/Latent-Dirichlet-Allocation/" data-id="ckeiowf8d004r4gphddbicpxj" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Prime-Factor-Index-in-Factorial" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/18/Prime-Factor-Index-in-Factorial/">Prime Factor Index in Factorial</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/18/Prime-Factor-Index-in-Factorial/">
            <time datetime="2017-03-18T02:37:24.000Z" itemprop="datePublished">2017-03-18</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Math/">Math</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Math/">Math</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <p>题目的中文翻译是：阶乘中质因数的指数。<br>比如说一道谷歌面试题，求<code>2014!</code>尾部0的个数.</p>
<p>求尾部0的个数，也就是求这个数中质因子5的个数，有定理</p>
<p>在$n!$ 中质因子$p(p&lt;=n)$的指数为：$h=[\frac{n}{p}]+[\frac{n}{p^2}]+…$，其中<code>[]</code>表示取整符号。</p>
<p>所以<code>2014!</code>中5的指数是</p>
<script type="math/tex; mode=display">
\begin{aligned}
&\left[\frac{2014}{5}\right]+\left[\frac{2014}{25}\right]+\left[\frac{2014}{125}\right]+\left[\frac{2014}{625}\right] \\
&= 402+80+16+3 \\
&= 501
\end{aligned}</script>
        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/18/Prime-Factor-Index-in-Factorial/" data-id="ckeiowfa3007m4gphwfnq2m3d" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Cpp-Rule-Fragment3" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/16/Cpp-Rule-Fragment3/">Cpp Rule Fragment3</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/16/Cpp-Rule-Fragment3/">
            <time datetime="2017-03-16T02:05:38.000Z" itemprop="datePublished">2017-03-16</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Dev/">Dev</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Cpp/">Cpp</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h4 id="模板与泛型编程"><a href="#模板与泛型编程" class="headerlink" title="模板与泛型编程"></a>模板与泛型编程</h4><h5 id="定义模板"><a href="#定义模板" class="headerlink" title="定义模板"></a>定义模板</h5><ul>
<li>函数模板可以定义为inline、constexpr，关键字位置应该在模板参数列表之后，返回类型之前</li>
<li>编译器遇到模板时不生成代码，只有在实例化特定版本（使用）时，编译器才会生成代码</li>
<li>使用普通类对象时，类定义必须可用但成员函数的定义不必已经出现，因此类定义和函数声明放在头文件，函数、类成员函数定义在源文件。但<strong>实例化模板时，编译器需要知道模板定义</strong>，所以<strong>函数模板、类模板的定义通常放在头文件中</strong></li>
<li>大多数编译错误在实例化时期报告</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;   <span class="comment">// typename有的也写做class，意义相同</span></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="function">inline T <span class="title">sort</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">inline template &lt;typename T&gt; <span class="function">T <span class="title">sort</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>; <span class="comment">// wrong</span></span><br></pre></td></tr></table></figure>
<p><strong>非类型模板参数</strong></p>
<ul>
<li>非类型模板参数表示值，而非类型</li>
<li>非类型模板参数被用户提供的或者编译器推断的值替代，这些实参值必须是常量表达式</li>
<li>非类型参数可以是整型（实参必须是常量表达式），指向对象或函数类型的指针、左值引用（实参必须具有静态生存期（局外变量、静态变量、栈））</li>
</ul>
<h5 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h5><ul>
<li>类的作用域包括：类定义中，源文件类成员函数的函数体内(<code>{}</code>之内)</li>
<li>类的作用域中，编译器处理模板自身引用时可以不带类型名</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;::check (<span class="keyword">const</span> T&amp; t1, <span class="keyword">const</span> T&amp; t2) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类作用域中</span></span><br><span class="line">Blob&lt;T&gt;&amp; func();  <span class="comment">// ok</span></span><br><span class="line">Blob&amp; func(); <span class="comment">// ok</span></span><br><span class="line"><span class="comment">// 之外</span></span><br><span class="line">Blob&amp; func &#123;   <span class="comment">// wrong</span></span><br><span class="line">    Blob ret = *<span class="keyword">this</span>; <span class="comment">// ok, in scope</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="类模板和友元"><a href="#类模板和友元" class="headerlink" title="类模板和友元"></a>类模板和友元</h6><ol>
<li><strong>如果类模板包含非模板友元，则该友元可以访问所有模板实例</strong></li>
<li><strong>如果类模板包含模板友元，类可以授权给所有模板实例，也可以只授权给特定实例</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">friend B&lt;T&gt;;  <span class="comment">// 授权给特定实例，要求类型相同</span></span><br><span class="line">friend C&lt;F&gt;;  <span class="comment">// 授权给所有模板实例</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模板类型别名</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef Blob&lt;string&gt; strBlob;</span><br><span class="line"><span class="comment">// 为类模板定义一个类型别名</span></span><br><span class="line">template&lt;typename T&gt; using twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="keyword">int</span>&gt; p;  <span class="comment">// 定义类型为&lt;int, int&gt;类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以固定一个、多个模板参数</span></span><br><span class="line">template&lt;typename T&gt; using partNo = pair&lt;T, unsigned&gt;;</span><br></pre></td></tr></table></figure></p>
<p><strong>静态成员</strong></p>
<ul>
<li>模板的<code>static</code>成员也定义成模板，每个模板的实例都可以有一个自己的静态成员</li>
<li><code>template&lt;typename T&gt; size_t Foo&lt;T&gt;::ctr = 0;</code></li>
<li>通过引用特定实例、作用域运算符访问成员<code>Foo&lt;int&gt;::ctr;</code></li>
</ul>
<h6 id="模板参数"><a href="#模板参数" class="headerlink" title="模板参数"></a>模板参数</h6><ul>
<li>模板内不能重用模板参数名</li>
<li>模板声明必须包含模板参数</li>
<li>使用模板类型参数的类型成员，必须通过关键字typename(class不行)显式地告诉编译器该名字是一个类型</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T::size_type *p; <span class="comment">// 可以是定义指向size_type类型的指针，也可以是T的静态成员乘以p的结果</span></span><br><span class="line"></span><br><span class="line">typename T::size_type *p; <span class="comment">// 定义指向size_type类型的指针</span></span><br></pre></td></tr></table></figure>
<h6 id="成员模板"><a href="#成员模板" class="headerlink" title="成员模板"></a>成员模板</h6><ul>
<li>成员模板不能是虚函数</li>
<li>实例化类模板的成员模板，必须同时提供类和函数模板的实参<code>Blob&lt;int&gt; a1(vi.begin(), vi.end());</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span> </span>&#123;</span><br><span class="line">template&lt;typename T&gt; <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">string s = <span class="string">"hello"</span>;</span><br><span class="line">Blob b;</span><br><span class="line">b.func(s);</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> </span>&#123;</span><br><span class="line">template&lt;typename F&gt; Blob(<span class="keyword">const</span> F&amp;);</span><br><span class="line">&#125;</span><br><span class="line">string s = <span class="string">"hello"</span>;</span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(s)</span></span>;</span><br></pre></td></tr></table></figure>
<h6 id="控制实例化"><a href="#控制实例化" class="headerlink" title="控制实例化"></a>控制实例化</h6><ul>
<li>模板在使用时才会实例化，多个文件中的模板实例化可能会造成严重额外开销</li>
<li>通过显示实例化避免开销，<strong>编译器遇到<code>extern</code>模板声明时就不会在本文件中生成实例化代码</strong></li>
<li>类模板的实例化会实例化所有成员（包括内联）（和普通类不同）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">extern template declaration; <span class="comment">// 实例化声明</span></span><br><span class="line">template declaration;  <span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure>
<h5 id="模板实参推断"><a href="#模板实参推断" class="headerlink" title="模板实参推断"></a>模板实参推断</h5><h6 id="模板转换"><a href="#模板转换" class="headerlink" title="模板转换"></a>模板转换</h6><ul>
<li>如果函数形参使用了模板类型参数，其采用特殊的初始化规则</li>
<li>编译器通常不是对实参进行类型转换，而是生成一个新的模板实例，例外在下面<ul>
<li>const转换，忽略顶层const</li>
<li>数组、函数指针转换（函数形参不能为引用类型）</li>
</ul>
</li>
</ul>
<h6 id="显式模板实参、remove-reference"><a href="#显式模板实参、remove-reference" class="headerlink" title="显式模板实参、remove_reference"></a>显式模板实参、<code>remove_reference</code></h6><ul>
<li>显式模板参数在<code>&lt;&gt;</code>中给出，函数名后，参数列表之前</li>
<li>显式模板实参按从左向右的顺序与对应的模板参数匹配，尾部的可以忽略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T1, typename T2, typename T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">func</span><span class="params">(T2, T3)</span></span>;  <span class="comment">// bad</span></span><br><span class="line">T1 func&lt;<span class="keyword">int</span>&gt;(T2, T3); <span class="comment">// T1 is int</span></span><br><span class="line">T1 func&lt;<span class="keyword">int</span>, string&gt;(T2, T3); <span class="comment">// T1 is int, T2 is string</span></span><br><span class="line"></span><br><span class="line">template&lt;typename T1, typename T2, typename T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">func</span><span class="params">(T2, T1)</span></span>; <span class="comment">// wrong</span></span><br><span class="line">T3 func&lt;<span class="keyword">int</span>&gt;(T2, T1); <span class="comment">// wrong, T3是int，但不能推断T1、T2</span></span><br><span class="line">T3 func&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt;(T2, T1); <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾后类型的使用</span></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="function">auto <span class="title">func</span><span class="params">(T beg, T end)</span> -&gt; <span class="title">decltype</span><span class="params">(*beg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面迭代器返回的是引用，如果希望返回原来类型，如下</span></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line"><span class="function">auto <span class="title">func</span><span class="params">(T beg, T end)</span> -&gt; typename remove_reference&lt;<span class="title">delctype</span><span class="params">(*beg)</span>&gt;::type </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *beg;  <span class="comment">// 返回元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>remove_reference&lt;T&amp;&gt;</code>将得到原本的T类型，类型由其类型成员<code>type</code>表示</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/16/Cpp-Rule-Fragment3/" data-id="ckeiowf70001t4gph9l94s6jq" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Sunday" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/15/Sunday/">Sunday</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/15/Sunday/">
            <time datetime="2017-03-15T14:01:25.000Z" itemprop="datePublished">2017-03-15</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/String/">String</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h6><p><code>Sunday</code>算法是用于字符串匹配的算法，平均复杂度为<code>O(n)</code>，平均效率高于<code>KMP</code>和<code>BM</code>。</p>
<p>示例如下：<br>匹配时，从左到右匹配，第一个字符不匹配，看模式串后一位<code>t</code>对应的字符，因为<code>t</code>位的字符也总是要匹配的。所以我们需要查找<code>t</code>位字符在模式串中最右侧的位置，然后移动模式串。如果<code>t</code>位的字符在模式串中不存在，那么移动模式串首到当前模式串尾部的下一个位置。</p>
<pre><code>suck kmy balls
kmy
</code></pre><p>对齐字母<code>k</code>，如下</p>
<pre><code>suck kmy balls
   kmy
</code></pre><p>还不匹配，继续</p>
<pre><code>suck kmy balls
     kmy
</code></pre><p>匹配出现，记录下。然后再看下一个字符<code> </code>，其在模式串没出现，移动模式串到</p>
<pre><code>suck kmy balls
         kmy
</code></pre><p>依此类推，直到结束。</p>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fdoevubjcbj216o0djgm5" alt=""></p>
<p>下面看一下具体移动的步长，设当前p和s的位置分别在pi和si，p结尾的最后一个位置对应于s中序号为<code>skey = si+p.length()-pi</code>的位置：</p>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fdof40xqgpj21e60dkwf1" alt=""></p>
<ul>
<li>如果<code>skey</code>中的字符在模式串p中没有，则将<code>pi=0</code>，<code>si</code>移到<code>skey+1</code>位置</li>
</ul>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fdoezdgengj21a10ea0ta" alt=""></p>
<p><img src="http://ww1.sinaimg.cn/large/9bcfe727ly1fdof5yzhjkj219x0duzkt" alt=""></p>
<ul>
<li>否则，要令<code>skey</code>与p中对应的最右相同元素对齐，设p中序号为<code>k</code>的元素满足条件，<code>si</code>需要移动变成<code>skey-k=si+p.length()-pi-k</code>，同样地<code>pi=0</code></li>
</ul>
<h6 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h6><p><code>sunday</code>算法需要维护一个数组，记录s串中下一个字符为x时模式串移动的距离。命其名为<code>next</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_next</span><span class="params">(string p, vector&lt;<span class="keyword">int</span>&gt; &amp;next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;p.length(); i++) &#123;</span><br><span class="line">        next[p[i]] = p.length()-i;  <span class="comment">// 模式串有的字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sunday</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">next</span><span class="params">(<span class="number">255</span>, p.length()</span>+1)</span>;  <span class="comment">// 默认不存在模式串中的字符对应的移动长度为p.length()+1</span></span><br><span class="line">    get_next();</span><br><span class="line">    <span class="keyword">int</span> si=<span class="number">0</span>, pi=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (si+p.length() &lt; s.length()) &#123;</span><br><span class="line">        pi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (pi=<span class="number">0</span>; pi&lt;p.length(), s[si++] != p[pi]; pi++); <span class="comment">// matching</span></span><br><span class="line">        <span class="keyword">if</span> (pi == p.length())  <span class="comment">// match found</span></span><br><span class="line">            cout &lt;&lt; <span class="string">"match found, index is "</span> &lt;&lt; si-p.length()+<span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">int</span> skey = si + p.length() - pi;</span><br><span class="line">        <span class="keyword">if</span> (skey &gt;= s.length) <span class="keyword">break</span>;</span><br><span class="line">        si += next(s[skey]) - pi;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/15/Sunday/" data-id="ckeiowfat008v4gph8hdenzbm" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-K-Nearest-Neighbor" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/07/K-Nearest-Neighbor/">K-Nearest Neighbor</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/07/K-Nearest-Neighbor/">
            <time datetime="2017-03-07T02:08:37.000Z" itemprop="datePublished">2017-03-07</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Algorithm/">Algorithm</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/machine-learning/">machine learning</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h6 id="KNN"><a href="#KNN" class="headerlink" title="KNN"></a>KNN</h6><p>KNN的算法思想非常简单，不赘述。<br>K值的选择有讲究，一般使用交叉验证的方法来确定K值。</p>
<h6 id="KD树"><a href="#KD树" class="headerlink" title="KD树"></a>KD树</h6><p>KNN naive的实现实现方法是线性扫描法，但是这种方法效率很差，训练集很大时非常耗时。好一点的方法是使用一个最大堆，时间复杂度为$O(nlogK)$。</p>
<p>下面介绍基于树的方法：kd树。</p>
<p>kd树是二叉树，表示对k维空间的一个划分。相当于不断地用垂直于坐标轴的超平面将k维空间切分，构成一系列的超矩形区域。</p>
<p>kd树的构造方法如下：</p>
<hr>
<p>输入：数据集$D=\lbrace x_1,x_2,…,x_n \rbrace$<br>其中$x_i=(x_i^{(1)},…,x_i^{(k)})$为$k$维空间的样本</p>
<hr>
<p>1) 构造根结点，根节点对应于包含$D$的$k$维空间超矩形区域。选择$x^{(1)}$为坐标轴，以$D$中所有样本的$x^{(1)}$坐标的中位数作为切分点，切成两部分。落在超平面上的点保存在根节点，在超平面左侧、右侧的节点分别根节点深度为1的左右孩子。<br>2) 重复：对深度为$j$的节点，选择$x^{(l)}$作为切分的坐标轴，满足$l=j\; mod\; k + 1$，坐标轴轮流选，一轮完了再重复.<br>3) 迭代停止条件：如果一个节点的左右孩子中都没有样本，那么停止迭代</p>
<hr>
<p>输出：kd树</p>
<hr>
<p>下面介绍使用kd树进行k近邻搜索，使用最大堆辅助结构</p>
<hr>
<p>输入：已构造的kd树，目标点$x$，近邻数$K$，空最大堆$hp$</p>
<hr>
<ol>
<li>从根节点出发，递归地向下访问kd树，若目标$x$当前维的坐标小于切分点的坐标，则移动到左子结点，否则移动到右子结点，直到结点为叶节点为止。对每一个路过的节点，添加元素维护最大推（留下小的）。</li>
<li>递归的向上回退，在每个节点$p$进行以下操作<ul>
<li>检查该结点未被访问过的结点$p_c$对应的区域是否有比堆顶元素更近的点或堆容量未满。具体的，检查$p_c$对应的区域是否与以目标点为求心、以目标点与堆顶元素距离为半径的球体相交</li>
<li>如果相交或$hp$容量未满，以$p_c$结点为根节点执行1，否则继续回溯</li>
</ul>
</li>
<li>当对根节点的回溯完成以后，结束</li>
</ol>
<hr>
<p>输出：最大堆$hp$内元素即为$s$的$K$近邻</p>
<hr>
<p><strong>kd树更适用于训练实例数远大于空间维度数时的计算</strong>，空间维度接近训练实例数时，效率会迅速下降，几乎接近线性扫描。</p>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/07/K-Nearest-Neighbor/" data-id="ckeiowf88004g4gphq6hkpudk" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <article id="post-Cpp-Rule-Fragment2" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 itemprop="name">
            <a class="article-title" href="/2017/03/06/Cpp-Rule-Fragment2/">Cpp Rule Fragment2</a>
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fas fa-calendar-alt"></i>
        <a href="/2017/03/06/Cpp-Rule-Fragment2/">
            <time datetime="2017-03-06T07:28:49.000Z" itemprop="datePublished">2017-03-06</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fas fa-folder"></i>
        <a class="article-category-link" href="/categories/Dev/">Dev</a>
    </div>

                        
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/tags/Cpp/">Cpp</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h5 id="左右的概念"><a href="#左右的概念" class="headerlink" title="左右的概念"></a>左右的概念</h5><h6 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h6><p>C++中左值与右值这两概念是从 c 中传承而来的，在 c 中，<strong>左值指的是既能够出现在等号左边也能出现在等号右边的变量(或表达式)，右值指的则是只能出现在等号右边的变量(或表达式)</strong></p>
<p><strong>在 C语言中，通常来说有名字的变量就是左值</strong>(如 a, b)，<strong>而由运算操作(加减乘除，函数调用返回值等)所产生的中间结果(没有名字)就是右值</strong>，如 3 + 4， a + b 等。</p>
<p>在 C++ 中，每一个表达式都会产生一个左值，或者右值，相应的，该表达式也就被称作“左值表达式”， “右值表达式”。对于内置的基本数据类型来说，左值右值的概念和 c 没有太多不同，不同的地方在于自定义的类型，具体如下：</p>
<ul>
<li>对于内置的类型，右值是不可被修改的(non-modifiable)，也不可被 const, volatile 所修饰（volatile关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中，保证每次取的值都是内存中值）</li>
<li>对于自定义的类型(user-defined types)，右值却允许通过它的成员函数进行修改<br>2<h6 id="左值引用、右值引用"><a href="#左值引用、右值引用" class="headerlink" title="左值引用、右值引用"></a>左值引用、右值引用</h6></li>
<li>左值引用，<code>Type &amp; 左值引用名 = 左值表达式;</code></li>
<li>声明时必须初始化，初始化之后无法在改变；对别名的一切操作都等价于对原来变量的操作。</li>
<li>右值不能赋值给左值引用，加上const限定符即可</li>
<li>c++中临时变量默认const属性，所以只能传给const引用(延长生命周期)</li>
</ul>
<hr>
<ul>
<li>右值引用，<code>Type &amp;&amp; 右值引用名 = 右值表达式;</code></li>
<li>可以直接把左值或者右值转换成右值引用，但转换后原对象就不能使用了</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp; a1 = val+<span class="number">1</span>;  <span class="comment">// 错误，此时val+1（中间结果用const型的临时变量保存）等价于右值，右值不能赋值给左值引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a2 = val+<span class="number">1</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a3 = <span class="number">10</span>;  <span class="comment">//  正确</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;&amp; a4 = std::move(val+<span class="number">1</span>); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h4 id="动态内存与智能指针"><a href="#动态内存与智能指针" class="headerlink" title="动态内存与智能指针"></a>动态内存与智能指针</h4><ul>
<li>智能指针负责自动释放所指向的对象，定义在<code>memory</code>头文件中</li>
<li>智能指针也是模板，创建智能指针时需要提供类型信息</li>
<li>智能指针的使用与普通指针类似</li>
<li>包括shared_ptr（允许多个指针指向同一个对象）、unique_ptr（独占所指向的对象）、weak_ptr（指向shared_ptr所指向的对象）</li>
</ul>
<p>注意事项</p>
<ul>
<li>不用相同的内置指针初始化多个智能指针</li>
<li>不delete get函数返回的值</li>
<li>不用get返回值初始化/reset另一个智能指针</li>
<li>如果智能指针管理的资源不是new分配的资源，需要传给他一个删除器</li>
</ul>
<h5 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; sp; <span class="comment">// 空指针</span></span><br><span class="line"><span class="keyword">if</span> (p)   <span class="comment">//  如果p指向一个对象则为true</span></span><br><span class="line">*p</span><br><span class="line">p-&gt;mem</span><br><span class="line">p.get()   <span class="comment">// 返回p中保存的指针</span></span><br><span class="line">swap(p, q)  <span class="comment">// 交换p和q中的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>不要将get函数得到的内置指针用于初始化其他智能指针</strong>，可能会导致两个智能指针指向同一个对象，且他们的计数器都为1<br>以上操作也适用于unique_ptr，下面的操作则是shared_ptr独占：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">make_shared&lt;T&gt; (args)  <span class="comment">// 返回一个shared_ptr, 指向类型T的动态内存对象，使用args初始化</span></span><br><span class="line">shared_ptr&lt;T&gt;p(q)   <span class="comment">// p是q的拷贝；q中的计数器加一，要求q中的指针必须能转化位T*</span></span><br><span class="line">p = q    <span class="comment">// p,q都是shared_ptr，保存的指针必须能相互转换。p的引用计数器递减，q的递增。若p的引用计数器变为0，则将其管理的资源释放</span></span><br><span class="line">p.unique()   <span class="comment">//  若p.use_count()为1，返回true；否则返回false</span></span><br><span class="line">p.use_count  <span class="comment">// 返回与p共享对象的智能指针个数；一般用于调试</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">auto p1 = <span class="keyword">new</span> auto(obj); <span class="comment">// p指向一个与obj类类型相同的对象，该对象用obj初始化</span></span><br><span class="line"></span><br><span class="line">auto p2 = <span class="keyword">new</span> auto&#123;a,b,c&#125;; <span class="comment">// 错误，括号中只能有单个初始化器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存耗尽时new操作会抛出bad_alloc异常，下面的方法可以避免抛出异常</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> (notthrow) <span class="keyword">int</span>;   <span class="comment">// 内存耗尽时返回空指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li>delete空指针没有问题</li>
<li>delete之后应该重置指针</li>
</ul>
<h6 id="shared-ptr和new"><a href="#shared-ptr和new" class="headerlink" title="shared_ptr和new"></a>shared_ptr和new</h6><ul>
<li>可以使用new返回的指针初始化智能指针</li>
<li><strong>接受指针参数的智能指针构造函数为explicit</strong>（不准指针隐式转换），必须使用直接初始化形式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(new <span class="keyword">int</span>(<span class="number">42</span>)</span>)</span>;</span><br><span class="line">shared_ptr&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>); <span class="comment">// 错误，可以使用reset</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(u)</span></span>;  <span class="comment">// p从unique_ptr接管对象所有权，将u置空</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">p</span><span class="params">(q, d)</span>  <span class="comment">// p接管内置指针q所指向的对象，q必须能转换为T*，p使用可调用对象d代替delete</span></span></span><br><span class="line"><span class="function">p.<span class="title">reset</span><span class="params">()</span>   <span class="comment">// 若p是唯一指向其对象的shared_ptr，reset释放该对象</span></span></span><br><span class="line"><span class="function">p.<span class="title">reset</span><span class="params">(q)</span>  <span class="comment">// 若传递了参数内置指针q，令p指向q，否则将p置空</span></span></span><br><span class="line"><span class="function">p.<span class="title">reset</span><span class="params">(q, d)</span></span>;  <span class="comment">// 有d则使用可调用对象代替delete</span></span><br></pre></td></tr></table></figure>
<h5 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h5><ul>
<li>一个对象只能有一个unique_ptr，不支持拷贝（除非是返回即将要销毁或局部对象的拷贝）、赋值</li>
<li>必须采用直接初始化形式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;T, D&gt; u <span class="comment">// D为可调用对象，用来释放内存</span></span><br><span class="line"><span class="function">unique_ptr&lt;T, D&gt; <span class="title">u</span><span class="params">(d)</span>   <span class="comment">// 用d代替D</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">u </span>= nullptr  <span class="comment">// 释放u指向的对象，将u置空</span></span><br><span class="line">u.release()  <span class="comment">// u交出控制权，返回内置指针，将u置空</span></span><br><span class="line"></span><br><span class="line">u.reset()     <span class="comment">// 释放u指向的对象</span></span><br><span class="line">u.reset(q)   <span class="comment">// 提供内置指针q，则令u指向这个对象；否则将u置空</span></span><br><span class="line">u.reset(nullptr)</span><br></pre></td></tr></table></figure>
<h6 id="unique-ptr和动态数组"><a href="#unique-ptr和动态数组" class="headerlink" title="unique_ptr和动态数组"></a>unique_ptr和动态数组</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;T[]&gt; u;  <span class="comment">// u指向一个动态分配的数组</span></span><br><span class="line">unique_ptr&lt;T[]&gt; u(p);  <span class="comment">// u指向内置指针p指向的动态动态分配的数组，p类型必须能转换为T*</span></span><br><span class="line">u[i];   <span class="comment">// 访问数组</span></span><br></pre></td></tr></table></figure>
<p>shared_ptr没有提供管理动态数组的功能，需要使用需要自己定义删除器。</p>
<h5 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h5><ul>
<li>不能控制对象生存周期，指向由shared_ptr管理的对象，切不改变shared_ptr引用计数</li>
<li>需要用shared_ptr初始化</li>
<li>指向对象可能被释放掉，所以不能直接访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">weak_ptr&lt;T&gt; <span class="title">w</span><span class="params">(sp)</span></span>;  <span class="comment">// 初始化</span></span><br><span class="line"></span><br><span class="line">w = p; <span class="comment">// p可以是weak_ptr或shared_ptr，赋值后两者共享对象</span></span><br><span class="line">w.reset()  <span class="comment">// w置空</span></span><br><span class="line">w.use_count()  <span class="comment">// 与w共享对象的shared_ptr的数量</span></span><br><span class="line">w.expired()     <span class="comment">// w.use_count() == 0返回true</span></span><br><span class="line">w.lock()   <span class="comment">// w.expired() 为true返回一个空shared_ptr，否则返回一个与w共享对象的shared_ptr</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问</span></span><br><span class="line"><span class="keyword">if</span> (shared_ptr&lt;<span class="keyword">int</span>&gt; np = w.lock()) &#123;  <span class="comment">// np不为空成立</span></span><br><span class="line">    <span class="comment">// 使用np访问对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="allocator类"><a href="#allocator类" class="headerlink" title="allocator类"></a>allocator类</h5><ul>
<li>定义在memory头文件中，是一个模板</li>
<li>allocator分配的内存都是未构造的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;T&gt; a;</span><br><span class="line">a.allocate(n);  <span class="comment">// 分配一段原始的、未构造的内存，保存n个类型为T的对象</span></span><br><span class="line">a.deallocate(p, n);  <span class="comment">// 释放从T*类型的指针p开始的内存，这块内存保存了n个T类型对象；p必须是由allocate函数返回的指针，n必须是p创建时要求的大小。调用之前，必须对这n个T对象调用destory</span></span><br><span class="line"></span><br><span class="line">a.construct(p, args); <span class="comment">// p必须是类型为T*的指针，指向一块原始内存，args被传递给类型为T的构造函数，用来在p指向的内存中构造一个对象</span></span><br><span class="line">a.destory(p)  <span class="comment">// 对p指向的对象指向析构函数</span></span><br></pre></td></tr></table></figure>
<h6 id="构造、填充未初始化内存的算法"><a href="#构造、填充未初始化内存的算法" class="headerlink" title="构造、填充未初始化内存的算法"></a>构造、填充未初始化内存的算法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">uninitialized_copy(b, e, b2);  <span class="comment">// 拷贝迭代器b、e指定范围元素到b2指定的未构造的原始内存中，b2指向的内存必须足够大</span></span><br><span class="line">uninitialized_copy_n(b, n, b2); <span class="comment">// 从b开始，n个元素</span></span><br><span class="line"></span><br><span class="line">uninitialized_fill(b, e, t);  <span class="comment">// 拷贝值均为t</span></span><br><span class="line">uninitialized_fill_n(b, n, t);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这几个算法都返回下一个未初始化的内存位置</span></span><br></pre></td></tr></table></figure>
<h4 id="拷贝控制"><a href="#拷贝控制" class="headerlink" title="拷贝控制"></a>拷贝控制</h4><h5 id="拷贝、赋值与销毁"><a href="#拷贝、赋值与销毁" class="headerlink" title="拷贝、赋值与销毁"></a>拷贝、赋值与销毁</h5><h6 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h6><ul>
<li>成员类型决定拷贝方式，内置类型直接拷贝，类类型需要拷贝构造函数来拷贝</li>
<li>不应该是explicit的</li>
<li>参数是自身类类型的引用</li>
<li>编译器会为我们定义一个（如果我们没有定义）</li>
</ul>
<p><strong>拷贝初始化发生的时间不仅在用=定义变量时，也会发生在</strong>：</p>
<ol>
<li>将对象作为实参传递给非引用类型的形参</li>
<li>从返回非引用类型的函数返回一个对象</li>
<li>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</li>
</ol>
<h6 id="拷贝赋值运算符"><a href="#拷贝赋值运算符" class="headerlink" title="拷贝赋值运算符"></a>拷贝赋值运算符</h6><ul>
<li>编译器会为我们定义一个（如果我们没有定义）</li>
</ul>
<h6 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h6><ul>
<li>编译器会为我们定义一个（如果我们没有定义）</li>
<li>一般为空，成员是在析构函数体之后隐含的析构阶段被销毁的</li>
<li>某些类中，析构函数也被用来阻止该类型的对象被销毁</li>
<li>需要析构函数的类也需要拷贝、赋值操作</li>
</ul>
<h6 id="使用-default"><a href="#使用-default" class="headerlink" title="使用=default"></a>使用<code>=default</code></h6><ul>
<li>将拷贝控制成员定义为<code>=default</code>可以显式地要求编译器生成合成的版本</li>
<li>类内使用`=default’修饰的成员将隐式地声明为内联的</li>
<li>如果不希望内联，则只对类外的定义使用<code>=default</code>。</li>
</ul>
<h6 id="阻止拷贝"><a href="#阻止拷贝" class="headerlink" title="阻止拷贝"></a>阻止拷贝</h6><ul>
<li>在函数第一次声明后面写上<code>=delete</code>表示<strong>删除的函数</strong>，不希望定义这些成员</li>
<li>拷贝构造函数、拷贝赋值运算符定义为删除的函数可以阻止拷贝</li>
<li>析构函数不能是删除的成员，因为存在对象无法销毁的问题</li>
<li>但如果你真的这么干了：如果一个类有数据成员不能默认构造、拷贝、复制、销毁，则对应的成员函数将被定义为删除的</li>
</ul>
<h5 id="动态内存管理类"><a href="#动态内存管理类" class="headerlink" title="动态内存管理类"></a>动态内存管理类</h5><ul>
<li>在运行时分配可变大小内存的空间</li>
<li>以vector为例，添加元素的成员函数检查是否有更多空间，没有则申请新的空间，<strong>将已有元素移到新空间</strong>，释放旧空间，添加新元素</li>
</ul>
<h5 id="移动构造函数和std-move"><a href="#移动构造函数和std-move" class="headerlink" title="移动构造函数和std::move"></a>移动构造函数和std::move</h5><ul>
<li>移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象</li>
<li>调用标准库函数move（utility头文件）表示希望使用移动构造函数</li>
</ul>
<h6 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h6><ul>
<li><strong>右值引用是指必须绑定到右值的引用</strong>，通过<code>&amp;&amp;</code>获得</li>
<li>右值引用只能绑定到将要销毁的对象，因此可以将一个将要销毁的资源移动到另一个对象中</li>
<li>左值引用不能绑定到要求转换的表达式、字面常量、返回右值的表达式（变量是左值）</li>
<li>右值引用有相反的要求；一般右值生命周期短（字面常量、临时对象等）</li>
<li>通过move函数显式地将左值转换为对应的右值引用类型，使用move不用using声明，直接用<code>std::move</code></li>
<li>右值引用做形参时不能为const，因为需要窃取他的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;r1 = <span class="number">42</span>; <span class="comment">// correct</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r2 = r1;  <span class="comment">// wrong, 变量表达式r1是左值</span></span><br><span class="line"><span class="comment">// 调用move后，意味着除了对r1赋值、销毁外，将不再使用它</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r3 = std::move(r1); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<h5 id="移动构造函数、移动赋值运算符"><a href="#移动构造函数、移动赋值运算符" class="headerlink" title="移动构造函数、移动赋值运算符"></a>移动构造函数、移动赋值运算符</h5><ul>
<li>移动构造函数的<strong>第一个参数是该类型的一个右值引用</strong></li>
<li>必须确保移动后，源对象处于销毁无害的状态，也就是说<strong>源对象必须不再指向被移动的资源</strong>（指针置为nullptr，因为源对象可以被销毁，如果它的指针还指向被移动的资源，执行析构函数时就会将被移动的资源释放）</li>
<li>移动操作<strong>通常</strong>不抛出异常。编写不抛出异常的移动操作，应该使用<code>noexcept</code>通知标准库，免去其为了处理可能存在的异常做的额外工作（可能出现异常的还是不要写比较好）</li>
<li><code>noexcept</code>出现在参数列表之后；如果是构造函数，其在初始化列表的<code>:</code>之前</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">A::A(A &amp;&amp;a) noexcept : x(a.x), y(x.y) &#123;</span><br><span class="line">    a.x = a.y = nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A &amp;A::operator=(A &amp;&amp; a) noexcept &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;a) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 自赋值</span></span><br><span class="line">    free();   <span class="comment">// 释放现在对象的资源</span></span><br><span class="line">    x = a.x;</span><br><span class="line">    y = a.y;</span><br><span class="line">    a.x = a.y = nullptr;  <span class="comment">// 重置源对象的指针</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员；也可以移动有对应移动操作的类成员</strong></li>
<li>移到构造函数永远不会隐式地定义为删除的函数（delete）</li>
<li>如果显式要求编译器生成<code>=default</code>的移动操作，但编译器不能移动所有成员，则编译器将移动操作定义为删除的</li>
<li>类本身的析构函数为删除的、不可访问的，则其移动构造函数为删除的</li>
<li>如果类成员是const的或者是引用，则类的移动赋值运算符定义为删除的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct X &#123;</span><br><span class="line">    <span class="keyword">int</span> i;               <span class="comment">// 内置成员可以移动</span></span><br><span class="line">    std::string s;   <span class="comment">//  string有自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line">struct Y &#123;</span><br><span class="line">    X mem;     <span class="comment">// X有合成移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x1, x = std::move(x1);   <span class="comment">// 合成移动构造函数</span></span><br><span class="line">Y y1, y = std::move(y1);   <span class="comment">// 使用合成移动构造函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>既有拷贝构造函数也有移动构造函数时，遵循<strong>移动右值，拷贝左值</strong>的方法</li>
<li>没有移动构造函数时，右值也被拷贝</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A  a1, a2;</span><br><span class="line">a1 = a2;  <span class="comment">// a2是左值，使用拷贝</span></span><br><span class="line"><span class="function">A <span class="title">getA</span><span class="params">(istream&amp; is)</span></span>;  <span class="comment">// 函数getA返回一个右值</span></span><br><span class="line">a2 = getA();      <span class="comment">// 返回右值，使用移动赋值</span></span><br></pre></td></tr></table></figure>
<h6 id="移动迭代器"><a href="#移动迭代器" class="headerlink" title="移动迭代器"></a>移动迭代器</h6><ul>
<li>一般的迭代器解引用操作返回一个指向元素的左值，<strong>移动迭代器的解引用操作生成一个右值引用</strong></li>
<li>调用<code>make_move_iterator</code>将一个普通迭代器转化为一个移动迭代器，原迭代器的所有操作在移动迭代器中都正常工作</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto first = alloc.allocate(new_capacity);</span><br><span class="line"><span class="comment">// 使用移动构造函数来构造每个元素</span></span><br><span class="line">auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);</span><br></pre></td></tr></table></figure>
<h6 id="右值、左值引用成员函数、重载和引用函数"><a href="#右值、左值引用成员函数、重载和引用函数" class="headerlink" title="右值、左值引用成员函数、重载和引用函数"></a>右值、左值引用成员函数、重载和引用函数</h6><ul>
<li>类成员函数的参数列表后可以放置<code>&amp;</code>或<code>&amp;&amp;</code>，称为引用限定符</li>
<li>引用限定符指出<code>this</code>可以指向一个左值或右值</li>
<li>引用限定符只能用在非static成员函数中（类似const限定符），且必须在声明、定义中都出现</li>
<li><strong>引用限定符就是限制调用成员函数的对象有引用限定</strong></li>
<li><code>&amp;</code>限定的函数，只能将这个函数用于左值；<code>&amp;&amp;</code>则只能用于右值</li>
<li>同时有const限定符的函数，引用限定符应该在const限定符之后<code>const &amp;</code></li>
<li>引用限定符可以区分重载版本（const也可以），表示其对象是右值还是左值</li>
<li>定义两个及以上具有相同名字和参数列表的函数，就必须对所有函数加上引用限定符，或者所有都不加。（有的加，有的不加不行）</li>
</ul>
<p><strong>右值执行排序，可以直接进行，因为右值没有其他用户，可以改变；但是，对const右值、左值进行排序时，不能改变对象，所以先拷贝再排序。</strong></p>
<h4 id="重载运算与类型转换"><a href="#重载运算与类型转换" class="headerlink" title="重载运算与类型转换"></a>重载运算与类型转换</h4><ul>
<li>运算符作用域内置类型的运算对象时，运算符的含义无法改变（不能重载）</li>
<li>只能重载已有的运算符</li>
<li>不能被重载的运算符包括<code>::        .*        .        ?:</code></li>
<li>下标运算符<code>[]</code>返回的是元素的引用</li>
</ul>
<h5 id="输入输出运算符"><a href="#输入输出运算符" class="headerlink" title="输入输出运算符"></a>输入输出运算符</h5><ul>
<li>输入、输出运算符必须是非成员函数</li>
<li>一般地，重载输出运算符<code>&lt;&lt;</code>函数的第一个参数是一个非常量<code>ostream</code>对象引用（非常量是因为向流写入内容会改变其状态，引用是因为ostream不能拷贝），第二个参数一般是要打印对象的常量引用；函数返回ostream的形参</li>
<li>重载输入运算符函数的第二个参数<strong>非常量对象的引用</strong>，返回istream的形参</li>
<li>重载输入运算符要处理可能失败的情况，输出则不需要</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ostream&amp; operator&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> A&amp; a) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">istream&amp; operator&gt;&gt;(istream&amp; is, A&amp; a) &#123;</span><br><span class="line">    <span class="comment">// .... 包括处理失败情况</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="递增递减运算符"><a href="#递增递减运算符" class="headerlink" title="递增递减运算符"></a>递增递减运算符</h5><ul>
<li>区分前置、后置的办法是：<strong>后置版本有一个不被使用的int类型形参</strong></li>
<li>后置版本需要先记录对象的状态，操作完成后返回之前记录的状态</li>
<li><strong>后置运算符返回对象的原值</strong>，不是引用</li>
<li>显式调用后置运算符需要多加一个参数: <code>a.operator++(0);</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A&amp; operator++();    <span class="comment">// 前置</span></span><br><span class="line">A operator++(<span class="keyword">int</span>);  <span class="comment">// 后置，有形参，返回原值</span></span><br><span class="line"></span><br><span class="line">A A::operator++() &#123;</span><br><span class="line">    A ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">// 返回之前的记录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h5><ul>
<li>包括解引用<code>*</code>和箭头运算符<code>-&gt;</code>两种</li>
<li><code>-&gt;</code>必须是类成员，解引用通常是类成员</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">string&amp; operator*() <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="comment">// 检查curr是否在有效范围内，如果是，返回curr所知元素的引用</span></span><br><span class="line">    auto p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">    <span class="keyword">return</span> (*p)[curr];          <span class="comment">// *p是对象所指的vector</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string * operator-&gt;() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">// 将工作委托给解引用运算符</span></span><br><span class="line">    <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;operator*();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="函数调用运算符"><a href="#函数调用运算符" class="headerlink" title="函数调用运算符"></a>函数调用运算符</h5><ul>
<li>重载函数调用运算符就可以向调用函数一样使用类对象</li>
<li>由于可以像使用函数对象那样使用，重载调用运算符可以替代lambda表达式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">absInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;   <span class="comment">// 注意参数放在后面的括号里</span></span><br><span class="line">        <span class="keyword">return</span> val&lt;<span class="number">0</span>? -val:val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">absInt ai;</span><br><span class="line">ai(-<span class="number">10</span>);  <span class="comment">// 返回10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stable_sort(words.begin(), words.end(), [](<span class="keyword">const</span> string&amp; s1, <span class="keyword">const</span> string&amp; s2)&#123;<span class="keyword">return</span> s1.size &lt; s2.size()&#125;;);</span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">short_string</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">bool <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> string&amp; s1, <span class="keyword">const</span> string&amp; s2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.size &lt; s2.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// short_string()构造一个对象，由于重载了调用运算符，就可以看作"可调用对象"使用</span></span><br><span class="line">stable_sort(words.begin(), words.end(), short_string());</span><br></pre></td></tr></table></figure>
<h6 id="标准库定义的函数对象"><a href="#标准库定义的函数对象" class="headerlink" title="标准库定义的函数对象"></a>标准库定义的函数对象</h6><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符（所以其对象也可以被“调用”）。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>算术</th>
<th>关系</th>
<th>逻辑</th>
</tr>
</thead>
<tbody>
<tr>
<td>plus<t></t></td>
<td>equal_to<t></t></td>
<td>logical_and<t></t></td>
</tr>
<tr>
<td>minus<t></t></td>
<td>not_equal_to<t></t></td>
<td>logical_or<t></t></td>
</tr>
<tr>
<td>multiplies<t></t></td>
<td>greater<t></t></td>
<td>logical_not<t></t></td>
</tr>
<tr>
<td>divides<t></t></td>
<td>greater_equal<t></t></td>
<td></td>
</tr>
<tr>
<td>modules<t></t></td>
<td>less<t></t></td>
<td></td>
</tr>
<tr>
<td>megate<t></t></td>
<td>less_equal<t></t></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">plus&lt;<span class="keyword">int</span>&gt; intadd;</span><br><span class="line">intadd(<span class="number">10</span>, <span class="number">15</span>);  <span class="comment">// 25</span></span><br><span class="line"></span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; intnegate;</span><br><span class="line">intnegate(<span class="number">10</span>);  <span class="comment">// -10</span></span><br><span class="line">intnegate(intadd(<span class="number">10</span>,<span class="number">15</span>));  <span class="comment">// -25</span></span><br><span class="line"></span><br><span class="line">sort(vec.begin(), vec.end(), greater&lt;string&gt;());</span><br><span class="line"><span class="comment">// 如果vector里面是string*也照样可以</span></span><br><span class="line">sort(vec.begin(), vec.end(), greater&lt;string*&gt;());</span><br></pre></td></tr></table></figure>
<h6 id="可调用对象与function"><a href="#可调用对象与function" class="headerlink" title="可调用对象与function"></a>可调用对象与function</h6><p>C++中的可调用对象包括：<strong>函数、函数指针、lambda表达式、bind创建的对象、重载了调用运算符的类</strong></p>
<ul>
<li>function类型定义在<code>functional</code>头文件中，是一个模板</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function&lt;T&gt; f;  <span class="comment">// f是用来存储可调用对象的空的function，T限定函数类型（T就是`返回值 (各个参数)`）</span></span><br><span class="line"><span class="function">function&lt;T&gt; <span class="title">f</span><span class="params">(nullptr)</span></span>;  <span class="comment">//  显式构造一个空的function</span></span><br><span class="line"><span class="function">function&lt;T&gt; <span class="title">f</span><span class="params">(obj)</span></span>;  <span class="comment">// f中存储可调用对象obj的副本</span></span><br><span class="line">f                               <span class="comment">// f中有可调用对象为真，否则为假</span></span><br><span class="line">f(args);                    <span class="comment">// 调用f中的对象，args是参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义为function&lt;T&gt;的成员类型</span></span><br><span class="line">result_type       <span class="comment">// 可调用对象的返回类型</span></span><br><span class="line">argument_type <span class="comment">// T一个实参时，实参的类型</span></span><br><span class="line">first_argument_type, second_argument_type</span><br></pre></td></tr></table></figure>
<p>使用示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;    <span class="comment">// 函数指针</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = divide(); <span class="comment">// 重载了调用运算符的类的对象</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123;<span class="keyword">return</span> i+j;&#125;;  <span class="comment">// lambda表达式</span></span><br><span class="line"></span><br><span class="line">f1(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">f2(<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">f3(<span class="number">3</span>,<span class="number">4</span>);</span><br></pre></td></tr></table></figure></p>
<h5 id="重载、类型转换与运算符"><a href="#重载、类型转换与运算符" class="headerlink" title="重载、类型转换与运算符"></a>重载、类型转换与运算符</h5><ul>
<li>可以通过定义类类型转换运算符达到类类型转换的效果</li>
<li>转换构造函数和类型转换运算符共同定义了类类型转换</li>
</ul>
<h6 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h6><ul>
<li><strong>类型转换运算符是类成员函数</strong></li>
<li>可以面向除了<code>void*</code>之外的任意类型进行定义，只要该类型能作为函数的返回类型（数组、函数类型就不行）</li>
<li>一般形式<code>operator type() const</code></li>
<li>类型转换运算符是<strong>隐式执行</strong>的，没有形参，不能传递实参，不能指定返回类型</li>
<li>可能产生意外结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">smallInt</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    smallInt(<span class="keyword">int</span> i=<span class="number">0</span>) : val(i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="number">0</span> || i&gt;<span class="number">255</span>) <span class="keyword">throw</span> std::out_of_range(<span class="string">"Invalid value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">operator <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> operator <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// wrong，不能有返回类型</span></span><br><span class="line">    <span class="function">operator <span class="title">int</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// wrong，不能有形式参数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::size_t val;</span><br><span class="line">&#125;</span><br><span class="line">smallInt si;</span><br><span class="line">si = <span class="number">4</span>;  <span class="comment">// 先将4隐式转换为smallInt，再调用赋值运算符</span></span><br><span class="line">si+<span class="number">3</span>;    <span class="comment">// 先将si隐式转换为int，再执行整数加法</span></span><br><span class="line"></span><br><span class="line">smallInt s = <span class="number">3.14</span>;  <span class="comment">// 内置类型转换double-&gt;int，再调用smallInt(int)构造</span></span><br><span class="line">s+<span class="number">3.14</span>                <span class="comment">// smallInt先转成int，内置类型再将int转换成double</span></span><br></pre></td></tr></table></figure>
<p>由于隐式转换可能会带来意想不到的结果，所以有时候需要使用<strong>显式的类型转换运算符</strong>。定义显式类型转换运算符只需要加上<code>explicit</code>即可，但转换时就行必须使用显式的强制转换方式。<br><strong>有一个例外：当表达式被用作条件判断（<code>if, while, do, for, &amp;&amp;, ||, !, ?:</code>），编译器会将显式的类型转换自动用于它，也就是会隐式执行</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">explicit operator <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val;&#125;  <span class="comment">// 改变的类型转换运算符</span></span><br><span class="line"></span><br><span class="line">smallInt si = <span class="number">3</span>; <span class="comment">// ok</span></span><br><span class="line">si+<span class="number">3</span>                 <span class="comment">// wrong，此处需要隐式转换，但转换函数是显式的</span></span><br><span class="line">static_cast&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>  <span class="comment">// 显示请求转换</span></span><br></pre></td></tr></table></figure></p>
<p>IO类型可以向void*转换，C++11下支持将IO类型向bool显式类型转换，IO类型向bool的转换一般定义成显式（explicit），因为通常用在条件判断部分，所以也可以隐式执行。</p>
<h6 id="二义性问题"><a href="#二义性问题" class="headerlink" title="二义性问题"></a>二义性问题</h6><p>二义性类型转换的途径</p>
<ul>
<li>两个类提供了相同的类型转换（分别通过构造函数和类型转换运算符）</li>
<li>定义了多个转换规则，这些转换<strong>涉及的类型本身可以通过其他类型转换联系在一起</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A(<span class="keyword">int</span> = <span class="number">0</span>); <span class="comment">// 最好不要创建两个转换源都是算术类型的类型转换</span></span><br><span class="line">    A(<span class="keyword">double</span>);</span><br><span class="line">    <span class="function">operator <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;  <span class="comment">// 最好不要创建两个转换对象都是算术类型的类型转换</span></span><br><span class="line">    <span class="function">operator <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// other member</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">f2(a);  <span class="comment">// 二义性错误，两个类型转换函数都可以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>;  <span class="comment">// 二义性，编译器无法区分long转int和double的好坏</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> s = <span class="number">42</span>;</span><br><span class="line"><span class="function">A <span class="title">a3</span><span class="params">(s)</span></span>;  <span class="comment">//ok, 使用A::A(int)</span></span><br></pre></td></tr></table></figure>
<p>但是short转int确实比short转double好</p>
<p><strong>重载函数于转换构造函数</strong></p>
<ul>
<li>如果两个或多个类型的转换都提供了同一种可行的匹配，则这些类型转换一样好</li>
<li><strong>即使其中一个能精确匹配，另一个需要额外的标准类型转换，编译器也会将其表示为二义性错误</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct C &#123;</span><br><span class="line">    C(<span class="keyword">int</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">struct D &#123;</span><br><span class="line">    D(ing);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> D&amp;)</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">//二义性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------分割线----------------------------------</span></span><br><span class="line"></span><br><span class="line">struct E &#123;</span><br><span class="line">    E(<span class="keyword">double</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> E&amp;)</span></span>;</span><br><span class="line">f(<span class="number">10</span>);  <span class="comment">// 依旧二义性错误，即使其中一个能精确匹配，另一个需要额外的标准类型转换，编译器也会将其表示为二义性错误</span></span><br></pre></td></tr></table></figure>
<p>函数匹配与重载运算符</p>
<ul>
<li>表达式中运算符的候选函数集包括成员函数和非成员函数</li>
<li><strong>如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">friend A operator+(<span class="keyword">const</span> A&amp; a, <span class="keyword">const</span> A&amp; b);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">    <span class="function">operator <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> val&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    size_t val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A a1, a2;</span><br><span class="line">A a3 = s1 + s2;  <span class="comment">// 使用重载的operator+</span></span><br><span class="line"><span class="keyword">int</span> i = s3 + <span class="number">1</span>;    <span class="comment">//  二义性错误</span></span><br></pre></td></tr></table></figure>
<h4 id="面向对象程序设计-OOP"><a href="#面向对象程序设计-OOP" class="headerlink" title="面向对象程序设计 OOP"></a>面向对象程序设计 OOP</h4><ul>
<li>OOP的核心思想是<strong>数据抽象、继承和动态绑定</strong></li>
</ul>
<h5 id="基类与派生类（父类与子类）"><a href="#基类与派生类（父类与子类）" class="headerlink" title="基类与派生类（父类与子类）"></a>基类与派生类（父类与子类）</h5><ul>
<li>子类经常覆盖父类中的虚函数，如果不覆盖，子类将直接继承父类的版本</li>
<li>能把子类对象当成父类对象来用，也能把父类的指针或引用绑定到子类对象的父类部分上</li>
<li>子类构造函数先初始化父类部分，然后按照声明顺序依次初始化子类成员</li>
<li><strong>派生类可以访问基类的公有和受保护成员</strong></li>
</ul>
<hr>
<ul>
<li>基类中的静态成员在整个继承体系中都只存在该成员的唯一定义，如果是private的，派生类就不能访问</li>
<li><strong>声明派生类时不能加上派生列表</strong></li>
<li>派生类一定要有定义，类不能派生自己</li>
<li>使用final关键字可以禁止类被继承</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span> </span>&#123;&#125;;</span><br><span class="line">class A final : public father &#123;&#125;;  // ok, 但A不能被继承</span><br><span class="line">class B : public A&#123;&#125;;  // 错误，A是final的</span><br></pre></td></tr></table></figure>
<ul>
<li>派生类向基类的自动类型转换只对指针、引用类型有效</li>
<li>用派生类对象为基类对象初始化或者赋值时，其派生类独有的部分会被忽略</li>
</ul>
<h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><ul>
<li>运行时动态绑定</li>
<li>所有虚函数都必须有定义</li>
<li>派生类中的虚函数可以不加<code>virtual</code>关键字，因为一旦某个函数被声明为虚函数，他在所有派生类中都是虚函数</li>
<li>覆盖基类虚函数的派生类函数必须在形参上与派生类完全一致</li>
<li><code>override</code>关键字用来说明派生类中的虚函数</li>
<li><code>final</code>关键字阻止函数派生类覆盖此函数</li>
<li>如果虚函数使用默认实参，实参由本次调用的静态类型决定（使用基类的指针就用基类的虚函数默认实参），所以最好定义派生类、基类虚函数的默认实参一致</li>
<li>回避虚函数机制，可使用作用域运算符机制</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function">virtual <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">class B : A &#123;</span><br><span class="line"><span class="function">virtual <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">final</span></span>;  <span class="comment">// 不允许后续的其他类覆盖f1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A * a = <span class="keyword">new</span> B();</span><br><span class="line">a-&gt;f1();  <span class="comment">// 调用B类中的虚函数f1</span></span><br><span class="line">a-&gt;A::f1();  <span class="comment">// 无论a类型是什么，都是用A中的虚函数f1</span></span><br></pre></td></tr></table></figure>
<h5 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h5><ul>
<li>抽象基类负责定义接口，不能直接创建其对象</li>
</ul>
<h6 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h6><ul>
<li>在函数声明加上<code>=0</code>就可以将函数声明为纯虚函数</li>
<li>纯虚函数无需定义，非要定义的话必须在类的外部</li>
</ul>
<h5 id="访问控制与继承"><a href="#访问控制与继承" class="headerlink" title="访问控制与继承"></a>访问控制与继承</h5><h6 id="受保护的成员-protected"><a href="#受保护的成员-protected" class="headerlink" title="受保护的成员 protected"></a>受保护的成员 protected</h6><ul>
<li>类的用户不能访问受保护的成员，私有的更不行</li>
<li>派生类的成员、友元可访问继承来的protected、public成员，private不行</li>
<li><strong>派生类的成员、友元只能通过派生类对象访问基类的受保护成员。派生类无法访问基类对象中的受保护成员</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class base &#123;</span><br><span class="line">protected:</span><br><span class="line">    int mem;</span><br><span class="line">&#125;;</span><br><span class="line">class sneak : base &#123;</span><br><span class="line">    friend void get(sneak&amp;);  // 可以通过自身对象访问基类的受保护部分</span><br><span class="line">    friend void get(base&amp;);   // 不能访问基类对象中的受保护成员</span><br><span class="line">    int j; // private</span><br><span class="line">&#125;;</span><br><span class="line">void get(sneaky&amp; s)&#123;s.j = s.mem = 0;&#125;</span><br><span class="line">void get(base &amp;b) &#123;b.mem = 0;&#125;  // 错误，不能访问</span><br></pre></td></tr></table></figure>
<ul>
<li>派生类对其继承而来的成员的访问权限收到两个因素影响：<ul>
<li>基类中该成员的访问说明符</li>
<li>派生类的派生列表中的访问说明符</li>
</ul>
</li>
<li><strong>派生访问说明符对于派生类的成员及其友元能否访问直接基类的成员没什么影响</strong>，<strong>其对基类成员的访问权限只与基类中的访问说明符有关</strong></li>
<li><strong>派生访问说明符的目的是控制派生类用户（包括派生类的派生类）对于基类成员的访问权限</strong><ul>
<li>如果继承是公有的，成员遵循原有的访问说明符</li>
<li>如果继承是私有的，则所有对象都是私有的</li>
<li>如果继承是protected的，原本public的称为protected的</li>
</ul>
</li>
</ul>
<hr>
<p><strong>派生类向基类转换的可访问性</strong>（假定D继承自B）</p>
<ul>
<li>只有继承方式是public，用户代码才能使用派生类向基类的转换</li>
<li>无论以什么方式继承，D的成员和友元都能使用派生类向基类的转换</li>
<li>如果D以public或protected方式继承B，则D的派生类的成员和友元可以使用D向B的转换</li>
<li>要改变个别成员的可访问性，可使用<code>using</code>关键字</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> mem, n;</span><br><span class="line">&#125;;</span><br><span class="line">class derived : private base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    using base::mem;</span><br><span class="line">protect:</span><br><span class="line">    using base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<p>友元与继承</p>
<ul>
<li>友元关系不能继承</li>
</ul>
<h5 id="继承中的类作用域"><a href="#继承中的类作用域" class="headerlink" title="继承中的类作用域"></a>继承中的类作用域</h5><ul>
<li>先名字查找再类型检查（p-&gt;mem(), obj.mem()）<ol>
<li>确定p的静态类型，因为调用的是成员，该类型必然是类类型</li>
<li>在p的静态类型对应的类中查找mem，找不到则直接基类中查找直到继承链最顶端。还是找不到就报错</li>
<li>一旦找到mem，就进行常规的类型检查以确认本次调用是否合法</li>
<li>如果调用合法，则编译器将根据调用的是否是虚函数产生不同的代码</li>
</ol>
</li>
<li>内层作用域的函数不会重载声明在外层作用域的函数</li>
<li>名字查找过程中，<strong>派生类会隐藏基类的同名成员（即使形参列表不一样）</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">class derived : private base&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// 隐藏了基类的f()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">base b; derived d;</span><br><span class="line">d.f(<span class="number">10</span>);  <span class="comment">// ok</span></span><br><span class="line">d.f();      <span class="comment">// wrong，参数列表为空的f函数被隐藏了</span></span><br></pre></td></tr></table></figure>
<h5 id="拷贝函数与拷贝控制"><a href="#拷贝函数与拷贝控制" class="headerlink" title="拷贝函数与拷贝控制"></a>拷贝函数与拷贝控制</h5><h6 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h6><ul>
<li>派生类会继承基类析构函数的虚属性</li>
<li>基类虚析构函数能保证delete基类指针时使用正确的析构函数版本</li>
<li>定义了虚析构函数的类，编译器就不会为其合成移动操作</li>
</ul>
<h6 id="派生类中删除的拷贝控制与基类的关系"><a href="#派生类中删除的拷贝控制与基类的关系" class="headerlink" title="派生类中删除的拷贝控制与基类的关系"></a>派生类中删除的拷贝控制与基类的关系</h6><ul>
<li>基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或不可访问的，则派生类中对应的成员将是删除的</li>
<li>基类中的析构函数是不可访问或删除的，那么派生类中的合成的默认和拷贝构造函数都是删除的</li>
<li>基类中对应操作是删除的，派生类中的也会是删除的（比如说移动构造函数）</li>
</ul>
<h6 id="移动操作与继承"><a href="#移动操作与继承" class="headerlink" title="移动操作与继承"></a>移动操作与继承</h6><ul>
<li>带有虚析构函数的类，编译器不会为其合成移动操作，所以其子类也没有</li>
<li>确实需要移动操作时，可以显式地定义（可以使用合成版本）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() = <span class="keyword">default</span>;   <span class="comment">// 默认构造</span></span><br><span class="line">    A(<span class="keyword">const</span> A&amp;) = <span class="keyword">default</span>;   <span class="comment">// 拷贝构造</span></span><br><span class="line">    A(A&amp;&amp;) = <span class="keyword">default</span>;        <span class="comment">// 移动构造</span></span><br><span class="line">    A&amp; operator=(<span class="keyword">const</span> A&amp;) = <span class="keyword">default</span>;   <span class="comment">// 拷贝赋值</span></span><br><span class="line">    A&amp; operator=(A&amp;&amp;) = <span class="keyword">default</span>;        <span class="comment">// 移动赋值</span></span><br><span class="line">    virtual ~A();</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="派生类的拷贝控制"><a href="#派生类的拷贝控制" class="headerlink" title="派生类的拷贝控制"></a>派生类的拷贝控制</h6><ul>
<li>派生类在拷贝、移动的同时要拷贝、移动基类部分(显式地)</li>
<li>派生类赋值运算符的处理方法也类似</li>
<li>派生类的析构函数只负责销毁派生类自己分配的资源</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base</span> </span>&#123;&#125;;</span><br><span class="line">class D : private base&#123;</span><br><span class="line">    D(<span class="keyword">const</span> D&amp; d) : base(d), <span class="comment">/*D的成员初始值*/</span> &#123;...&#125; <span class="comment">// d作为参数将被绑定到类型为base&amp;的实参上</span></span><br><span class="line">    D(D&amp;&amp; d) : base(std::move(d)), <span class="comment">/*D的成员初始值*/</span> &#123;...&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">D&amp; D::operator= (<span class="keyword">const</span> D&amp; d) &#123;</span><br><span class="line">    base::operator=(d);  <span class="comment">// 为基类部分赋值</span></span><br><span class="line">    <span class="comment">// 酌情处理自赋值、释放已有资源</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="在构造函数和虚构函数中调用虚函数"><a href="#在构造函数和虚构函数中调用虚函数" class="headerlink" title="在构造函数和虚构函数中调用虚函数"></a>在构造函数和虚构函数中调用虚函数</h6><ul>
<li><strong>如果构造函数或析构函数调用了某个虚函数，则程序会执行与调用构造函数或析构函数所属类型相对应的虚函数版本</strong></li>
<li>这个例子：创建派生类对象时，先调用基类的构造函数，此时对象的派生类部分是未被初始化的，调用派生类的虚函数存在风险，所以应该调用基类的虚函数。</li>
</ul>
<h6 id="继承的构造函数"><a href="#继承的构造函数" class="headerlink" title="继承的构造函数"></a>继承的构造函数</h6><ul>
<li>一个类可以继承其直接基类的构造函数</li>
<li>类不能继承默认、移动、拷贝构造函数</li>
<li>继承方式是使用<code>using base::base;</code>就可以继承base的构造函数，对于基类的构造函数，编译器将会为派生类与之对应的派生类版本<code>derived(params) : base(args) {}</code></li>
<li>构造函数的using声明不会改变该构造函数的访问级别（私有还是私有，公有还是共有）</li>
<li>当基类构造函数有默认实参，派生类将获得多个构造函数，每个构造函数省略掉一个含有默认实参的形参</li>
<li>派生类不继承某些构造函数的原因可能是：<ul>
<li>派生类自己定义了有相同参数列表的构造函数</li>
<li>默认、移动、拷贝构造函数按照正常规则被合成</li>
</ul>
</li>
</ul>
<h6 id="容器与继承"><a href="#容器与继承" class="headerlink" title="容器与继承"></a>容器与继承</h6><ul>
<li>不能把具有继承关系的对象放在一个容器中</li>
<li>在容器中放置（智能）指针而非对象</li>
<li>派生类的（智能）指针可以隐式转换为基类的（智能）指针</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;shared_ptr&lt;quote&gt;&gt; basket;</span><br><span class="line">basket.push_back(make_shared&lt;quote&gt;(<span class="string">"00001"</span>, <span class="number">50</span>));</span><br><span class="line">basket.push_back(make_shared&lt;derived_quote&gt;(<span class="string">"972719"</span>, <span class="number">35</span>, <span class="number">21</span>, <span class="number">7</span>));</span><br></pre></td></tr></table></figure>
<h5 id="多重继承与虚继承"><a href="#多重继承与虚继承" class="headerlink" title="多重继承与虚继承"></a>多重继承与虚继承</h5><h6 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h6><ul>
<li>每个基类包含一个可选的访问说明符</li>
<li>关键字<code>class</code>的默认访问说明符是<code>private</code>，<code>struct</code>的默认访问说明符是<code>public</code></li>
<li>派生类的对象包含每个基类的子对象，派生类的构造函数初始值只能初始化它的直接基类</li>
<li><strong>基类的构造顺序与派生列表中的基类出现的顺序一致</strong></li>
<li>多重构造在析构时，顺序与构造时相反，派生类的析构函数只负责销毁自己的部分</li>
<li>派生列表中，同一个基类只能出现一次</li>
</ul>
<p><strong>多重继承构造函数的继承</strong></p>
<ul>
<li>C++11中允许派生类从他的基类中继承构造函数</li>
<li>如果继承的多个构造函数相同（形参列表完全相同），程序产生错误</li>
<li>如果不想上述错误出现，这个类必须为该构造函数定义它自己的版本</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct base1 &#123;</span><br><span class="line">    base1() = <span class="keyword">default</span>;</span><br><span class="line">    base1(<span class="keyword">const</span> string&amp;);</span><br><span class="line">&#125;;</span><br><span class="line">struct base2 &#123;</span><br><span class="line">base2() = <span class="keyword">default</span>;</span><br><span class="line">base2(<span class="keyword">const</span> string&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// D1尝试继承两个基类中的参数为 const string&amp; 的构造函数</span></span><br><span class="line">struct D1 : <span class="keyword">public</span> base1, <span class="keyword">public</span> base2 &#123;</span><br><span class="line">    using base1::base1;  <span class="comment">// 继承base1</span></span><br><span class="line">    using base2::base2;  <span class="comment">// 继承base2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct D2 : <span class="keyword">public</span> base1, <span class="keyword">public</span> base2 &#123;</span><br><span class="line">    using base1::base1;  <span class="comment">// 继承base1</span></span><br><span class="line">    using base2::base2;  <span class="comment">// 继承base2</span></span><br><span class="line">    <span class="comment">// 定义自己的 参数为 const string&amp; 的构造函数</span></span><br><span class="line">    D2(<span class="keyword">const</span> string&amp; s) : base1(s), base2(s);</span><br><span class="line">    D2() = <span class="keyword">default</span>;  <span class="comment">// 一旦D2定义了自己的构造函数，就必须出现这个</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="类型转换与多个基类"><a href="#类型转换与多个基类" class="headerlink" title="类型转换与多个基类"></a>类型转换与多个基类</h6><ul>
<li>可以使某个可访问的基类的指针、引用直接指向一个派生类的对象</li>
<li>编译器认为基类们向派生类的转换不分优劣，因此可能会产生二义性错误</li>
</ul>
<h6 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h6><ul>
<li>派生类可能通过直接基类间接继承自同一个间接基类，所以派生类对象会包含两份间接基类的对象</li>
<li>虚继承可以解决上述问题，<strong>其目的是令某个类作出声明，承诺愿意共享它的基类</strong></li>
<li>共享的基类称为虚基类</li>
<li><strong>含有虚基类的对象构造顺序：虚基类总是先于非虚基类构造</strong></li>
<li>先虚：虚子对象按照他们在派生列表中出现的顺序从左向右出现，然后才是非虚对象从左向右</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// base是D1、D2的虚基类</span></span><br><span class="line">class D1 : public virtual base &#123;&#125;;</span><br><span class="line">class D2 : virtual public base &#123;&#125;;</span><br></pre></td></tr></table></figure>
<pre><code>class Character {};
class BookCharacter : public Character{};
class ZooAnimal {};
class Bear : public ZooAnimal{};
class ToyAnimal{};
class TeddyBear : public BookCharacter, public Bear, public virtual ToyAnimal{};
// 构造TeddyBear时，构造顺序如下：
ZooAnimal();
ToyAnimal();
Character();
BookCharacter();
Bear();
TeddyBear();
</code></pre><h4 id="标准库特殊设施"><a href="#标准库特殊设施" class="headerlink" title="标准库特殊设施"></a>标准库特殊设施</h4><h5 id="bitset类"><a href="#bitset类" class="headerlink" title="bitset类"></a>bitset类</h5><p><code>#include &lt;bitset&gt;</code></p>
<h6 id="定义与初始化"><a href="#定义与初始化" class="headerlink" title="定义与初始化"></a>定义与初始化</h6><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>bitset&lt;n&gt; b</code></td>
<td><code>b有n位，每一位均是0。此构造函数为constexpr</code></td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(u)</code></td>
<td><code>b是unsigned long long值u的低n位的拷贝，如果u没有n位，则补0。此构造函数为constexpr</code></td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(s, pos, m, zero, one)</code></td>
<td><code>explicit型。从string s的pos（默认为0）位置开始的m（默认为string::npos）个字符，s中只能包含zero（默认&#39;0&#39;）和one（默认&#39;1&#39;）</code></td>
</tr>
<tr>
<td><code>bitset&lt;n&gt; b(cp, pos, m, zero, one)</code></td>
<td><code>explicit型。从字符数组cp的pos（默认为0）位置开始的m（默认为string::npos）个字符，cp中只能包含zero（默认&#39;0&#39;）和one（默认&#39;1&#39;）</code></td>
</tr>
</tbody>
</table>
</div>
<h6 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h6><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>b.any()</code></td>
<td><code>b中是否有为1的二进制位</code></td>
<td><code>b.all()</code></td>
<td><code>是否所有的位置都为1</code></td>
</tr>
<tr>
<td><code>b.none()</code></td>
<td><code>b中是否所有的位置都为0</code></td>
<td><code>b.count()</code></td>
<td><code>b中1的个数</code></td>
</tr>
<tr>
<td><code>b.size()</code></td>
<td><code>b中位数总和，constexpr型</code></td>
<td><code>b.test(pos)</code></td>
<td><code>pos位位1：true，否则false</code></td>
</tr>
<tr>
<td><code>b.set(pos, v)</code></td>
<td><code>将pos位置为v(默认true是1)，不带参数pos则设置所有位</code></td>
<td><code>b.reset(pos)</code></td>
<td><code>将pos复位，没有pos则全部复位</code></td>
</tr>
<tr>
<td><code>b.flip(pos)</code></td>
<td><code>反转pos位或者全部反转</code></td>
<td><code>b[pos]</code></td>
<td><code>访问pos位置，如果b是const的，返回true/false布尔值</code></td>
</tr>
<tr>
<td><code>b.to_ulong()</code></td>
<td><code>返回b对应的unsigned long值，放不下则抛出异常</code></td>
<td><code>b.to_ullong()</code></td>
<td><code>返回b对应的unsigned long long值，放不下则抛出异常</code></td>
</tr>
<tr>
<td><code>b.to_string(zero, one)</code></td>
<td><code>将b转换成&#39;0&#39;,&#39;1&#39;组成的string类型</code></td>
<td><code>os&lt;&lt;b</code></td>
<td><code>打印b中的01流</code></td>
</tr>
<tr>
<td><code>is&gt;&gt;b</code></td>
<td><code>从is读入字符存入b，当下一个字符不是&#39;0&#39;,&#39;1&#39;或是已经到达b.size()时停止</code></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<h5 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h5><p><code>#include &lt;random.h&gt;</code></p>
<h6 id="随机数引擎类和随机数分布"><a href="#随机数引擎类和随机数分布" class="headerlink" title="随机数引擎类和随机数分布"></a>随机数引擎类和随机数分布</h6><p>随机数引擎是函数对象类，定义了调用运算符，该运算符不接收参数并返回一个随机unsigned整数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">default_random_engine e;</span><br><span class="line">e();</span><br></pre></td></tr></table></figure></p>
<p>随机数引擎操作如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Engine e</code></td>
<td><code>默认构造函数，使用默认种子</code></td>
</tr>
<tr>
<td><code>Engine e(s)</code></td>
<td><code>使用整型值s作为种子</code></td>
</tr>
<tr>
<td><code>e.seed(s)</code></td>
<td><code>使用种子s重置e的状态</code></td>
</tr>
<tr>
<td><code>e.min()</code></td>
<td><code>此引擎可生成的最小值</code></td>
</tr>
<tr>
<td><code>e.max()</code></td>
<td><code>最大值</code></td>
</tr>
<tr>
<td><code>Engine::result_type</code></td>
<td><code>此引擎生成的unsigned整型类型</code></td>
</tr>
<tr>
<td><code>e.discard(u)</code></td>
<td><code>将引擎推进u步，u的类型位uul</code></td>
</tr>
</tbody>
</table>
</div>
<p>为了得到一个指定范围内的数，使用一个分布类型的对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0-9之间的均匀分布</span></span><br><span class="line"><span class="comment">// u是一个调用运算符，接受一个随机数引擎作为参数</span></span><br><span class="line"><span class="function">unifrom_int_distribution&lt;unsigned&gt; <span class="title">u</span><span class="params">(<span class="number">0</span>, <span class="number">9</span>)</span></span>;</span><br><span class="line">default_random_engine e;</span><br><span class="line">cout &lt;&lt; u(e) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<h6 id="其他随机数分布"><a href="#其他随机数分布" class="headerlink" title="其他随机数分布"></a>其他随机数分布</h6><ul>
<li>使用<code>uniform_real_distribution&lt;double&gt;</code>类型的对象生成随机浮点数，用法类似上面</li>
<li><code>uniform_real_distribution&lt;&gt;</code>默认为<code>double</code>类型</li>
<li>高斯分布：<code>normal_distribution&lt;&gt; n(u, sigma);</code> // 均值为<code>u</code>，标准差为<code>sigma</code></li>
<li><code>lround(a)</code>函数对<code>a</code>进行四舍五入转化为整数，来自头文件<code>cmath</code></li>
<li><code>bernoulli_distribution b(p)</code>一次成功概率为<code>p</code>。它不是模板类（没有<code>&lt;&gt;</code>）</li>
</ul>

        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

    <a data-url="atlantic8.github.io/2017/03/06/Cpp-Rule-Fragment2/" data-id="ckeiowf6z001q4gphffrmxfq1" class="article-share-link"><i class="fas fa-share"></i>分享到</a>
<script>
    (function ($) {
        // Prevent duplicate binding
        if (typeof(__SHARE_BUTTON_BINDED__) === 'undefined' || !__SHARE_BUTTON_BINDED__) {
            __SHARE_BUTTON_BINDED__ = true;
        } else {
            return;
        }
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="fab fa-twitter article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="fab fa-facebook article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="fab fa-pinterest article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="fab fa-google article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

            
    

        </footer>
    </div>
    
</article>



    <nav id="page-nav">
        <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/4/">下一页 &raquo;</a>
    </nav>
</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="">
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/30/NLP-Pre-train-Models-after-Bert/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2020/08/30/NLP-Pre-train-Models-after-Bert/" class="title">NLP Pre-train Models after Bert</a></p>
                            <p class="item-date"><time datetime="2020-08-30T05:16:49.000Z" itemprop="datePublished">2020-08-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/30/XGboost/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2020/08/30/XGboost/" class="title">XGboost</a></p>
                            <p class="item-date"><time datetime="2020-08-30T05:00:24.000Z" itemprop="datePublished">2020-08-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/30/Bert/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2020/08/30/Bert/" class="title">Bert</a></p>
                            <p class="item-date"><time datetime="2020-08-30T04:58:01.000Z" itemprop="datePublished">2020-08-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/30/Transformer/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Algorithm/">Algorithm</a></p>
                            <p class="item-title"><a href="/2020/08/30/Transformer/" class="title">Transformer</a></p>
                            <p class="item-date"><time datetime="2020-08-30T04:53:14.000Z" itemprop="datePublished">2020-08-30</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-thumbnail">
                            <a href="/2020/08/30/First-Order-Optimization/" class="thumbnail">
    
    
        <span class="thumbnail-image thumbnail-none"></span>
    
</a>

                        </div>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Math/">Math</a></p>
                            <p class="item-title"><a href="/2020/08/30/First-Order-Optimization/" class="title">First Order Optimization</a></p>
                            <p class="item-date"><time datetime="2020-08-30T04:46:31.000Z" itemprop="datePublished">2020-08-30</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Algorithm/">Algorithm</a><span class="category-list-count">46</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Dev/">Dev</a><span class="category-list-count">20</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Math/">Math</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/OJ/">OJ</a><span class="category-list-count">55</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">三月 2017</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">十一月 2016</a><span class="archive-list-count">10</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a><span class="archive-list-count">35</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a><span class="archive-list-count">8</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Backtracking/" style="font-size: 11.11px;">Backtracking</a> <a href="/tags/Binary-Search/" style="font-size: 11.11px;">Binary Search</a> <a href="/tags/Binary-Tree/" style="font-size: 16.67px;">Binary Tree</a> <a href="/tags/Cpp/" style="font-size: 15.56px;">Cpp</a> <a href="/tags/DFS/" style="font-size: 10px;">DFS</a> <a href="/tags/DP/" style="font-size: 16.67px;">DP</a> <a href="/tags/Deep-Learning/" style="font-size: 10px;">Deep Learning</a> <a href="/tags/Divide-Conquer/" style="font-size: 10px;">Divide & Conquer</a> <a href="/tags/Game-Theory/" style="font-size: 10px;">Game Theory</a> <a href="/tags/Geometry/" style="font-size: 10px;">Geometry</a> <a href="/tags/Greedy/" style="font-size: 13.33px;">Greedy</a> <a href="/tags/IPython/" style="font-size: 10px;">IPython</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/LeetCode/" style="font-size: 20px;">LeetCode</a> <a href="/tags/Leetcode/" style="font-size: 11.11px;">Leetcode</a> <a href="/tags/MIR/" style="font-size: 10px;">MIR</a> <a href="/tags/Machine-Learning/" style="font-size: 10px;">Machine Learning</a> <a href="/tags/Math/" style="font-size: 12.22px;">Math</a> <a href="/tags/Matlab/" style="font-size: 10px;">Matlab</a> <a href="/tags/NLP/" style="font-size: 13.33px;">NLP</a> <a href="/tags/Optimization/" style="font-size: 10px;">Optimization</a> <a href="/tags/POJ/" style="font-size: 11.11px;">POJ</a> <a href="/tags/Permutation/" style="font-size: 10px;">Permutation</a> <a href="/tags/STL/" style="font-size: 10px;">STL</a> <a href="/tags/Sliding-window/" style="font-size: 14.44px;">Sliding window</a> <a href="/tags/Sort/" style="font-size: 11.11px;">Sort</a> <a href="/tags/State-Machine/" style="font-size: 10px;">State Machine</a> <a href="/tags/String/" style="font-size: 14.44px;">String</a> <a href="/tags/Tree/" style="font-size: 10px;">Tree</a> <a href="/tags/bit/" style="font-size: 10px;">bit</a> <a href="/tags/deep-learning/" style="font-size: 13.33px;">deep learning</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/machine-learning/" style="font-size: 18.89px;">machine learning</a> <a href="/tags/music-information-retrieval/" style="font-size: 10px;">music information retrieval</a> <a href="/tags/numpy/" style="font-size: 11.11px;">numpy</a> <a href="/tags/other/" style="font-size: 10px;">other</a> <a href="/tags/pandas/" style="font-size: 11.11px;">pandas</a> <a href="/tags/prime/" style="font-size: 10px;">prime</a> <a href="/tags/python/" style="font-size: 17.78px;">python</a> <a href="/tags/random-algorithm/" style="font-size: 12.22px;">random algorithm</a> <a href="/tags/recommender-system/" style="font-size: 10px;">recommender system</a> <a href="/tags/time-series-data/" style="font-size: 10px;">time_series_data</a> <a href="/tags/visualization/" style="font-size: 10px;">visualization</a> <a href="/tags/web/" style="font-size: 10px;">web</a> <a href="/tags/数据分析/" style="font-size: 10px;">数据分析</a> <a href="/tags/文件/" style="font-size: 10px;">文件</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="https://xueshu.glgoo.org/">Google Scholar Mirror</a>
                    </li>
                
                    <li>
                        <a href="https://www.kaggle.com/">Kaggle</a>
                    </li>
                
                    <li>
                        <a href="http://mlr.cs.umass.edu/ml/datasets.html">UCI dataset</a>
                    </li>
                
                    <li>
                        <a href="https://leetcode.com/problemset/algorithms/">LeetCode</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fas fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2020 Atlantic8<br>
            Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        </div>
    </div>
</footer>
        


    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</body>
</html>